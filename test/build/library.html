

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>rocALUTION &mdash; ReadTheDocs-Breathe 1.0.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="API" href="api.html" />
    <link rel="prev" title="Welcome to rocALUTION’s documentation!" href="index.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> ReadTheDocs-Breathe
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">rocALUTION</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#contributing">Contributing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#contribution-license-agreement">Contribution License Agreement</a></li>
<li class="toctree-l4"><a class="reference internal" href="#how-to-contribute">How to contribute</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pull-request-guidelines">Pull-request guidelines</a></li>
<li class="toctree-l4"><a class="reference internal" href="#styleguide">StyleGuide</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#building-and-installing">Building and Installing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#installing-from-amd-rocm-repositories">Installing from AMD ROCm repositories</a></li>
<li class="toctree-l3"><a class="reference internal" href="#building-rocalution-from-open-source-repository">Building rocALUTION from Open-Source repository</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#download-rocalution">Download rocALUTION</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-install-sh-to-build-dependencies-library">Using <em>install.sh</em> to build dependencies + library</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-install-sh-to-build-dependencies-library-client">Using <em>install.sh</em> to build dependencies + library + client</a></li>
<li class="toctree-l4"><a class="reference internal" href="#using-individual-commands-to-build-rocalution">Using individual commands to build rocALUTION</a></li>
<li class="toctree-l4"><a class="reference internal" href="#common-build-problems">Common build problems</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#simple-test">Simple Test</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#basics">Basics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#design-and-philosophy">Design and Philosophy</a></li>
<li class="toctree-l3"><a class="reference internal" href="#operators-and-vectors">Operators and Vectors</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#local-operators-and-vectors">Local Operators and Vectors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#global-operators-and-vectors">Global Operators and Vectors</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#functionality-on-the-accelerator">Functionality on the Accelerator</a></li>
<li class="toctree-l3"><a class="reference internal" href="#initialization-of-rocalution">Initialization of rocALUTION</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#thread-core-mapping">Thread-core Mapping</a></li>
<li class="toctree-l4"><a class="reference internal" href="#openmp-threshold-size">OpenMP Threshold Size</a></li>
<li class="toctree-l4"><a class="reference internal" href="#accelerator-selection">Accelerator Selection</a></li>
<li class="toctree-l4"><a class="reference internal" href="#disable-the-accelerator">Disable the Accelerator</a></li>
<li class="toctree-l4"><a class="reference internal" href="#backend-information">Backend Information</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mpi-and-multi-accelerators">MPI and Multi-Accelerators</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#automatic-object-tracking">Automatic Object Tracking</a></li>
<li class="toctree-l3"><a class="reference internal" href="#verbose-output">Verbose Output</a></li>
<li class="toctree-l3"><a class="reference internal" href="#verbose-output-and-mpi">Verbose Output and MPI</a></li>
<li class="toctree-l3"><a class="reference internal" href="#debug-output">Debug Output</a></li>
<li class="toctree-l3"><a class="reference internal" href="#logging">Logging</a></li>
<li class="toctree-l3"><a class="reference internal" href="#versions">Versions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#single-node-computation">Single-node Computation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#code-structure">Code Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#valuetype">ValueType</a></li>
<li class="toctree-l3"><a class="reference internal" href="#complex-support">Complex Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="#allocation-and-free">Allocation and Free</a></li>
<li class="toctree-l3"><a class="reference internal" href="#matrix-formats">Matrix Formats</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#coo-storage-format">COO storage format</a></li>
<li class="toctree-l4"><a class="reference internal" href="#csr-storage-format">CSR storage format</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ell-storage-format">ELL storage format</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dia-storage-format">DIA storage format</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hyb-storage-format">HYB storage format</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memory-usage">Memory Usage</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#file-i-o">File I/O</a></li>
<li class="toctree-l3"><a class="reference internal" href="#access">Access</a></li>
<li class="toctree-l3"><a class="reference internal" href="#raw-access-to-the-data">Raw Access to the Data</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#setdataptr">SetDataPtr</a></li>
<li class="toctree-l4"><a class="reference internal" href="#leavedataptr">LeaveDataPtr</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#copy-csr-matrix-host-data">Copy CSR Matrix Host Data</a></li>
<li class="toctree-l3"><a class="reference internal" href="#copy-data">Copy Data</a></li>
<li class="toctree-l3"><a class="reference internal" href="#object-info">Object Info</a></li>
<li class="toctree-l3"><a class="reference internal" href="#copy">Copy</a></li>
<li class="toctree-l3"><a class="reference internal" href="#clone">Clone</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#clonefrom">CloneFrom</a></li>
<li class="toctree-l4"><a class="reference internal" href="#clonebackend">CloneBackend</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#check">Check</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sort">Sort</a></li>
<li class="toctree-l3"><a class="reference internal" href="#keying">Keying</a></li>
<li class="toctree-l3"><a class="reference internal" href="#graph-analyzers">Graph Analyzers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cuthill-mckee-ordering">Cuthill-McKee Ordering</a></li>
<li class="toctree-l4"><a class="reference internal" href="#maximal-independent-set">Maximal Independent Set</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multi-coloring">Multi-Coloring</a></li>
<li class="toctree-l4"><a class="reference internal" href="#zero-block-permutation">Zero Block Permutation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#connectivity-ordering">Connectivity Ordering</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#basic-linear-algebra-operations">Basic Linear Algebra Operations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#multi-node-computation">Multi-node Computation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id13">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id14">Code Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parallel-manager">Parallel Manager</a></li>
<li class="toctree-l3"><a class="reference internal" href="#global-matrices-and-vectors">Global Matrices and Vectors</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#asynchronous-spmv">Asynchronous SpMV</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id15">File I/O</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#file-organization">File Organization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id16">Parallel Manager</a></li>
<li class="toctree-l4"><a class="reference internal" href="#matrices">Matrices</a></li>
<li class="toctree-l4"><a class="reference internal" href="#vectors">Vectors</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#solvers">Solvers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id17">Code Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#iterative-linear-solvers">Iterative Linear Solvers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#building-and-solving-phase">Building and Solving Phase</a></li>
<li class="toctree-l3"><a class="reference internal" href="#clear-function-and-destructor">Clear Function and Destructor</a></li>
<li class="toctree-l3"><a class="reference internal" href="#numerical-update">Numerical Update</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fixed-point-iteration">Fixed-Point Iteration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#krylov-subspace-solvers">Krylov Subspace Solvers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cg">CG</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cr">CR</a></li>
<li class="toctree-l4"><a class="reference internal" href="#gmres">GMRES</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fgmres">FGMRES</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bicgstab">BiCGStab</a></li>
<li class="toctree-l4"><a class="reference internal" href="#idr">IDR</a></li>
<li class="toctree-l4"><a class="reference internal" href="#fcg">FCG</a></li>
<li class="toctree-l4"><a class="reference internal" href="#qmrcgstab">QMRCGStab</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bicgstab-l">BiCGStab(l)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#chebyshev-iteration-scheme">Chebyshev Iteration Scheme</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mixed-precision-defect-correction-scheme">Mixed-Precision Defect Correction Scheme</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multigrid-solvers">MultiGrid Solvers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#geometric-multigrid">Geometric MultiGrid</a></li>
<li class="toctree-l4"><a class="reference internal" href="#algebraic-multigrid">Algebraic MultiGrid</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#direct-linear-solvers">Direct Linear Solvers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#preconditioners">Preconditioners</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id50">Code Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#jacobi-method">Jacobi Method</a></li>
<li class="toctree-l3"><a class="reference internal" href="#symmetric-gauss-seidel-s-sor-method">(Symmetric) Gauss-Seidel / (S)SOR Method</a></li>
<li class="toctree-l3"><a class="reference internal" href="#incomplete-factorizations">Incomplete Factorizations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#ilu">ILU</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ilut">ILUT</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ic">IC</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#ai-chebyshev">AI Chebyshev</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fsai">FSAI</a></li>
<li class="toctree-l3"><a class="reference internal" href="#spai">SPAI</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tns">TNS</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multicolored-preconditioners">MultiColored Preconditioners</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#multicolored-symmetric-gauss-seidel-s-sor">MultiColored (Symmetric) Gauss-Seidel / (S)SOR</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multicolored-power-q-pattern-method-ilu-p-q">MultiColored Power(q)-pattern method ILU(p,q)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#multi-elimination-incomplete-lu">Multi-Elimination Incomplete LU</a></li>
<li class="toctree-l3"><a class="reference internal" href="#diagonal-preconditioner-for-saddle-point-problems">Diagonal Preconditioner for Saddle-Point Problems</a></li>
<li class="toctree-l3"><a class="reference internal" href="#restricted-additive-schwarz-preconditioner">(Restricted) Additive Schwarz Preconditioner</a></li>
<li class="toctree-l3"><a class="reference internal" href="#block-jacobi-mpi-preconditioner">Block-Jacobi (MPI) Preconditioner</a></li>
<li class="toctree-l3"><a class="reference internal" href="#block-preconditioner">Block Preconditioner</a></li>
<li class="toctree-l3"><a class="reference internal" href="#variable-preconditioner">Variable Preconditioner</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#backends">Backends</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#moving-objects-to-and-from-the-accelerator">Moving Objects To and From the Accelerator</a></li>
<li class="toctree-l3"><a class="reference internal" href="#asynchronous-transfers">Asynchronous Transfers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#systems-without-accelerators">Systems without Accelerators</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#memory-allocations">Memory Allocations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#allocation-problems">Allocation Problems</a></li>
<li class="toctree-l3"><a class="reference internal" href="#memory-alignment">Memory Alignment</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pinned-memory-allocation-hip">Pinned Memory Allocation (HIP)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#remarks">Remarks</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#performance">Performance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#accelerators">Accelerators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#correctness">Correctness</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#change-log">Change Log</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#beta-for-rocm-1-9">1.3.2.0-beta for ROCm 1.9</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#bibliography">Bibliography</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">ReadTheDocs-Breathe</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>rocALUTION</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/library.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="toctree-wrapper compound">
</div>
<div class="section" id="rocalution">
<h1>rocALUTION<a class="headerlink" href="#rocalution" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<div class="section" id="overview">
<h3>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h3>
<p>rocALUTION is a sparse linear algebra library with focus on exploring fine-grained parallelism, targeting modern processors and accelerators including multi/many-core CPU and GPU platforms. The main goal of this package is to provide a portable library for iterative sparse methods on state of the art hardware. rocALUTION can be seen as middle-ware between different parallel backends and application specific packages.</p>
<p>The major features and characteristics of the library are</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>Various backends</dt>
<dd><ul class="first last">
<li>Host - fallback backend, designed for CPUs</li>
<li>GPU/HIP - accelerator backend, designed for HIP capable AMD GPUs</li>
<li>OpenMP - designed for multi-core CPUs</li>
<li>MPI - designed for multi-node and multi-GPU configurations</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Easy to use</dt>
<dd>The syntax and structure of the library provide easy learning curves. With the help of the examples, anyone can try out the library - no knowledge in HIP, OpenMP or MPI programming required.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>No special hardware requirements</dt>
<dd>There are no hardware requirements to install and run rocALUTION. If a GPU device and HIP is available, the library will use them.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Variety of iterative solvers</dt>
<dd><ul class="first last">
<li>Fixed-Point iteration - Jacobi, Gauss-Seidel, Symmetric-Gauss Seidel, SOR and SSOR</li>
<li>Krylov subspace methods - CR, CG, BiCGStab, BiCGStab(l), GMRES, IDR, QMRCGSTAB, Flexible CG/GMRES</li>
<li>Mixed-precision defect-correction scheme</li>
<li>Chebyshev iteration</li>
<li>Multiple MultiGrid schemes, geometric and algebraic</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Various preconditioners</dt>
<dd><ul class="first last">
<li>Matrix splitting - Jacobi, (Multi-colored) Gauss-Seidel, Symmetric Gauss-Seidel, SOR, SSOR</li>
<li>Factorization - ILU(0), ILU(p) (based on levels), ILU(p,q) (power(q)-pattern method), Multi-Elimination ILU (nested/recursive), ILUT (based on threshold) and IC(0)</li>
<li>Approximate Inverse - Chebyshev matrix-valued polynomial, SPAI, FSAI and TNS</li>
<li>Diagonal-based preconditioner for Saddle-point problems</li>
<li>Block-type of sub-preconditioners/solvers</li>
<li>Additive Schwarz and Restricted Additive Schwarz</li>
<li>Variable type preconditioners</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Generic and robust design</dt>
<dd>rocALUTION is based on a generic and robust design allowing expansion in the direction of new solvers and preconditioners and support for various hardware types. Furthermore, the design of the library allows the use of all solvers as preconditioners in other solvers. For example you can easily define a CG solver with a Multi-Elimination preconditioner, where the last-block is preconditioned with another Chebyshev iteration method which is preconditioned with a multi-colored Symmetric Gauss-Seidel scheme.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Portable code and results</dt>
<dd>All code based on rocALUTION is portable and independent of HIP or OpenMP. The code will compile and run everywhere. All solvers and preconditioners are based on a single source code, which delivers portable results across all supported backends (variations are possible due to different rounding modes on the hardware). The only difference which you can see for a hardware change is the performance variation.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Support for several sparse matrix formats</dt>
<dd>Compressed Sparse Row (CSR), Modified Compressed Sparse Row (MCSR), Dense (DENSE), Coordinate (COO), ELL, Diagonal (DIA), Hybrid format of ELL and COO (HYB).</dd>
</dl>
</li>
</ul>
<p>The code is open-source under MIT license and hosted on here: <a class="reference external" href="https://github.com/ROCmSoftwarePlatform/rocALUTION">https://github.com/ROCmSoftwarePlatform/rocALUTION</a></p>
</div>
<div class="section" id="contributing">
<span id="rocalution-contributing"></span><h3>Contributing<a class="headerlink" href="#contributing" title="Permalink to this headline">¶</a></h3>
<div class="section" id="contribution-license-agreement">
<h4>Contribution License Agreement<a class="headerlink" href="#contribution-license-agreement" title="Permalink to this headline">¶</a></h4>
<ol class="arabic simple">
<li>The code I am contributing is mine, and I have the right to license it.</li>
<li>By submitting a pull request for this project I am granting you a license to distribute said code under the MIT License for the project.</li>
</ol>
</div>
<div class="section" id="how-to-contribute">
<h4>How to contribute<a class="headerlink" href="#how-to-contribute" title="Permalink to this headline">¶</a></h4>
<p>Our code contriubtion guidelines closely follows the model of GitHub pull-requests. This repository follows the git flow workflow, which dictates a /master branch where releases are cut, and a /develop branch which serves as an integration branch for new code.</p>
<p>A <a class="reference external" href="https://github.com/nvie/gitflow">git extention</a> has been developed to ease the use of the ‘git flow’ methodology, but requires manual installation by the user. Please refer to the projects wiki.</p>
</div>
<div class="section" id="pull-request-guidelines">
<h4>Pull-request guidelines<a class="headerlink" href="#pull-request-guidelines" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Target the <strong>develop</strong> branch for integration.</li>
<li>Ensure code builds successfully.</li>
<li>Do not break existing test cases</li>
<li>New functionality will only be merged with new unit tests.<ul>
<li>New unit tests should integrate within the existing <a class="reference external" href="https://github.com/google/googletest/blob/master/googletest/docs/primer.md">googletest framework</a>.</li>
<li>Tests must have good code coverage.</li>
<li>Code must also have benchmark tests, and performance must approach the compute bound limit or memory bound limit.</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="styleguide">
<h4>StyleGuide<a class="headerlink" href="#styleguide" title="Permalink to this headline">¶</a></h4>
<p>This project follows the <a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md">CPP Core guidelines</a>, with few modifications or additions noted below. All pull-requests should in good faith attempt to follow the guidelines stated therein, but we recognize that the content is lengthy. Below we list our primary concerns when reviewing pull-requests.</p>
<p><strong>Interface</strong></p>
<ul class="simple">
<li>All public APIs are C89 compatible; all other library code should use C++14.</li>
<li>Our minimum supported compiler is clang 3.6.</li>
<li>Avoid CamelCase.</li>
<li>This rule applies specifically to publicly visible APIs, but is also encouraged (not mandated) for internal code.</li>
</ul>
<p><strong>Philosophy</strong></p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rp-Cplusplus">P.2</a>: Write in ISO Standard C++ (especially to support Windows, Linux and MacOS platforms).</li>
<li><a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rp-compile-time">P.5</a>: Prefer compile-time checking to run-time checking.</li>
</ul>
<p><strong>Implementation</strong></p>
<ul class="simple">
<li><a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rs-file-suffix">SF.1</a>: Use a .cpp suffix for code files and .h for interface files if your project doesn’t already follow another convention.</li>
<li>We modify this rule:<ul>
<li>.h: C header files.</li>
<li>.hpp: C++ header files.</li>
</ul>
</li>
<li><a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rs-consistency">SF.5</a>: A .cpp file must include the .h file(s) that defines its interface.</li>
<li><a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rs-using-directive">SF.7</a>: Don’t put a using-directive in a header file.</li>
<li><a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rs-guards">SF.8</a>: Use #include guards for all .h files.</li>
<li><a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rs-unnamed">SF.21</a>: Don’t use an unnamed (anonymous) namespace in a header.</li>
<li><a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rsl-arrays">SL.10</a>: Prefer using STL array or vector instead of a C array.</li>
<li><a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-private">C.9</a>: Minimize exposure of members.</li>
<li><a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rf-single">F.3</a>: Keep functions short and simple.</li>
<li><a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rf-out-multi">F.21</a>: To return multiple ‘out’ values, prefer returning a tuple.</li>
<li><a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rr-raii">R.1</a>: Manage resources automatically using RAII (this includes unique_ptr &amp; shared_ptr).</li>
<li><a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Res-auto">ES.11</a>:  Use auto to avoid redundant repetition of type names.</li>
<li><a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Res-always">ES.20</a>: Always initialize an object.</li>
<li><a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Res-list">ES.23</a>: Prefer the {} initializer syntax.</li>
<li><a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Res-casts-named">ES.49</a>: If you must use a cast, use a named cast.</li>
<li><a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#S-concurrency">CP.1</a>: Assume that your code will run as part of a multi-threaded program.</li>
<li><a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Ri-global">I.2</a>: Avoid global variables.</li>
</ul>
<p><strong>Format</strong></p>
<p>C and C++ code is formatted using clang-format. To format a file, use</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">clang</span><span class="o">-</span><span class="nb">format</span><span class="o">-</span><span class="mf">3.8</span> <span class="o">-</span><span class="n">style</span><span class="o">=</span><span class="n">file</span> <span class="o">-</span><span class="n">i</span> <span class="o">&lt;</span><span class="n">file</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>To format all files, run the following script in rocALUTION directory:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/bin/bash</span>

<span class="n">find</span> <span class="o">.</span> <span class="o">-</span><span class="n">iname</span> <span class="s1">&#39;*.h&#39;</span> \
<span class="o">-</span><span class="n">o</span> <span class="o">-</span><span class="n">iname</span> <span class="s1">&#39;*.hpp&#39;</span> \
<span class="o">-</span><span class="n">o</span> <span class="o">-</span><span class="n">iname</span> <span class="s1">&#39;*.cpp&#39;</span> \
<span class="o">-</span><span class="n">o</span> <span class="o">-</span><span class="n">iname</span> <span class="s1">&#39;*.h.in&#39;</span> \
<span class="o">-</span><span class="n">o</span> <span class="o">-</span><span class="n">iname</span> <span class="s1">&#39;*.hpp.in&#39;</span> \
<span class="o">-</span><span class="n">o</span> <span class="o">-</span><span class="n">iname</span> <span class="s1">&#39;*.cpp.in&#39;</span> \
<span class="o">-</span><span class="n">o</span> <span class="o">-</span><span class="n">iname</span> <span class="s1">&#39;*.cl&#39;</span> \
<span class="o">|</span> <span class="n">grep</span> <span class="o">-</span><span class="n">v</span> <span class="s1">&#39;build&#39;</span> \
<span class="o">|</span> <span class="n">xargs</span> <span class="o">-</span><span class="n">n</span> <span class="mi">1</span> <span class="o">-</span><span class="n">P</span> <span class="mi">8</span> <span class="o">-</span><span class="n">I</span><span class="p">{}</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span><span class="o">-</span><span class="mf">3.8</span> <span class="o">-</span><span class="n">style</span><span class="o">=</span><span class="n">file</span> <span class="o">-</span><span class="n">i</span> <span class="p">{}</span>
</pre></div>
</div>
<p>Also, githooks can be installed to format the code per-commit:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">./.</span><span class="n">githooks</span><span class="o">/</span><span class="n">install</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="building-and-installing">
<h2>Building and Installing<a class="headerlink" href="#building-and-installing" title="Permalink to this headline">¶</a></h2>
<div class="section" id="installing-from-amd-rocm-repositories">
<h3>Installing from AMD ROCm repositories<a class="headerlink" href="#installing-from-amd-rocm-repositories" title="Permalink to this headline">¶</a></h3>
<p>TODO, not yet available</p>
</div>
<div class="section" id="building-rocalution-from-open-source-repository">
<h3>Building rocALUTION from Open-Source repository<a class="headerlink" href="#building-rocalution-from-open-source-repository" title="Permalink to this headline">¶</a></h3>
<div class="section" id="download-rocalution">
<h4>Download rocALUTION<a class="headerlink" href="#download-rocalution" title="Permalink to this headline">¶</a></h4>
<p>The rocALUTION source code is available at the <a class="reference external" href="https://github.com/ROCmSoftwarePlatform/rocALUTION">rocALUTION github page</a>.
Download the master branch using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">clone</span> <span class="o">-</span><span class="n">b</span> <span class="n">master</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">ROCmSoftwarePlatform</span><span class="o">/</span><span class="n">rocALUTION</span><span class="o">.</span><span class="n">git</span>
<span class="n">cd</span> <span class="n">rocALUTION</span>
</pre></div>
</div>
<p>Note that if you want to contribute to rocALUTION, you will need to checkout the develop branch instead of the master branch. See <a class="reference internal" href="#rocalution-contributing"><span class="std std-ref">Contributing</span></a> for further details.
Below are steps to build different packages of the library, including dependencies and clients.
It is recommended to install rocALUTION using the <em>install.sh</em> script.</p>
</div>
<div class="section" id="using-install-sh-to-build-dependencies-library">
<h4>Using <em>install.sh</em> to build dependencies + library<a class="headerlink" href="#using-install-sh-to-build-dependencies-library" title="Permalink to this headline">¶</a></h4>
<p>The following table lists common uses of <em>install.sh</em> to build dependencies + library. Accelerator support via HIP and OpenMP will be enabled by default, whereas MPI is disabled.</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Command</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><cite>./install.sh -h</cite></td>
<td>Print help information.</td>
</tr>
<tr class="row-odd"><td><cite>./install.sh -d</cite></td>
<td>Build dependencies and library in your local directory. The <cite>-d</cite> flag only needs to be <br /> used once. For subsequent invocations of <em>install.sh</em> it is not necessary to rebuild the <br /> dependencies.</td>
</tr>
<tr class="row-even"><td><cite>./install.sh</cite></td>
<td>Build library in your local directory. It is assumed dependencies are available.</td>
</tr>
<tr class="row-odd"><td><cite>./install.sh -i</cite></td>
<td>Build library, then build and install rocALUTION package in <cite>/opt/rocm/rocalution</cite>. You will <br /> be prompted for sudo access. This will install for all users.</td>
</tr>
<tr class="row-even"><td><cite>./install.sh –host</cite></td>
<td>Build library in your local directory without HIP support. It is assumed dependencies <br /> are available.</td>
</tr>
<tr class="row-odd"><td><cite>./install.sh –mpi</cite></td>
<td>Build library in your local directory with HIP and MPI support. It is assumed <br /> dependencies are available.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="using-install-sh-to-build-dependencies-library-client">
<h4>Using <em>install.sh</em> to build dependencies + library + client<a class="headerlink" href="#using-install-sh-to-build-dependencies-library-client" title="Permalink to this headline">¶</a></h4>
<p>The client contains example code, unit tests and benchmarks. Common uses of <em>install.sh</em> to build them are listed in the table below.</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="92%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Command</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><cite>./install.sh -h</cite></td>
<td>Print help information.</td>
</tr>
<tr class="row-odd"><td><cite>./install.sh -dc</cite></td>
<td>Build dependencies, library and client in your local directory. The <cite>-d</cite> flag only needs to <br /> be used once. For subsequent invocations of <em>install.sh</em> it is not necessary to rebuild the <br /> dependencies.</td>
</tr>
<tr class="row-even"><td><cite>./install.sh -c</cite></td>
<td>Build library and client in your local directory. It is assumed dependencies are available.</td>
</tr>
<tr class="row-odd"><td><cite>./install.sh -idc</cite></td>
<td>Build library, dependencies and client, then build and install rocALUTION package in <br /> <cite>/opt/rocm/rocalution</cite>. You will be prompted for sudo access. This will install for all users.</td>
</tr>
<tr class="row-even"><td><cite>./install.sh -ic</cite></td>
<td>Build library and client, then build and install rocALUTION package in <br /> <cite>opt/rocm/rocalution</cite>. You will be prompted for sudo access. This will install for all users.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="using-individual-commands-to-build-rocalution">
<h4>Using individual commands to build rocALUTION<a class="headerlink" href="#using-individual-commands-to-build-rocalution" title="Permalink to this headline">¶</a></h4>
<p>CMake 3.5 or later is required in order to build rocALUTION.</p>
<p>rocALUTION can be built with cmake using the following commands:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># Create and change to build directory
mkdir -p build/release ; cd build/release

# Default install path is /opt/rocm, use -DCMAKE_INSTALL_PREFIX=&lt;path&gt; to adjust it
cmake ../.. -DSUPPORT_HIP=ON \
            -DSUPPORT_MPI=OFF \
            -DSUPPORT_OMP=ON

# Compile rocALUTION library
make -j$(nproc)

# Install rocALUTION to /opt/rocm
sudo make install
</pre></div>
</div>
<p>GoogleTest is required in order to build rocALUTION client.</p>
<p>rocALUTION with dependencies and client can be built using the following commands:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span># Install googletest
mkdir -p build/release/deps ; cd build/release/deps
cmake ../../../deps
sudo make -j$(nproc) install

# Change to build directory
cd ..

# Default install path is /opt/rocm, use -DCMAKE_INSTALL_PREFIX=&lt;path&gt; to adjust it
cmake ../.. -DBUILD_CLIENTS_TESTS=ON \
            -DBUILD_CLIENTS_SAMPLES=ON

# Compile rocALUTION library
make -j$(nproc)

# Install rocALUTION to /opt/rocm
sudo make install
</pre></div>
</div>
<p>The compilation process produces a shared library file <em>librocalution.so</em> and <em>librocalution_hip.so</em> if HIP support is enabled. Ensure that the library objects can be found in your library path. If you do not copy the library to a specific location you can add the path under Linux in the <em>LD_LIBRARY_PATH</em> variable.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:&lt;path_to_rocalution&gt;
</pre></div>
</div>
</div>
<div class="section" id="common-build-problems">
<h4>Common build problems<a class="headerlink" href="#common-build-problems" title="Permalink to this headline">¶</a></h4>
<ol class="arabic">
<li><p class="first"><strong>Issue:</strong> HIP (/opt/rocm/hip) was built using hcc 1.0.xxx-xxx-xxx-xxx, but you are using /opt/rocm/bin/hcc with version 1.0.yyy-yyy-yyy-yyy from hipcc (version mismatch). Please rebuild HIP including cmake or update HCC_HOME variable.</p>
<p><strong>Solution:</strong> Download HIP from github and use hcc to <a class="reference external" href="https://github.com/ROCm-Developer-Tools/HIP/blob/master/INSTALL.md">build from source</a> and then use the built HIP instead of /opt/rocm/hip.</p>
</li>
<li><p class="first"><strong>Issue:</strong> For Carrizo - HCC RUNTIME ERROR: Failed to find compatible kernel</p>
<p><strong>Solution:</strong> Add the following to the cmake command when configuring: <cite>-DCMAKE_CXX_FLAGS=”–amdgpu-target=gfx801”</cite></p>
</li>
<li><p class="first"><strong>Issue:</strong> For MI25 (Vega10 Server) - HCC RUNTIME ERROR: Failed to find compatible kernel</p>
<p><strong>Solution:</strong> <cite>export HCC_AMDGPU_TARGET=gfx900</cite></p>
</li>
<li><dl class="first docutils">
<dt><strong>Issue:</strong> Could not find a package configuration file provided by “ROCM” with any of the following names:</dt>
<dd><p class="first last">ROCMConfig.cmake <br />
rocm-config.cmake</p>
</dd>
</dl>
<p><strong>Solution:</strong> Install <a class="reference external" href="https://github.com/RadeonOpenCompute/rocm-cmake">ROCm cmake modules</a></p>
</li>
<li><dl class="first docutils">
<dt><strong>Issue:</strong> Could not find a package configuration file provided by “ROCSPARSE” with any of the following names:</dt>
<dd><p class="first last">ROCSPARSE.cmake <br />
rocsparse-config.cmake</p>
</dd>
</dl>
<p><strong>Solution:</strong> Install <a class="reference external" href="https://github.com/ROCmSoftwarePlatform/rocSPARSE">rocSPARSE</a></p>
</li>
<li><dl class="first docutils">
<dt><strong>Issue:</strong> Could not find a package configuration file provided by “ROCBLAS” with any of the following names:</dt>
<dd><p class="first last">ROCBLAS.cmake <br />
rocblas-config.cmake</p>
</dd>
</dl>
<p><strong>Solution:</strong> Install <a class="reference external" href="https://github.com/ROCmSoftwarePlatform/rocBLAS">rocBLAS</a></p>
</li>
</ol>
</div>
</div>
<div class="section" id="simple-test">
<h3>Simple Test<a class="headerlink" href="#simple-test" title="Permalink to this headline">¶</a></h3>
<p>You can test the installation by running a CG solver on a Laplace matrix. After compiling the library you can perform the CG solver test by executing</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span> <span class="n">rocALUTION</span><span class="o">/</span><span class="n">build</span><span class="o">/</span><span class="n">release</span><span class="o">/</span><span class="n">examples</span>

<span class="n">wget</span> <span class="n">ftp</span><span class="p">:</span><span class="o">//</span><span class="n">math</span><span class="o">.</span><span class="n">nist</span><span class="o">.</span><span class="n">gov</span><span class="o">/</span><span class="n">pub</span><span class="o">/</span><span class="n">MatrixMarket2</span><span class="o">/</span><span class="n">Harwell</span><span class="o">-</span><span class="n">Boeing</span><span class="o">/</span><span class="n">laplace</span><span class="o">/</span><span class="n">gr_30_30</span><span class="o">.</span><span class="n">mtx</span><span class="o">.</span><span class="n">gz</span>
<span class="n">gzip</span> <span class="o">-</span><span class="n">d</span> <span class="n">gr_30_30</span><span class="o">.</span><span class="n">mtx</span><span class="o">.</span><span class="n">gz</span>

<span class="o">./</span><span class="n">cg</span> <span class="n">gr_30_30</span><span class="o">.</span><span class="n">mtx</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="basics">
<h2>Basics<a class="headerlink" href="#basics" title="Permalink to this headline">¶</a></h2>
<div class="section" id="design-and-philosophy">
<h3>Design and Philosophy<a class="headerlink" href="#design-and-philosophy" title="Permalink to this headline">¶</a></h3>
<p>The main idea of the rocALUTION objects is that they are separated from the actual hardware specification. Once you declare a matrix, a vector or a solver they are initially allocated on the host (CPU). Then, every object can be moved to a selected accelerator by a simple <a class="reference internal" href="api.html#_CPPv3N10rocalution14BaseRocalution17MoveToAcceleratorEv" title="rocalution::BaseRocalution::MoveToAccelerator"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::BaseRocalution::MoveToAccelerator()</span></code></a> function. The whole execution mechanism is based on run-time type information (RTTI), which allows you to select where and how you want to perform the operations at run time. This is in contrast to the template-based libraries, which need this information at compile time.</p>
<p>The philosophy of the library is to abstract the hardware-specific functions and routines from the actual program, that describes the algorithm. It is hard and almost impossible for most of the large simulation software based on sparse computation, to adapt and port their implementation in order to use every new technology. On the other hand, the new high performance accelerators and devices have the capability to decrease the computational time significantly in many critical parts.</p>
<p>This abstraction layer of the hardware specific routines is the core of the rocALUTION design. It is built to explore fine-grained level of parallelism suited for multi/many-core devices. This is in contrast to most of the parallel sparse libraries available which are mainly based on domain decomposition techniques. Thus, the design of the iterative solvers the preconditioners is very different. Another cornerstone of rocALUTION is the native support of accelerators - the memory allocation, transfers and specific hardware functions are handled internally in the library.</p>
<p>rocALUTION helps you to use accelerator technologies but does not force you to use them. Even if you offload your algorithms and solvers to the accelerator device, the same source code can be compiled and executed in a system without any accelerators.</p>
</div>
<div class="section" id="operators-and-vectors">
<h3>Operators and Vectors<a class="headerlink" href="#operators-and-vectors" title="Permalink to this headline">¶</a></h3>
<p>The main objects in rocALUTION are linear operators and vectors. All objects can be moved to an accelerator at run time. The linear operators are defined as local or global matrices (i.e. on a single node or distributed/multi-node) and local stencils (i.e. matrix-free linear operations). The only template parameter of the operators and vectors is the data type (ValueType). The operator data type could be float, double, complex float or complex double, while the vector data type can be int, float, double, complex float or complex double (int is used mainly for the permutation vectors). In the current version, cross ValueType object operations are not supported. <code class="xref std std-numref docutils literal notranslate"><span class="pre">operators</span></code> gives an overview of supported operators and vectors.</p>
<img alt="operator and vector classes" class="align-center" id="operators" src="_images/operators.png" />
<p><strong>operator and vector classes</strong></p>
<p>Each of the objects contain a local copy of the hardware descriptor created by the <a class="reference internal" href="api.html#_CPPv3N10rocalution15init_rocalutionEii" title="rocalution::init_rocalution"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::init_rocalution()</span></code></a> function. This allows the user to modify it according to his needs and to obtain two or more objects with different hardware specifications (e.g. different amount of OpenMP threads, HIP block sizes, etc.).</p>
<div class="section" id="local-operators-and-vectors">
<h4>Local Operators and Vectors<a class="headerlink" href="#local-operators-and-vectors" title="Permalink to this headline">¶</a></h4>
<p>By Local Operators and Vectors we refer to Local Matrices and Stencils and to Local Vectors. By Local we mean the fact that they stay on a single system. The system can contain several CPUs via UMA or NUMA memory system, it can also contain an accelerator.</p>
<dl class="class">
<dt id="_CPPv3N10rocalution11LocalMatrixE">
<span id="_CPPv2N10rocalution11LocalMatrixE"></span><span id="rocalution::LocalMatrix"></span><span class="target" id="classrocalution_1_1_local_matrix"></span><em class="property">template </em>&lt;typename <em>ValueType</em>&gt;<br /><em class="property">class </em><code class="descname">LocalMatrix</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution8OperatorE" title="rocalution::Operator">Operator</a>&lt;ValueType&gt;<br /></dt>
<dd><p><a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> class. </p>
<p>A <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> is called local, because it will always stay on a single system. The system can contain several CPUs via UMA or NUMA memory system or it can contain an accelerator.</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be int, float, double, std::complex&lt;float&gt; and std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N10rocalution12LocalStencilE">
<span id="_CPPv2N10rocalution12LocalStencilE"></span><span id="rocalution::LocalStencil"></span><span class="target" id="classrocalution_1_1_local_stencil"></span><em class="property">template </em>&lt;<em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">LocalStencil</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution8OperatorE" title="rocalution::Operator">Operator</a>&lt;ValueType&gt;<br /></dt>
<dd><p><a class="reference internal" href="#classrocalution_1_1_local_stencil"><span class="std std-ref">LocalStencil</span></a> class. </p>
<p>A <a class="reference internal" href="#classrocalution_1_1_local_stencil"><span class="std std-ref">LocalStencil</span></a> is called local, because it will always stay on a single system. The system can contain several CPUs via UMA or NUMA memory system or it can contain an accelerator.</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be int, float, double, std::complex&lt;float&gt; and std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N10rocalution11LocalVectorE">
<span id="_CPPv2N10rocalution11LocalVectorE"></span><span id="rocalution::LocalVector"></span><span class="target" id="classrocalution_1_1_local_vector"></span><em class="property">template </em>&lt;typename <em>ValueType</em>&gt;<br /><em class="property">class </em><code class="descname">LocalVector</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution6VectorE" title="rocalution::Vector">Vector</a>&lt;ValueType&gt;<br /></dt>
<dd><p><a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> class. </p>
<p>A <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> is called local, because it will always stay on a single system. The system can contain several CPUs via UMA or NUMA memory system or it can contain an accelerator.</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be int, float, double, std::complex&lt;float&gt; and std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="global-operators-and-vectors">
<h4>Global Operators and Vectors<a class="headerlink" href="#global-operators-and-vectors" title="Permalink to this headline">¶</a></h4>
<p>By Global Operators and Vectors we refer to Global Matrix and to Global Vectors. By Global we mean the fact they can stay on a single or multiple nodes in a network. For this type of computation, the communication is based on MPI.</p>
<dl class="class">
<dt id="_CPPv3N10rocalution12GlobalMatrixE">
<span id="_CPPv2N10rocalution12GlobalMatrixE"></span><span id="rocalution::GlobalMatrix"></span><span class="target" id="classrocalution_1_1_global_matrix"></span><em class="property">template </em>&lt;<em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">GlobalMatrix</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution8OperatorE" title="rocalution::Operator">Operator</a>&lt;ValueType&gt;<br /></dt>
<dd><p><a class="reference internal" href="#classrocalution_1_1_global_matrix"><span class="std std-ref">GlobalMatrix</span></a> class. </p>
<p>A <a class="reference internal" href="#classrocalution_1_1_global_matrix"><span class="std std-ref">GlobalMatrix</span></a> is called global, because it can stay on a single or on multiple nodes in a network. For this type of communication, MPI is used.</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be int, float, double, std::complex&lt;float&gt; and std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N10rocalution12GlobalVectorE">
<span id="_CPPv2N10rocalution12GlobalVectorE"></span><span id="rocalution::GlobalVector"></span><span class="target" id="classrocalution_1_1_global_vector"></span><em class="property">template </em>&lt;typename <em>ValueType</em>&gt;<br /><em class="property">class </em><code class="descname">GlobalVector</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution6VectorE" title="rocalution::Vector">Vector</a>&lt;ValueType&gt;<br /></dt>
<dd><p><a class="reference internal" href="#classrocalution_1_1_global_vector"><span class="std std-ref">GlobalVector</span></a> class. </p>
<p>A <a class="reference internal" href="#classrocalution_1_1_global_vector"><span class="std std-ref">GlobalVector</span></a> is called global, because it can stay on a single or on multiple nodes in a network. For this type of communication, MPI is used.</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be int, float, double, std::complex&lt;float&gt; and std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</div>
<div class="section" id="functionality-on-the-accelerator">
<h3>Functionality on the Accelerator<a class="headerlink" href="#functionality-on-the-accelerator" title="Permalink to this headline">¶</a></h3>
<p>Naturally, not all routines and algorithms can be performed efficiently on many-core systems (i.e. on accelerators). To provide full functionality, the library has internal mechanisms to check if a particular routine is implemented on the accelerator. If not, the object is moved to the host and the routine is computed there. This guarantees that your code will run (maybe not in the most efficient way) with any accelerator regardless of the available functionality for it.</p>
</div>
<div class="section" id="initialization-of-rocalution">
<h3>Initialization of rocALUTION<a class="headerlink" href="#initialization-of-rocalution" title="Permalink to this headline">¶</a></h3>
<p>The body of a rocALUTION code is very simple, it should contain the header file and the namespace of the library. The program must contain an initialization call, which will check and allocate the hardware and a finalizing call which will release the allocated hardware.</p>
<dl class="function">
<dt id="_CPPv3N10rocalution15init_rocalutionEii">
<span id="_CPPv2N10rocalution15init_rocalutionEii"></span><span id="rocalution::init_rocalution__i.i"></span><span class="target" id="group__backend__module_1ga044437ad21ae0e48c88f09bdb508cdae"></span>int <code class="descclassname">rocalution<code class="descclassname">::</code></code><code class="descname">init_rocalution</code><span class="sig-paren">(</span>int <em>rank</em> = -1, int <em>dev_per_node</em> = 1<span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize rocALUTION platform. </p>
<p><code class="docutils literal notranslate"><span class="pre">init_rocalution</span></code> defines a backend descriptor with information about the hardware and its specifications. All objects created after that contain a copy of this descriptor. If the specifications of the global descriptor are changed (e.g. set different number of threads) and new objects are created, only the new objects will use the new configurations.</p>
<p>For control, the library provides the following functions<ul class="simple">
<li><a class="reference internal" href="#group__backend__module_1ga90fb4a381beab8525d17988f2600a336"><span class="std std-ref">set_device_rocalution()</span></a> is a unified function to select a specific device. If you have compiled the library with a backend and for this backend there are several available devices, you can use this function to select a particular one. This function has to be called before <a class="reference internal" href="#group__backend__module_1ga044437ad21ae0e48c88f09bdb508cdae"><span class="std std-ref">init_rocalution()</span></a>.</li>
<li><a class="reference internal" href="#group__backend__module_1ga83e2a7e27ef32854ba4a34ff83b3285f"><span class="std std-ref">set_omp_threads_rocalution()</span></a> sets the number of OpenMP threads. This function has to be called after <a class="reference internal" href="#group__backend__module_1ga044437ad21ae0e48c88f09bdb508cdae"><span class="std std-ref">init_rocalution()</span></a>.</li>
</ul>
</p>
<p><dl class="docutils">
<dt><strong>Example</strong></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &lt;rocalution.hpp&gt;</span>

<span class="n">using</span> <span class="n">namespace</span> <span class="n">rocalution</span><span class="p">;</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">(</span><span class="nb">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">init_rocalution</span><span class="p">();</span>

    <span class="o">//</span> <span class="o">...</span>

    <span class="n">stop_rocalution</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">rank</span></code>: specifies MPI rank when multi-node environment </li>
<li><code class="docutils literal notranslate"><span class="pre">dev_per_node</span></code>: number of accelerator devices per node, when in multi-GPU environment</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution15stop_rocalutionEv">
<span id="_CPPv2N10rocalution15stop_rocalutionEv"></span><span id="rocalution::stop_rocalution__void"></span><span class="target" id="group__backend__module_1gaf6098d8efba475358435f3b00da8c51b"></span>int <code class="descclassname">rocalution<code class="descclassname">::</code></code><code class="descname">stop_rocalution</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Shutdown rocALUTION platform. </p>
<p><code class="docutils literal notranslate"><span class="pre">stop_rocalution</span></code> shuts down the rocALUTION platform. </p>
</dd></dl>

<div class="section" id="thread-core-mapping">
<h4>Thread-core Mapping<a class="headerlink" href="#thread-core-mapping" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="_CPPv3N10rocalution26set_omp_threads_rocalutionEi">
<span id="_CPPv2N10rocalution26set_omp_threads_rocalutionEi"></span><span id="rocalution::set_omp_threads_rocalution__i"></span><span class="target" id="group__backend__module_1ga83e2a7e27ef32854ba4a34ff83b3285f"></span>void <code class="descclassname">rocalution<code class="descclassname">::</code></code><code class="descname">set_omp_threads_rocalution</code><span class="sig-paren">(</span>int <em>nthreads</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set number of OpenMP threads. </p>
<p>The number of threads which rocALUTION will use can be set with <code class="docutils literal notranslate"><span class="pre">set_omp_threads_rocalution</span></code> or by the global OpenMP environment variable (for Unix-like OS this is <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS</span></code>). During the initialization phase, the library provides affinity thread-core mapping:<ul class="simple">
<li>If the number of cores (including SMT cores) is greater or equal than two times the number of threads, then all the threads can occupy every second core ID (e.g. 0, 2, 4, <span class="math notranslate nohighlight">\(\ldots\)</span>). This is to avoid having two threads working on the same physical core, when SMT is enabled.</li>
<li>If the number of threads is less or equal to the number of cores (including SMT), and the previous clause is false, then the threads can occupy every core ID (e.g. 0, 1, 2, 3, <span class="math notranslate nohighlight">\(\ldots\)</span>).</li>
<li>If non of the above criteria is matched, then the default thread-core mapping is used (typically set by the OS).</li>
</ul>
</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The thread-core mapping is available only for Unix-like OS.</dd>
<dt><strong>Note</strong></dt>
<dd>The user can disable the thread affinity by calling <a class="reference internal" href="#group__backend__module_1ga207aa4a91a2507c0e9f7b1ac8e8c8b28"><span class="std std-ref">set_omp_affinity_rocalution()</span></a>, before initializing the library (i.e. before <a class="reference internal" href="#group__backend__module_1ga044437ad21ae0e48c88f09bdb508cdae"><span class="std std-ref">init_rocalution()</span></a>).</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">nthreads</span></code>: number of OpenMP threads </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution27set_omp_affinity_rocalutionEb">
<span id="_CPPv2N10rocalution27set_omp_affinity_rocalutionEb"></span><span id="rocalution::set_omp_affinity_rocalution__b"></span><span class="target" id="group__backend__module_1ga207aa4a91a2507c0e9f7b1ac8e8c8b28"></span>void <code class="descclassname">rocalution<code class="descclassname">::</code></code><code class="descname">set_omp_affinity_rocalution</code><span class="sig-paren">(</span>bool <em>affinity</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Enable/disable OpenMP host affinity. </p>
<p><code class="docutils literal notranslate"><span class="pre">set_omp_affinity_rocalution</span></code> enables / disables OpenMP host affinity.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">affinity</span></code>: boolean to turn on/off OpenMP host affinity </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="openmp-threshold-size">
<h4>OpenMP Threshold Size<a class="headerlink" href="#openmp-threshold-size" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="_CPPv3N10rocalution28set_omp_threshold_rocalutionEi">
<span id="_CPPv2N10rocalution28set_omp_threshold_rocalutionEi"></span><span id="rocalution::set_omp_threshold_rocalution__i"></span><span class="target" id="group__backend__module_1ga63587ed85501959c6f34a9838b8f2ba8"></span>void <code class="descclassname">rocalution<code class="descclassname">::</code></code><code class="descname">set_omp_threshold_rocalution</code><span class="sig-paren">(</span>int <em>threshold</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set OpenMP threshold size. </p>
<p>Whenever you want to work on a small problem, you might observe that the OpenMP host backend is (slightly) slower than using no OpenMP. This is mainly attributed to the small amount of work, which every thread should perform and the large overhead of forking/joining threads. This can be avoid by the OpenMP threshold size parameter in rocALUTION. The default threshold is set to 10000, which means that all matrices under (and equal) this size will use only one thread (disregarding the number of OpenMP threads set in the system). The threshold can be modified with <code class="docutils literal notranslate"><span class="pre">set_omp_threshold_rocalution</span></code>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">threshold</span></code>: OpenMP threshold size </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="accelerator-selection">
<h4>Accelerator Selection<a class="headerlink" href="#accelerator-selection" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="_CPPv3N10rocalution21set_device_rocalutionEi">
<span id="_CPPv2N10rocalution21set_device_rocalutionEi"></span><span id="rocalution::set_device_rocalution__i"></span><span class="target" id="group__backend__module_1ga90fb4a381beab8525d17988f2600a336"></span>void <code class="descclassname">rocalution<code class="descclassname">::</code></code><code class="descname">set_device_rocalution</code><span class="sig-paren">(</span>int <em>dev</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the accelerator device. </p>
<p><code class="docutils literal notranslate"><span class="pre">set_device_rocalution</span></code> lets the user select the accelerator device that is supposed to be used for the computation.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">dev</span></code>: accelerator device ID for computation </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="disable-the-accelerator">
<h4>Disable the Accelerator<a class="headerlink" href="#disable-the-accelerator" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="_CPPv3N10rocalution30disable_accelerator_rocalutionEb">
<span id="_CPPv2N10rocalution30disable_accelerator_rocalutionEb"></span><span id="rocalution::disable_accelerator_rocalution__b"></span><span class="target" id="group__backend__module_1gac17c61b30b39327cca408417ef68bb2a"></span>void <code class="descclassname">rocalution<code class="descclassname">::</code></code><code class="descname">disable_accelerator_rocalution</code><span class="sig-paren">(</span>bool <em>onoff</em> = true<span class="sig-paren">)</span><br /></dt>
<dd><p>Disable/Enable the accelerator. </p>
<p>If you want to disable the accelerator (without re-compiling the code), you need to call <code class="docutils literal notranslate"><span class="pre">disable_accelerator_rocalution</span></code> before <a class="reference internal" href="#group__backend__module_1ga044437ad21ae0e48c88f09bdb508cdae"><span class="std std-ref">init_rocalution()</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">onoff</span></code>: boolean to turn on/off the accelerator </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="backend-information">
<h4>Backend Information<a class="headerlink" href="#backend-information" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="_CPPv3N10rocalution15info_rocalutionEv">
<span id="_CPPv2N10rocalution15info_rocalutionEv"></span><span id="rocalution::info_rocalution__void"></span><span class="target" id="group__backend__module_1gace30a89d8b0688fdfb425be39fa10633"></span>void <code class="descclassname">rocalution<code class="descclassname">::</code></code><code class="descname">info_rocalution</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Print info about rocALUTION. </p>
<p><code class="docutils literal notranslate"><span class="pre">info_rocalution</span></code> prints information about the rocALUTION platform </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution15info_rocalutionEK29Rocalution_Backend_Descriptor">
<span id="_CPPv2N10rocalution15info_rocalutionEK29Rocalution_Backend_Descriptor"></span><span id="rocalution::info_rocalution__Rocalution_Backend_DescriptorC"></span><span class="target" id="group__backend__module_1gad4d74134029d46a072420b2ca787f859"></span>void <code class="descclassname">rocalution<code class="descclassname">::</code></code><code class="descname">info_rocalution</code><span class="sig-paren">(</span><em class="property">const</em> <em class="property">struct</em> Rocalution_Backend_Descriptor <em>backend_descriptor</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Print info about specific rocALUTION backend descriptor. </p>
<p><code class="docutils literal notranslate"><span class="pre">info_rocalution</span></code> prints information about the rocALUTION platform of the specific backend descriptor.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">backend_descriptor</span></code>: rocALUTION backend descriptor </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="mpi-and-multi-accelerators">
<h4>MPI and Multi-Accelerators<a class="headerlink" href="#mpi-and-multi-accelerators" title="Permalink to this headline">¶</a></h4>
<p>When initializing the library with MPI, the user need to pass the rank of the MPI process as well as the number of accelerators available on each node. Basically, this way the user can specify the mapping of MPI
process and accelerators - the allocated accelerator will be <cite>rank % num_dev_per_node</cite>. Thus, the user can run two MPI processes on systems with two accelerators by specifying the number of devices to 2.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;rocalution.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;mpi.h&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">rocalution</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">MPI_Init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">);</span>
    <span class="n">MPI_Comm</span> <span class="n">comm</span> <span class="o">=</span> <span class="n">MPI_COMM_WORLD</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">num_processes</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">rank</span><span class="p">;</span>

    <span class="n">MPI_Comm_size</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_processes</span><span class="p">);</span>
    <span class="n">MPI_Comm_rank</span><span class="p">(</span><span class="n">comm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rank</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">nacc_per_node</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

    <span class="n">init_rocalution</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="n">nacc_per_node</span><span class="p">);</span>

    <span class="c1">// ...</span>

    <span class="n">stop_rocalution</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="automatic-object-tracking">
<h3>Automatic Object Tracking<a class="headerlink" href="#automatic-object-tracking" title="Permalink to this headline">¶</a></h3>
<p>By default, after the initialization of the library, rocALUTION tracks all objects and releasing the allocated memory in them when the library is stopped. This ensure large memory leaks when the objects are allocated but not freed. The user can disable the tracking by editing <cite>src/utils/def.hpp</cite>, however, this is not recommended.</p>
</div>
<div class="section" id="verbose-output">
<h3>Verbose Output<a class="headerlink" href="#verbose-output" title="Permalink to this headline">¶</a></h3>
<p>rocALUTION provides different levels of output messages. They can be modified in <cite>src/utils/def.hpp</cite> before the compilation of the library. By setting a higher level, the user will obtain more detailed information about the internal calls and data transfers to and from the accelerators.</p>
</div>
<div class="section" id="verbose-output-and-mpi">
<h3>Verbose Output and MPI<a class="headerlink" href="#verbose-output-and-mpi" title="Permalink to this headline">¶</a></h3>
<p>To prevent all MPI processes from printing information to screen, the default configuration is that only RANK 0 outputs information. The user can change the RANK or allow all RANKs to print by modifying <cite>src/utils/def.hpp</cite>. If file logging is enabled, all ranks write into the corresponding log files.</p>
</div>
<div class="section" id="debug-output">
<h3>Debug Output<a class="headerlink" href="#debug-output" title="Permalink to this headline">¶</a></h3>
<p>Debug output will print almost every detail in the program, including object constructor / destructor, address of the object, memory allocation, data transfers, all function calls for matrices, vectors, solvers and preconditioners. The debug flag can be set in <cite>src/utils/def.hpp</cite>. When enabled, additional <em>assert()s</em> are being checked during the computation. This might decrease the performance of some operations significantly.</p>
</div>
<div class="section" id="logging">
<h3>Logging<a class="headerlink" href="#logging" title="Permalink to this headline">¶</a></h3>
<p>TODO</p>
</div>
<div class="section" id="versions">
<span id="rocalution-version"></span><h3>Versions<a class="headerlink" href="#versions" title="Permalink to this headline">¶</a></h3>
<p>For checking the rocALUTION version in your code, you can use the pre-defined macros.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#define __ROCALUTION_VER_MAJOR  </span><span class="c1">// version major</span>
<span class="cp">#define __ROCALUTION_VER_MINOR  </span><span class="c1">// version minor</span>
<span class="cp">#define __ROCALUTION_VER_PATCH  </span><span class="c1">// version patch</span>

<span class="cp">#define __ROCALUTION_VER_PRE    </span><span class="c1">// version pre-release (alpha or beta)</span>

<span class="cp">#define __ROCALUTION_VER        </span><span class="c1">// version</span>
</pre></div>
</div>
<p>The final <em>__ROCALUTION_VER</em> gives the version number as <cite>10000 * major + 100 * minor + patch</cite>, see <cite>src/base/version.hpp.in</cite>.</p>
</div>
</div>
<div class="section" id="single-node-computation">
<h2>Single-node Computation<a class="headerlink" href="#single-node-computation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>Introduction<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>In this chapter, all base objects (matrices, vectors and stencils) for computation on a single-node (shared-memory) system are described. A typical configuration is illustrated in <code class="xref std std-numref docutils literal notranslate"><span class="pre">single-node</span></code>.</p>
<img alt="single-node system configuration" class="align-center" id="single-node" src="_images/single-node.png" />
<p><strong>A typical single-node configuration, where gray boxes represent the cores, blue boxes represent the memory and arrows represent the bandwidth</strong></p>
<p>The compute node contains none, one or more accelerators. The compute node could be any kind of shared-memory (single, dual, quad CPU) system.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The host and accelerator memory can be physically different.</p>
</div>
</div>
<div class="section" id="code-structure">
<h3>Code Structure<a class="headerlink" href="#code-structure" title="Permalink to this headline">¶</a></h3>
<p>The <cite>Data</cite> is an object, pointing to the BaseMatrix class. The pointing is coming from either a HostMatrix or an AcceleratorMatrix. The AcceleratorMatrix is created by an object with an implementation in the backend and a matrix format. Switching between host and accelerator matrices is performed in the LocalMatrix class. The LocalVector is organized in the same way.</p>
<p>Each matrix format has its own class for the host and for the accelerator backend. All matrix classes are derived from the BaseMatrix, which provides the base interface for computation as well as for data accessing.</p>
</div>
<div class="section" id="valuetype">
<h3>ValueType<a class="headerlink" href="#valuetype" title="Permalink to this headline">¶</a></h3>
<p>The value (data) type of the vectors and the matrices is defined as a template. The matrix can be of type float (32-bit), double (64-bit) and complex (64/128-bit). The vector can be float (32-bit), double (64-bit), complex (64/128-bit) and int (32/64-bit). The information about the precision of the data type is shown in the <a class="reference internal" href="api.html#_CPPv3NK10rocalution14BaseRocalution4InfoEv" title="rocalution::BaseRocalution::Info"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::BaseRocalution::Info()</span></code></a> function.</p>
</div>
<div class="section" id="complex-support">
<h3>Complex Support<a class="headerlink" href="#complex-support" title="Permalink to this headline">¶</a></h3>
<p>Currently, rocALUTION does not support complex computation.</p>
</div>
<div class="section" id="allocation-and-free">
<h3>Allocation and Free<a class="headerlink" href="#allocation-and-free" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv3N10rocalution11LocalVector8AllocateENSt6stringE10IndexType2">
<span id="_CPPv2N10rocalution11LocalVector8AllocateENSt6stringE10IndexType2"></span><span id="rocalution::LocalVector::Allocate__ss.IndexType2"></span><span class="target" id="classrocalution_1_1_local_vector_1ae9ad82b77b1fa3f94112092d69354a15"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVectorE" title="rocalution::LocalVector">LocalVector</a><code class="descclassname">::</code></code><code class="descname">Allocate</code><span class="sig-paren">(</span>std::string <em>name</em>, IndexType2 <em>size</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Allocate a local vector with name and size. </p>
<p>The local vector allocation function requires a name of the object (this is only for information purposes) and corresponding size description for vector objects.</p>
<p><dl class="docutils">
<dt><strong>Example</strong></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LocalVector</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>

<span class="n">vec</span><span class="o">.</span><span class="n">Allocate</span><span class="p">(</span><span class="s2">&quot;my vector&quot;</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
<span class="n">vec</span><span class="o">.</span><span class="n">Clear</span><span class="p">();</span>
</pre></div>
</div>
 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: object name </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: number of elements in the vector</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11LocalVector5ClearEv">
<span id="_CPPv2N10rocalution11LocalVector5ClearEv"></span><span id="rocalution::LocalVector::Clear"></span><span class="target" id="classrocalution_1_1_local_vector_1ae58d9c9b346f80079f4028108b8dfdb2"></span><em class="property">virtual</em> void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVectorE" title="rocalution::LocalVector">LocalVector</a><code class="descclassname">::</code></code><code class="descname">Clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N10rocalution11LocalVector5ClearEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clear (free all data) the object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11LocalMatrix11AllocateCOOEKNSt6stringEiii">
<span id="_CPPv2N10rocalution11LocalMatrix11AllocateCOOEKNSt6stringEiii"></span><span id="rocalution::LocalMatrix::AllocateCOO__ssC.i.i.i"></span><span class="target" id="classrocalution_1_1_local_matrix_1a5f8a0ce95e3c24b68dbc272bf0b979ed"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">AllocateCOO</code><span class="sig-paren">(</span><em class="property">const</em> std::string <em>name</em>, int <em>nnz</em>, int <em>nrow</em>, int <em>ncol</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11LocalMatrix11AllocateCSREKNSt6stringEiii">
<span id="_CPPv2N10rocalution11LocalMatrix11AllocateCSREKNSt6stringEiii"></span><span id="rocalution::LocalMatrix::AllocateCSR__ssC.i.i.i"></span><span class="target" id="classrocalution_1_1_local_matrix_1a9e2262ffb6ec53e72ebe079803616c67"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">AllocateCSR</code><span class="sig-paren">(</span><em class="property">const</em> std::string <em>name</em>, int <em>nnz</em>, int <em>nrow</em>, int <em>ncol</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11LocalMatrix12AllocateBCSREv">
<span id="_CPPv2N10rocalution11LocalMatrix12AllocateBCSREv"></span><span id="rocalution::LocalMatrix::AllocateBCSR__void"></span><span class="target" id="classrocalution_1_1_local_matrix_1a83eeb71afdf68f0aa91eadc46143034b"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">AllocateBCSR</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11LocalMatrix12AllocateMCSREKNSt6stringEiii">
<span id="_CPPv2N10rocalution11LocalMatrix12AllocateMCSREKNSt6stringEiii"></span><span id="rocalution::LocalMatrix::AllocateMCSR__ssC.i.i.i"></span><span class="target" id="classrocalution_1_1_local_matrix_1af3e1c51e650ffad760b7dbfc508bd80e"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">AllocateMCSR</code><span class="sig-paren">(</span><em class="property">const</em> std::string <em>name</em>, int <em>nnz</em>, int <em>nrow</em>, int <em>ncol</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11LocalMatrix11AllocateELLEKNSt6stringEiiii">
<span id="_CPPv2N10rocalution11LocalMatrix11AllocateELLEKNSt6stringEiiii"></span><span id="rocalution::LocalMatrix::AllocateELL__ssC.i.i.i.i"></span><span class="target" id="classrocalution_1_1_local_matrix_1acb5702157228a7cf509d518ed85023a3"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">AllocateELL</code><span class="sig-paren">(</span><em class="property">const</em> std::string <em>name</em>, int <em>nnz</em>, int <em>nrow</em>, int <em>ncol</em>, int <em>max_row</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11LocalMatrix11AllocateDIAEKNSt6stringEiiii">
<span id="_CPPv2N10rocalution11LocalMatrix11AllocateDIAEKNSt6stringEiiii"></span><span id="rocalution::LocalMatrix::AllocateDIA__ssC.i.i.i.i"></span><span class="target" id="classrocalution_1_1_local_matrix_1ac22ce8c62c7f96aaf81f0ca252550d37"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">AllocateDIA</code><span class="sig-paren">(</span><em class="property">const</em> std::string <em>name</em>, int <em>nnz</em>, int <em>nrow</em>, int <em>ncol</em>, int <em>ndiag</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11LocalMatrix11AllocateHYBEKNSt6stringEiiiii">
<span id="_CPPv2N10rocalution11LocalMatrix11AllocateHYBEKNSt6stringEiiiii"></span><span id="rocalution::LocalMatrix::AllocateHYB__ssC.i.i.i.i.i"></span><span class="target" id="classrocalution_1_1_local_matrix_1a0f11424c97e09672c909d457d06cbccb"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">AllocateHYB</code><span class="sig-paren">(</span><em class="property">const</em> std::string <em>name</em>, int <em>ell_nnz</em>, int <em>coo_nnz</em>, int <em>ell_max_row</em>, int <em>nrow</em>, int <em>ncol</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11LocalMatrix13AllocateDENSEEKNSt6stringEii">
<span id="_CPPv2N10rocalution11LocalMatrix13AllocateDENSEEKNSt6stringEii"></span><span id="rocalution::LocalMatrix::AllocateDENSE__ssC.i.i"></span><span class="target" id="classrocalution_1_1_local_matrix_1a0c79cf8ba3bcb18cfa5790bfcf874ce0"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">AllocateDENSE</code><span class="sig-paren">(</span><em class="property">const</em> std::string <em>name</em>, int <em>nrow</em>, int <em>ncol</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">More detailed information on the additional parameters required for matrix allocation is given in <a class="reference internal" href="#matrix-formats"><span class="std std-ref">Matrix Formats</span></a>.</p>
</div>
<dl class="function">
<dt id="_CPPv3N10rocalution11LocalMatrix5ClearEv">
<span id="_CPPv2N10rocalution11LocalMatrix5ClearEv"></span><span id="rocalution::LocalMatrix::Clear__void"></span><span class="target" id="classrocalution_1_1_local_matrix_1a8df7184b26588a0d06d6c65a53fd7a73"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">Clear</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N10rocalution11LocalMatrix5ClearEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clear (free all data) the object. </p>
</dd></dl>

</div>
<div class="section" id="matrix-formats">
<span id="id2"></span><h3>Matrix Formats<a class="headerlink" href="#matrix-formats" title="Permalink to this headline">¶</a></h3>
<p>Matrices, where most of the elements are equal to zero, are called sparse. In most practical applications, the number of non-zero entries is proportional to the size of the matrix (e.g. typically, if the matrix <span class="math notranslate nohighlight">\(A \in \mathbb{R}^{N \times N}\)</span>, then the number of elements are of order <span class="math notranslate nohighlight">\(O(N)\)</span>). To save memory, storing zero entries can be avoided by introducing a structure corresponding to the non-zero elements of the matrix. rocALUTION supports sparse CSR, MCSR, COO, ELL, DIA, HYB and dense matrices (DENSE).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The functionality of every matrix object is different and depends on the matrix format. The CSR format provides the highest support for various functions. For a few operations, an internal conversion is performed, however, for many routines an error message is printed and the program is terminated.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In the current version, some of the conversions are performed on the host (disregarding the actual object allocation - host or accelerator).</p>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Convert mat to CSR storage format</span>
<span class="n">mat</span><span class="p">.</span><span class="n">ConvertToCSR</span><span class="p">();</span>
<span class="c1">// Perform a matrix-vector multiplication y = mat * x in CSR format</span>
<span class="n">mat</span><span class="p">.</span><span class="n">Apply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">);</span>

<span class="c1">// Convert mat to ELL storage format</span>
<span class="n">mat</span><span class="p">.</span><span class="n">ConvertToELL</span><span class="p">();</span>
<span class="c1">// Perform a matrix-vector multiplication y = mat * x in ELL format</span>
<span class="n">mat</span><span class="p">.</span><span class="n">Apply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Convert mat to CSR storage format</span>
<span class="n">mat</span><span class="p">.</span><span class="n">ConvertTo</span><span class="p">(</span><span class="n">CSR</span><span class="p">);</span>
<span class="c1">// Perform a matrix-vector multiplication y = mat * x in CSR format</span>
<span class="n">mat</span><span class="p">.</span><span class="n">Apply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">);</span>

<span class="c1">// Convert mat to ELL storage format</span>
<span class="n">mat</span><span class="p">.</span><span class="n">ConvertTo</span><span class="p">(</span><span class="n">ELL</span><span class="p">);</span>
<span class="c1">// Perform a matrix-vector multiplication y = mat * x in ELL format</span>
<span class="n">mat</span><span class="p">.</span><span class="n">Apply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">);</span>
</pre></div>
</div>
<div class="section" id="coo-storage-format">
<h4>COO storage format<a class="headerlink" href="#coo-storage-format" title="Permalink to this headline">¶</a></h4>
<p>The most intuitive sparse format is the coordinate format (COO). It represents the non-zero elements of the matrix by their coordinates and requires two index arrays (one for row and one for column indexing) and the values array. A <span class="math notranslate nohighlight">\(m \times n\)</span> matrix is represented by</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>m</td>
<td>number of rows (integer).</td>
</tr>
<tr class="row-even"><td>n</td>
<td>number of columns (integer).</td>
</tr>
<tr class="row-odd"><td>nnz</td>
<td>number of non-zero elements (integer).</td>
</tr>
<tr class="row-even"><td>coo_val</td>
<td>array of <code class="docutils literal notranslate"><span class="pre">nnz</span></code> elements containing the data (floating point).</td>
</tr>
<tr class="row-odd"><td>coo_row_ind</td>
<td>array of <code class="docutils literal notranslate"><span class="pre">nnz</span></code> elements containing the row indices (integer).</td>
</tr>
<tr class="row-even"><td>coo_col_ind</td>
<td>array of <code class="docutils literal notranslate"><span class="pre">nnz</span></code> elements containing the column indices (integer).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The COO matrix is expected to be sorted by row indices and column indices per row. Furthermore, each pair of indices should appear only once.</p>
</div>
<p>Consider the following <span class="math notranslate nohighlight">\(3 \times 5\)</span> matrix and the corresponding COO structures, with <span class="math notranslate nohighlight">\(m = 3, n = 5\)</span> and <span class="math notranslate nohighlight">\(\text{nnz} = 8\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}A = \begin{pmatrix}
      1.0 &amp; 2.0 &amp; 0.0 &amp; 3.0 &amp; 0.0 \\
      0.0 &amp; 4.0 &amp; 5.0 &amp; 0.0 &amp; 0.0 \\
      6.0 &amp; 0.0 &amp; 0.0 &amp; 7.0 &amp; 8.0 \\
    \end{pmatrix}\end{split}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{ll}
  \text{coo_val}[8] &amp; = \{1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0\} \\
  \text{coo_row_ind}[8] &amp; = \{0, 0, 0, 1, 1, 2, 2, 2\} \\
  \text{coo_col_ind}[8] &amp; = \{0, 1, 3, 1, 2, 0, 3, 4\}
\end{array}\end{split}\]</div>
</div>
<div class="section" id="csr-storage-format">
<h4>CSR storage format<a class="headerlink" href="#csr-storage-format" title="Permalink to this headline">¶</a></h4>
<p>One of the most popular formats in many scientific codes is the compressed sparse row (CSR) format. In this format, instead of row indices, the row offsets to the beginning of each row are stored. Thus, each row elements can be accessed sequentially. However, this format does not allow sequential accessing of the column entries.
The CSR storage format represents a <span class="math notranslate nohighlight">\(m \times n\)</span> matrix by</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="87%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>m</td>
<td>number of rows (integer).</td>
</tr>
<tr class="row-even"><td>n</td>
<td>number of columns (integer).</td>
</tr>
<tr class="row-odd"><td>nnz</td>
<td>number of non-zero elements (integer).</td>
</tr>
<tr class="row-even"><td>csr_val</td>
<td>array of <code class="docutils literal notranslate"><span class="pre">nnz</span></code> elements containing the data (floating point).</td>
</tr>
<tr class="row-odd"><td>csr_row_ptr</td>
<td>array of <code class="docutils literal notranslate"><span class="pre">m+1</span></code> elements that point to the start of every row (integer).</td>
</tr>
<tr class="row-even"><td>csr_col_ind</td>
<td>array of <code class="docutils literal notranslate"><span class="pre">nnz</span></code> elements containing the column indices (integer).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The CSR matrix is expected to be sorted by column indices within each row. Furthermore, each pair of indices should appear only once.</p>
</div>
<p>Consider the following <span class="math notranslate nohighlight">\(3 \times 5\)</span> matrix and the corresponding CSR structures, with <span class="math notranslate nohighlight">\(m = 3, n = 5\)</span> and <span class="math notranslate nohighlight">\(\text{nnz} = 8\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}A = \begin{pmatrix}
      1.0 &amp; 2.0 &amp; 0.0 &amp; 3.0 &amp; 0.0 \\
      0.0 &amp; 4.0 &amp; 5.0 &amp; 0.0 &amp; 0.0 \\
      6.0 &amp; 0.0 &amp; 0.0 &amp; 7.0 &amp; 8.0 \\
    \end{pmatrix}\end{split}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{ll}
  \text{csr_val}[8] &amp; = \{1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0\} \\
  \text{csr_row_ptr}[4] &amp; = \{0, 3, 5, 8\} \\
  \text{csr_col_ind}[8] &amp; = \{0, 1, 3, 1, 2, 0, 3, 4\}
\end{array}\end{split}\]</div>
</div>
<div class="section" id="ell-storage-format">
<h4>ELL storage format<a class="headerlink" href="#ell-storage-format" title="Permalink to this headline">¶</a></h4>
<p>The Ellpack-Itpack (ELL) storage format can be seen as a modification of the CSR format without row offset pointers. Instead, a fixed number of elements per row is stored.
It represents a <span class="math notranslate nohighlight">\(m \times n\)</span> matrix by</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="88%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>m</td>
<td>number of rows (integer).</td>
</tr>
<tr class="row-even"><td>n</td>
<td>number of columns (integer).</td>
</tr>
<tr class="row-odd"><td>ell_width</td>
<td>maximum number of non-zero elements per row (integer)</td>
</tr>
<tr class="row-even"><td>ell_val</td>
<td>array of <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">times</span> <span class="pre">ell_width</span></code> elements containing the data (floating point).</td>
</tr>
<tr class="row-odd"><td>ell_col_ind</td>
<td>array of <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">times</span> <span class="pre">ell_width</span></code> elements containing the column indices (integer).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The ELL matrix is assumed to be stored in column-major format. Rows with less than <code class="docutils literal notranslate"><span class="pre">ell_width</span></code> non-zero elements are padded with zeros (<code class="docutils literal notranslate"><span class="pre">ell_val</span></code>) and <span class="math notranslate nohighlight">\(-1\)</span> (<code class="docutils literal notranslate"><span class="pre">ell_col_ind</span></code>).</p>
</div>
<p>Consider the following <span class="math notranslate nohighlight">\(3 \times 5\)</span> matrix and the corresponding ELL structures, with <span class="math notranslate nohighlight">\(m = 3, n = 5\)</span> and <span class="math notranslate nohighlight">\(\text{ell_width} = 3\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}A = \begin{pmatrix}
      1.0 &amp; 2.0 &amp; 0.0 &amp; 3.0 &amp; 0.0 \\
      0.0 &amp; 4.0 &amp; 5.0 &amp; 0.0 &amp; 0.0 \\
      6.0 &amp; 0.0 &amp; 0.0 &amp; 7.0 &amp; 8.0 \\
    \end{pmatrix}\end{split}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{ll}
  \text{ell_val}[9] &amp; = \{1.0, 4.0, 6.0, 2.0, 5.0, 7.0, 3.0, 0.0, 8.0\} \\
  \text{ell_col_ind}[9] &amp; = \{0, 1, 0, 1, 2, 3, 3, -1, 4\}
\end{array}\end{split}\]</div>
</div>
<div class="section" id="dia-storage-format">
<span id="id3"></span><h4>DIA storage format<a class="headerlink" href="#dia-storage-format" title="Permalink to this headline">¶</a></h4>
<p>If all (or most) of the non-zero entries belong to a few diagonals of the matrix, they can be stored with the corresponding offsets. The values in DIA format are stored as array with size <span class="math notranslate nohighlight">\(D \times N_D\)</span>, where <span class="math notranslate nohighlight">\(D\)</span> is the number of diagonals in the matrix and <span class="math notranslate nohighlight">\(N_D\)</span> is the number of elements in the main diagonal. Since not all values in this array are occupied, the not accessible entries are denoted with <span class="math notranslate nohighlight">\(\ast\)</span>. They correspond to the offsets in the diagonal array (negative values represent offsets from the beginning of the array).
The DIA storage format represents a <span class="math notranslate nohighlight">\(m \times n\)</span> matrix by</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>m</td>
<td>number of rows (integer)</td>
</tr>
<tr class="row-even"><td>n</td>
<td>number of columns (integer)</td>
</tr>
<tr class="row-odd"><td>ndiag</td>
<td>number of occupied diagonals (integer)</td>
</tr>
<tr class="row-even"><td>dia_offset</td>
<td>array of <code class="docutils literal notranslate"><span class="pre">ndiag</span></code> elements containing the offset with respect to the main diagonal (integer).</td>
</tr>
<tr class="row-odd"><td>dia_val</td>
<td>array of <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">times</span> <span class="pre">ndiag</span></code> elements containing the values (floating point).</td>
</tr>
</tbody>
</table>
<p>Consider the following <span class="math notranslate nohighlight">\(5 \times 5\)</span> matrix and the corresponding DIA structures, with <span class="math notranslate nohighlight">\(m = 5, n = 5\)</span> and <span class="math notranslate nohighlight">\(\text{ndiag} = 4\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}A = \begin{pmatrix}
      1 &amp; 2 &amp; 0 &amp; 11 &amp; 0 \\
      0 &amp; 3 &amp; 4 &amp; 0 &amp; 0 \\
      0 &amp; 5 &amp; 6 &amp; 7 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 8 &amp; 0 \\
      0 &amp; 0 &amp; 0 &amp; 9 &amp; 10
    \end{pmatrix}\end{split}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{ll}
  \text{dia_val}[20] &amp; = \{\ast, 0, 5, 0, 9, 1, 3, 6, 8, 10, 2, 4, 7, 0, \ast, 11, 0, \ast, \ast, \ast\} \\
  \text{dia_offset}[4] &amp; = \{-1, 0, 1, 3\}
\end{array}\end{split}\]</div>
</div>
<div class="section" id="hyb-storage-format">
<span id="id4"></span><h4>HYB storage format<a class="headerlink" href="#hyb-storage-format" title="Permalink to this headline">¶</a></h4>
<p>The DIA and ELL formats cannot represent efficiently completely unstructured sparse matrices. To keep the memory footprint low, DIA requires the elements to belong to a few diagonals and ELL needs a fixed number of elements per row. For many applications this is a too strong restriction. A solution to this issue is to represent the more regular part of the matrix in such a format and the remaining part in COO format. The HYB format is a mixture between ELL and COO, where the maximum elements per row for the ELL part is computed by <cite>nnz/m</cite>. It represents a <span class="math notranslate nohighlight">\(m \times n\)</span> matrix by</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="89%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>m</td>
<td>number of rows (integer).</td>
</tr>
<tr class="row-even"><td>n</td>
<td>number of columns (integer).</td>
</tr>
<tr class="row-odd"><td>nnz</td>
<td>number of non-zero elements of the COO part (integer)</td>
</tr>
<tr class="row-even"><td>ell_width</td>
<td>maximum number of non-zero elements per row of the ELL part (integer)</td>
</tr>
<tr class="row-odd"><td>ell_val</td>
<td>array of <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">times</span> <span class="pre">ell_width</span></code> elements containing the ELL part data (floating point).</td>
</tr>
<tr class="row-even"><td>ell_col_ind</td>
<td>array of <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">times</span> <span class="pre">ell_width</span></code> elements containing the ELL part column indices (integer).</td>
</tr>
<tr class="row-odd"><td>coo_val</td>
<td>array of <code class="docutils literal notranslate"><span class="pre">nnz</span></code> elements containing the COO part data (floating point).</td>
</tr>
<tr class="row-even"><td>coo_row_ind</td>
<td>array of <code class="docutils literal notranslate"><span class="pre">nnz</span></code> elements containing the COO part row indices (integer).</td>
</tr>
<tr class="row-odd"><td>coo_col_ind</td>
<td>array of <code class="docutils literal notranslate"><span class="pre">nnz</span></code> elements containing the COO part column indices (integer).</td>
</tr>
</tbody>
</table>
<p>For further details on matrix formats, see <a href="#id5"><span class="problematic" id="id6">:cite:`SAAD`</span></a>.</p>
</div>
<div class="section" id="memory-usage">
<h4>Memory Usage<a class="headerlink" href="#memory-usage" title="Permalink to this headline">¶</a></h4>
<p>The memory footprint of the different matrix formats is presented in the following table, considering a <span class="math notranslate nohighlight">\(N \times N\)</span> matrix, where the number of non-zero entries is denoted with <cite>nnz</cite>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="51%" />
<col width="38%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Structure</th>
<th class="head">Values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>DENSE</td>
<td>&#160;</td>
<td><span class="math notranslate nohighlight">\(N \times N\)</span></td>
</tr>
<tr class="row-odd"><td>COO</td>
<td><span class="math notranslate nohighlight">\(2 \times \text{nnz}\)</span></td>
<td><span class="math notranslate nohighlight">\(\text{nnz}\)</span></td>
</tr>
<tr class="row-even"><td>CSR</td>
<td><span class="math notranslate nohighlight">\(N + 1 + \text{nnz}\)</span></td>
<td><span class="math notranslate nohighlight">\(\text{nnz}\)</span></td>
</tr>
<tr class="row-odd"><td>ELL</td>
<td><span class="math notranslate nohighlight">\(M \times N\)</span></td>
<td><span class="math notranslate nohighlight">\(M \times N\)</span></td>
</tr>
<tr class="row-even"><td>DIA</td>
<td><span class="math notranslate nohighlight">\(D\)</span></td>
<td><span class="math notranslate nohighlight">\(D \times N_D\)</span></td>
</tr>
</tbody>
</table>
<p>For the ELL matrix <span class="math notranslate nohighlight">\(M\)</span> characterizes the maximal number of non-zero elements per row and for the DIA matrix, <span class="math notranslate nohighlight">\(D\)</span> defines the number of diagonals and <span class="math notranslate nohighlight">\(N_D\)</span> defines the size of the main diagonal.</p>
</div>
</div>
<div class="section" id="file-i-o">
<h3>File I/O<a class="headerlink" href="#file-i-o" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv3N10rocalution11LocalVector13ReadFileASCIIEKNSt6stringE">
<span id="_CPPv2N10rocalution11LocalVector13ReadFileASCIIEKNSt6stringE"></span><span id="rocalution::LocalVector::ReadFileASCII__ssC"></span><span class="target" id="classrocalution_1_1_local_vector_1a4f93a990c2b1a89bed6b8f69f965a729"></span><em class="property">virtual</em> void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVectorE" title="rocalution::LocalVector">LocalVector</a><code class="descclassname">::</code></code><code class="descname">ReadFileASCII</code><span class="sig-paren">(</span><em class="property">const</em> std::string <em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N10rocalution11LocalVector13ReadFileASCIIEKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Read vector from ASCII file. </p>
<p>Read a vector from ASCII file.</p>
<p><dl class="docutils">
<dt><strong>Example</strong></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LocalVector</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="n">vec</span><span class="o">.</span><span class="n">ReadFileASCII</span><span class="p">(</span><span class="s2">&quot;my_vector.dat&quot;</span><span class="p">);</span>
</pre></div>
</div>
 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">filename</span></code>: name of the file containing the ASCII data.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK10rocalution11LocalVector14WriteFileASCIIEKNSt6stringE">
<span id="_CPPv2NK10rocalution11LocalVector14WriteFileASCIIEKNSt6stringE"></span><span id="rocalution::LocalVector::WriteFileASCII__ssCC"></span><span class="target" id="classrocalution_1_1_local_vector_1ae25cac3e31ae90cfb0ed6cd26a0b820c"></span><em class="property">virtual</em> void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVectorE" title="rocalution::LocalVector">LocalVector</a><code class="descclassname">::</code></code><code class="descname">WriteFileASCII</code><span class="sig-paren">(</span><em class="property">const</em> std::string <em>filename</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK10rocalution11LocalVector14WriteFileASCIIEKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write vector to ASCII file. </p>
<p>Write a vector to ASCII file.</p>
<p><dl class="docutils">
<dt><strong>Example</strong></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LocalVector</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Allocate</span> <span class="ow">and</span> <span class="n">fill</span> <span class="n">vec</span>
<span class="o">//</span> <span class="o">...</span>

<span class="n">vec</span><span class="o">.</span><span class="n">WriteFileASCII</span><span class="p">(</span><span class="s2">&quot;my_vector.dat&quot;</span><span class="p">);</span>
</pre></div>
</div>
 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">filename</span></code>: name of the file to write the ASCII data to.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11LocalVector14ReadFileBinaryEKNSt6stringE">
<span id="_CPPv2N10rocalution11LocalVector14ReadFileBinaryEKNSt6stringE"></span><span id="rocalution::LocalVector::ReadFileBinary__ssC"></span><span class="target" id="classrocalution_1_1_local_vector_1a3ab863a463e4bfd2b1fc172ed9103c29"></span><em class="property">virtual</em> void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVectorE" title="rocalution::LocalVector">LocalVector</a><code class="descclassname">::</code></code><code class="descname">ReadFileBinary</code><span class="sig-paren">(</span><em class="property">const</em> std::string <em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N10rocalution11LocalVector14ReadFileBinaryEKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Read vector from binary file. </p>
<p>Read a vector from binary file. For details on the format, see <a class="reference internal" href="#classrocalution_1_1_local_vector_1a9c753058a01044c092079eade04d9fb1"><span class="std std-ref">WriteFileBinary()</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Example</strong></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LocalVector</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="n">vec</span><span class="o">.</span><span class="n">ReadFileBinary</span><span class="p">(</span><span class="s2">&quot;my_vector.bin&quot;</span><span class="p">);</span>
</pre></div>
</div>
 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">filename</span></code>: name of the file containing the data.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK10rocalution11LocalVector15WriteFileBinaryEKNSt6stringE">
<span id="_CPPv2NK10rocalution11LocalVector15WriteFileBinaryEKNSt6stringE"></span><span id="rocalution::LocalVector::WriteFileBinary__ssCC"></span><span class="target" id="classrocalution_1_1_local_vector_1a9c753058a01044c092079eade04d9fb1"></span><em class="property">virtual</em> void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVectorE" title="rocalution::LocalVector">LocalVector</a><code class="descclassname">::</code></code><code class="descname">WriteFileBinary</code><span class="sig-paren">(</span><em class="property">const</em> std::string <em>filename</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK10rocalution11LocalVector15WriteFileBinaryEKNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Write vector to binary file. </p>
<p>Write a vector to binary file.</p>
<p>The binary format contains a header, the rocALUTION version and the vector data as follows <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Header</span>
<span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;#rocALUTION binary vector file&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>

<span class="o">//</span> <span class="n">rocALUTION</span> <span class="n">version</span>
<span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">((</span><span class="n">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">version</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="nb">int</span><span class="p">));</span>

<span class="o">//</span> <span class="n">Vector</span> <span class="n">data</span>
<span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">((</span><span class="n">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="nb">int</span><span class="p">));</span>
<span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">((</span><span class="n">char</span><span class="o">*</span><span class="p">)</span><span class="n">vec_val</span><span class="p">,</span> <span class="n">size</span> <span class="o">*</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">double</span><span class="p">));</span>
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd><a class="reference internal" href="api.html#classrocalution_1_1_vector"><span class="std std-ref">Vector</span></a> values array is always stored in double precision (e.g. double or std::complex&lt;double&gt;).</dd>
<dt><strong>Example</strong></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LocalVector</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Allocate</span> <span class="ow">and</span> <span class="n">fill</span> <span class="n">vec</span>
<span class="o">//</span> <span class="o">...</span>

<span class="n">vec</span><span class="o">.</span><span class="n">WriteFileBinary</span><span class="p">(</span><span class="s2">&quot;my_vector.bin&quot;</span><span class="p">);</span>
</pre></div>
</div>
 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">filename</span></code>: name of the file to write the data to.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11LocalMatrix11ReadFileMTXEKNSt6stringE">
<span id="_CPPv2N10rocalution11LocalMatrix11ReadFileMTXEKNSt6stringE"></span><span id="rocalution::LocalMatrix::ReadFileMTX__ssC"></span><span class="target" id="classrocalution_1_1_local_matrix_1a22b9f4275cef954b889bf89a3b5889c9"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">ReadFileMTX</code><span class="sig-paren">(</span><em class="property">const</em> std::string <em>filename</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Read matrix from MTX (Matrix Market Format) file. </p>
<p>Read a matrix from Matrix Market Format file.</p>
<p><dl class="docutils">
<dt><strong>Example</strong></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LocalMatrix</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span> <span class="n">mat</span><span class="p">;</span>
<span class="n">mat</span><span class="o">.</span><span class="n">ReadFileMTX</span><span class="p">(</span><span class="s2">&quot;my_matrix.mtx&quot;</span><span class="p">);</span>
</pre></div>
</div>
 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">filename</span></code>: name of the file containing the MTX data.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK10rocalution11LocalMatrix12WriteFileMTXEKNSt6stringE">
<span id="_CPPv2NK10rocalution11LocalMatrix12WriteFileMTXEKNSt6stringE"></span><span id="rocalution::LocalMatrix::WriteFileMTX__ssCC"></span><span class="target" id="classrocalution_1_1_local_matrix_1ab10a7e473601a9a1d368b48781816185"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">WriteFileMTX</code><span class="sig-paren">(</span><em class="property">const</em> std::string <em>filename</em><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>Write matrix to MTX (Matrix Market Format) file. </p>
<p>Write a matrix to Matrix Market Format file.</p>
<p><dl class="docutils">
<dt><strong>Example</strong></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LocalMatrix</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span> <span class="n">mat</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Allocate</span> <span class="ow">and</span> <span class="n">fill</span> <span class="n">mat</span>
<span class="o">//</span> <span class="o">...</span>

<span class="n">mat</span><span class="o">.</span><span class="n">WriteFileMTX</span><span class="p">(</span><span class="s2">&quot;my_matrix.mtx&quot;</span><span class="p">);</span>
</pre></div>
</div>
 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">filename</span></code>: name of the file to write the MTX data to.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11LocalMatrix11ReadFileCSREKNSt6stringE">
<span id="_CPPv2N10rocalution11LocalMatrix11ReadFileCSREKNSt6stringE"></span><span id="rocalution::LocalMatrix::ReadFileCSR__ssC"></span><span class="target" id="classrocalution_1_1_local_matrix_1a0c211ccae3c7b1f1c8f631786c552aa9"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">ReadFileCSR</code><span class="sig-paren">(</span><em class="property">const</em> std::string <em>filename</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Read matrix from CSR (rocALUTION binary format) file. </p>
<p>Read a CSR matrix from binary file. For details on the format, see <a class="reference internal" href="#classrocalution_1_1_local_matrix_1af955765ef46e0a31967b87755c6053f5"><span class="std std-ref">WriteFileCSR()</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Example</strong></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LocalMatrix</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span> <span class="n">mat</span><span class="p">;</span>
<span class="n">mat</span><span class="o">.</span><span class="n">ReadFileCSR</span><span class="p">(</span><span class="s2">&quot;my_matrix.csr&quot;</span><span class="p">);</span>
</pre></div>
</div>
 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">filename</span></code>: name of the file containing the data.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK10rocalution11LocalMatrix12WriteFileCSREKNSt6stringE">
<span id="_CPPv2NK10rocalution11LocalMatrix12WriteFileCSREKNSt6stringE"></span><span id="rocalution::LocalMatrix::WriteFileCSR__ssCC"></span><span class="target" id="classrocalution_1_1_local_matrix_1af955765ef46e0a31967b87755c6053f5"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">WriteFileCSR</code><span class="sig-paren">(</span><em class="property">const</em> std::string <em>filename</em><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>Write CSR matrix to binary file. </p>
<p>Write a CSR matrix to binary file.</p>
<p>The binary format contains a header, the rocALUTION version and the matrix data as follows <div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Header</span>
<span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;#rocALUTION binary csr file&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>

<span class="o">//</span> <span class="n">rocALUTION</span> <span class="n">version</span>
<span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">((</span><span class="n">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">version</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="nb">int</span><span class="p">));</span>

<span class="o">//</span> <span class="n">CSR</span> <span class="n">matrix</span> <span class="n">data</span>
<span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">((</span><span class="n">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="nb">int</span><span class="p">));</span>
<span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">((</span><span class="n">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="nb">int</span><span class="p">));</span>
<span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">((</span><span class="n">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">nnz</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="nb">int</span><span class="p">));</span>
<span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">((</span><span class="n">char</span><span class="o">*</span><span class="p">)</span><span class="n">csr_row_ptr</span><span class="p">,</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">sizeof</span><span class="p">(</span><span class="nb">int</span><span class="p">));</span>
<span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">((</span><span class="n">char</span><span class="o">*</span><span class="p">)</span><span class="n">csr_col_ind</span><span class="p">,</span> <span class="n">nnz</span> <span class="o">*</span> <span class="n">sizeof</span><span class="p">(</span><span class="nb">int</span><span class="p">));</span>
<span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">((</span><span class="n">char</span><span class="o">*</span><span class="p">)</span><span class="n">csr_val</span><span class="p">,</span> <span class="n">nnz</span> <span class="o">*</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">double</span><span class="p">));</span>
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd><a class="reference internal" href="api.html#classrocalution_1_1_vector"><span class="std std-ref">Vector</span></a> values array is always stored in double precision (e.g. double or std::complex&lt;double&gt;).</dd>
<dt><strong>Example</strong></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LocalMatrix</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span> <span class="n">mat</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Allocate</span> <span class="ow">and</span> <span class="n">fill</span> <span class="n">mat</span>
<span class="o">//</span> <span class="o">...</span>

<span class="n">mat</span><span class="o">.</span><span class="n">WriteFileCSR</span><span class="p">(</span><span class="s2">&quot;my_matrix.csr&quot;</span><span class="p">);</span>
</pre></div>
</div>
 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">filename</span></code>: name of the file to write the data to.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">To obtain the rocALUTION version, see <a class="reference internal" href="#rocalution-version"><span class="std std-ref">Versions</span></a>.</p>
</div>
<p>For further details on the Matrix Market Format, see <a href="#id7"><span class="problematic" id="id8">:cite:`mm`</span></a>.</p>
</div>
<div class="section" id="access">
<h3>Access<a class="headerlink" href="#access" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv3N10rocalution11LocalVectorixEi">
<span id="_CPPv2N10rocalution11LocalVectorixEi"></span><span id="rocalution::LocalVector::subscript-operator__i"></span><span class="target" id="classrocalution_1_1_local_vector_1a20913b1560bec91831c49351530d34e8"></span>ValueType &amp;<code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVectorE" title="rocalution::LocalVector">LocalVector</a><code class="descclassname">::</code></code><code class="descname">operator[]</code><span class="sig-paren">(</span>int <em>i</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3NK10rocalution11LocalVectorixEi">
<span id="_CPPv2NK10rocalution11LocalVectorixEi"></span><span id="rocalution::LocalVector::subscript-operator__iC"></span><span class="target" id="classrocalution_1_1_local_vector_1ae584b51e9e91a17b5aeb5750cfd1d8d9"></span><em class="property">const</em> ValueType &amp;<code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVectorE" title="rocalution::LocalVector">LocalVector</a><code class="descclassname">::</code></code><code class="descname">operator[]</code><span class="sig-paren">(</span>int <em>i</em><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd></dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Accessing elements via the <em>[]</em> operators is slow. Use this for debugging purposes only. There is no direct access to the elements of matrices due to the sparsity structure. Matrices can be imported by a copy function. For CSR matrices, this is <a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrix11CopyFromCSREPKiPKiPK9ValueType" title="rocalution::LocalMatrix::CopyFromCSR"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::LocalMatrix::CopyFromCSR()</span></code></a> and <a class="reference internal" href="api.html#_CPPv3NK10rocalution11LocalMatrix9CopyToCSREPiPiP9ValueType" title="rocalution::LocalMatrix::CopyToCSR"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::LocalMatrix::CopyToCSR()</span></code></a>.</p>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Allocate the CSR matrix</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">csr_row_ptr</span>   <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">100</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">csr_col_ind</span>   <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">345</span><span class="p">];</span>
<span class="n">ValueType</span><span class="o">*</span> <span class="n">csr_val</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ValueType</span><span class="p">[</span><span class="mi">345</span><span class="p">];</span>

<span class="c1">// Fill the CSR matrix</span>
<span class="c1">// ...</span>

<span class="c1">// rocALUTION local matrix object</span>
<span class="n">LocalMatrix</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span> <span class="n">mat</span><span class="p">;</span>

<span class="c1">// Import CSR matrix to rocALUTION</span>
<span class="n">mat</span><span class="p">.</span><span class="n">AllocateCSR</span><span class="p">(</span><span class="s">&quot;my_matrix&quot;</span><span class="p">,</span> <span class="mi">345</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
<span class="n">mat</span><span class="p">.</span><span class="n">CopyFromCSR</span><span class="p">(</span><span class="n">csr_row_ptr</span><span class="p">,</span> <span class="n">csr_col</span><span class="p">,</span> <span class="n">csr_val</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="raw-access-to-the-data">
<h3>Raw Access to the Data<a class="headerlink" href="#raw-access-to-the-data" title="Permalink to this headline">¶</a></h3>
<div class="section" id="setdataptr">
<span id="id9"></span><h4>SetDataPtr<a class="headerlink" href="#setdataptr" title="Permalink to this headline">¶</a></h4>
<p>For vector and matrix objects, direct access to the raw data can be obtained via pointers. Already allocated data can be set with <em>SetDataPtr</em>. Setting data pointers will leave the original pointers empty.</p>
<dl class="function">
<dt id="_CPPv3N10rocalution11LocalVector10SetDataPtrEPP9ValueTypeNSt6stringEi">
<span id="_CPPv2N10rocalution11LocalVector10SetDataPtrEPP9ValueTypeNSt6stringEi"></span><span id="rocalution::LocalVector::SetDataPtr__ValueTypePP.ss.i"></span><span class="target" id="classrocalution_1_1_local_vector_1ae189cd6c550d72df04f2e7a15c9a5d4a"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVectorE" title="rocalution::LocalVector">LocalVector</a><code class="descclassname">::</code></code><code class="descname">SetDataPtr</code><span class="sig-paren">(</span>ValueType **<em>ptr</em>, std::string <em>name</em>, int <em>size</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize a <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> on the host with externally allocated data. </p>
<p><code class="docutils literal notranslate"><span class="pre">SetDataPtr</span></code> has direct access to the raw data via pointers. Already allocated data can be set by passing the pointer.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Setting data pointer will leave the original pointer empty (set to <code class="docutils literal notranslate"><span class="pre">NULL</span></code>).</dd>
<dt><strong>Example</strong></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Allocate</span> <span class="n">vector</span>
<span class="n">ValueType</span><span class="o">*</span> <span class="n">ptr_vec</span> <span class="o">=</span> <span class="n">new</span> <span class="n">ValueType</span><span class="p">[</span><span class="mi">200</span><span class="p">];</span>

<span class="o">//</span> <span class="n">Fill</span> <span class="n">vector</span>
<span class="o">//</span> <span class="o">...</span>

<span class="o">//</span> <span class="n">rocALUTION</span> <span class="n">local</span> <span class="n">vector</span> <span class="nb">object</span>
<span class="n">LocalVector</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Set</span> <span class="n">the</span> <span class="n">vector</span> <span class="n">data</span><span class="p">,</span> <span class="n">ptr_vec</span> <span class="n">will</span> <span class="n">become</span> <span class="n">invalid</span>
<span class="n">vec</span><span class="o">.</span><span class="n">SetDataPtr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr_vec</span><span class="p">,</span> <span class="s2">&quot;my_vector&quot;</span><span class="p">,</span> <span class="mi">200</span><span class="p">);</span>
</pre></div>
</div>
 </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11LocalMatrix13SetDataPtrCOOEPPiPPiPP9ValueTypeNSt6stringEiii">
<span id="_CPPv2N10rocalution11LocalMatrix13SetDataPtrCOOEPPiPPiPP9ValueTypeNSt6stringEiii"></span><span id="rocalution::LocalMatrix::SetDataPtrCOO__iPP.iPP.ValueTypePP.ss.i.i.i"></span><span class="target" id="classrocalution_1_1_local_matrix_1acdfeb3a318104a38a539ce2e14497346"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">SetDataPtrCOO</code><span class="sig-paren">(</span>int **<em>row</em>, int **<em>col</em>, ValueType **<em>val</em>, std::string <em>name</em>, int <em>nnz</em>, int <em>nrow</em>, int <em>ncol</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11LocalMatrix13SetDataPtrCSREPPiPPiPP9ValueTypeNSt6stringEiii">
<span id="_CPPv2N10rocalution11LocalMatrix13SetDataPtrCSREPPiPPiPP9ValueTypeNSt6stringEiii"></span><span id="rocalution::LocalMatrix::SetDataPtrCSR__iPP.iPP.ValueTypePP.ss.i.i.i"></span><span class="target" id="classrocalution_1_1_local_matrix_1ac4d2555ce3f1b82bedfbcd8d80a9990f"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">SetDataPtrCSR</code><span class="sig-paren">(</span>int **<em>row_offset</em>, int **<em>col</em>, ValueType **<em>val</em>, std::string <em>name</em>, int <em>nnz</em>, int <em>nrow</em>, int <em>ncol</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11LocalMatrix14SetDataPtrMCSREPPiPPiPP9ValueTypeNSt6stringEiii">
<span id="_CPPv2N10rocalution11LocalMatrix14SetDataPtrMCSREPPiPPiPP9ValueTypeNSt6stringEiii"></span><span id="rocalution::LocalMatrix::SetDataPtrMCSR__iPP.iPP.ValueTypePP.ss.i.i.i"></span><span class="target" id="classrocalution_1_1_local_matrix_1aa5213597d99fc349aac27a72d1b26f8b"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">SetDataPtrMCSR</code><span class="sig-paren">(</span>int **<em>row_offset</em>, int **<em>col</em>, ValueType **<em>val</em>, std::string <em>name</em>, int <em>nnz</em>, int <em>nrow</em>, int <em>ncol</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11LocalMatrix13SetDataPtrELLEPPiPP9ValueTypeNSt6stringEiiii">
<span id="_CPPv2N10rocalution11LocalMatrix13SetDataPtrELLEPPiPP9ValueTypeNSt6stringEiiii"></span><span id="rocalution::LocalMatrix::SetDataPtrELL__iPP.ValueTypePP.ss.i.i.i.i"></span><span class="target" id="classrocalution_1_1_local_matrix_1af7e5a78d103a2471cef1f1d59f011492"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">SetDataPtrELL</code><span class="sig-paren">(</span>int **<em>col</em>, ValueType **<em>val</em>, std::string <em>name</em>, int <em>nnz</em>, int <em>nrow</em>, int <em>ncol</em>, int <em>max_row</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11LocalMatrix13SetDataPtrDIAEPPiPP9ValueTypeNSt6stringEiiii">
<span id="_CPPv2N10rocalution11LocalMatrix13SetDataPtrDIAEPPiPP9ValueTypeNSt6stringEiiii"></span><span id="rocalution::LocalMatrix::SetDataPtrDIA__iPP.ValueTypePP.ss.i.i.i.i"></span><span class="target" id="classrocalution_1_1_local_matrix_1a0f2ba4a64a7dbcb539b4e553ac8f1fc6"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">SetDataPtrDIA</code><span class="sig-paren">(</span>int **<em>offset</em>, ValueType **<em>val</em>, std::string <em>name</em>, int <em>nnz</em>, int <em>nrow</em>, int <em>ncol</em>, int <em>num_diag</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11LocalMatrix15SetDataPtrDENSEEPP9ValueTypeNSt6stringEii">
<span id="_CPPv2N10rocalution11LocalMatrix15SetDataPtrDENSEEPP9ValueTypeNSt6stringEii"></span><span id="rocalution::LocalMatrix::SetDataPtrDENSE__ValueTypePP.ss.i.i"></span><span class="target" id="classrocalution_1_1_local_matrix_1a7094a60209b0a690c9046357c841cac2"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">SetDataPtrDENSE</code><span class="sig-paren">(</span>ValueType **<em>val</em>, std::string <em>name</em>, int <em>nrow</em>, int <em>ncol</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

</div>
<div class="section" id="leavedataptr">
<span id="id10"></span><h4>LeaveDataPtr<a class="headerlink" href="#leavedataptr" title="Permalink to this headline">¶</a></h4>
<p>With <em>LeaveDataPtr</em>, the raw data from the object can be obtained. This will leave the object empty.</p>
<dl class="function">
<dt id="_CPPv3N10rocalution11LocalVector12LeaveDataPtrEPP9ValueType">
<span id="_CPPv2N10rocalution11LocalVector12LeaveDataPtrEPP9ValueType"></span><span id="rocalution::LocalVector::LeaveDataPtr__ValueTypePP"></span><span class="target" id="classrocalution_1_1_local_vector_1a9400481562559c79b10346b8af097e9f"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVectorE" title="rocalution::LocalVector">LocalVector</a><code class="descclassname">::</code></code><code class="descname">LeaveDataPtr</code><span class="sig-paren">(</span>ValueType **<em>ptr</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Leave a <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> to host pointers. </p>
<p><code class="docutils literal notranslate"><span class="pre">LeaveDataPtr</span></code> has direct access to the raw data via pointers. A <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> object can leave its raw data to a host pointer. This will leave the <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> empty.</p>
<p><dl class="docutils">
<dt><strong>Example</strong></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">rocALUTION</span> <span class="n">local</span> <span class="n">vector</span> <span class="nb">object</span>
<span class="n">LocalVector</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Allocate</span> <span class="n">the</span> <span class="n">vector</span>
<span class="n">vec</span><span class="o">.</span><span class="n">Allocate</span><span class="p">(</span><span class="s2">&quot;my_vector&quot;</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>

<span class="o">//</span> <span class="n">Fill</span> <span class="n">vector</span>
<span class="o">//</span> <span class="o">...</span>

<span class="n">ValueType</span><span class="o">*</span> <span class="n">ptr_vec</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Get</span> <span class="p">(</span><span class="n">steal</span><span class="p">)</span> <span class="n">the</span> <span class="n">data</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">vector</span><span class="p">,</span> <span class="n">this</span> <span class="n">will</span> <span class="n">leave</span> <span class="n">the</span> <span class="n">local</span> <span class="n">vector</span> <span class="nb">object</span> <span class="n">empty</span>
<span class="n">vec</span><span class="o">.</span><span class="n">LeaveDataPtr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr_vec</span><span class="p">);</span>
</pre></div>
</div>
 </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11LocalMatrix15LeaveDataPtrCOOEPPiPPiPP9ValueType">
<span id="_CPPv2N10rocalution11LocalMatrix15LeaveDataPtrCOOEPPiPPiPP9ValueType"></span><span id="rocalution::LocalMatrix::LeaveDataPtrCOO__iPP.iPP.ValueTypePP"></span><span class="target" id="classrocalution_1_1_local_matrix_1a9763c9317b9e3cee8410f79f54c879d3"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">LeaveDataPtrCOO</code><span class="sig-paren">(</span>int **<em>row</em>, int **<em>col</em>, ValueType **<em>val</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11LocalMatrix15LeaveDataPtrCSREPPiPPiPP9ValueType">
<span id="_CPPv2N10rocalution11LocalMatrix15LeaveDataPtrCSREPPiPPiPP9ValueType"></span><span id="rocalution::LocalMatrix::LeaveDataPtrCSR__iPP.iPP.ValueTypePP"></span><span class="target" id="classrocalution_1_1_local_matrix_1ad67e42bdef63ec1d31d51391edb71f06"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">LeaveDataPtrCSR</code><span class="sig-paren">(</span>int **<em>row_offset</em>, int **<em>col</em>, ValueType **<em>val</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11LocalMatrix16LeaveDataPtrMCSREPPiPPiPP9ValueType">
<span id="_CPPv2N10rocalution11LocalMatrix16LeaveDataPtrMCSREPPiPPiPP9ValueType"></span><span id="rocalution::LocalMatrix::LeaveDataPtrMCSR__iPP.iPP.ValueTypePP"></span><span class="target" id="classrocalution_1_1_local_matrix_1a1ac5d3d11c02ed8f2bb288c39a29f108"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">LeaveDataPtrMCSR</code><span class="sig-paren">(</span>int **<em>row_offset</em>, int **<em>col</em>, ValueType **<em>val</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11LocalMatrix15LeaveDataPtrELLEPPiPP9ValueTypeRi">
<span id="_CPPv2N10rocalution11LocalMatrix15LeaveDataPtrELLEPPiPP9ValueTypeRi"></span><span id="rocalution::LocalMatrix::LeaveDataPtrELL__iPP.ValueTypePP.iR"></span><span class="target" id="classrocalution_1_1_local_matrix_1acd943926268fb9ddf641df08bb45069b"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">LeaveDataPtrELL</code><span class="sig-paren">(</span>int **<em>col</em>, ValueType **<em>val</em>, int &amp;<em>max_row</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11LocalMatrix15LeaveDataPtrDIAEPPiPP9ValueTypeRi">
<span id="_CPPv2N10rocalution11LocalMatrix15LeaveDataPtrDIAEPPiPP9ValueTypeRi"></span><span id="rocalution::LocalMatrix::LeaveDataPtrDIA__iPP.ValueTypePP.iR"></span><span class="target" id="classrocalution_1_1_local_matrix_1ae4214ba5874900000d5455e511010d90"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">LeaveDataPtrDIA</code><span class="sig-paren">(</span>int **<em>offset</em>, ValueType **<em>val</em>, int &amp;<em>num_diag</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11LocalMatrix17LeaveDataPtrDENSEEPP9ValueType">
<span id="_CPPv2N10rocalution11LocalMatrix17LeaveDataPtrDENSEEPP9ValueType"></span><span id="rocalution::LocalMatrix::LeaveDataPtrDENSE__ValueTypePP"></span><span class="target" id="classrocalution_1_1_local_matrix_1a396f929bbd45cba276a1e0ef8f9adece"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">LeaveDataPtrDENSE</code><span class="sig-paren">(</span>ValueType **<em>val</em><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the object is allocated on the host, then the pointers obtained from <a class="reference internal" href="#setdataptr"><span class="std std-ref">SetDataPtr</span></a> and <a class="reference internal" href="#leavedataptr"><span class="std std-ref">LeaveDataPtr</span></a> will be on the host. If the vector object is on the accelerator, then the data pointers will be on the accelerator.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the object is moved to and from the accelerator, then the original pointer will be invalid.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Never rely on old pointers, hidden object movement to and from the accelerator will make them invalid.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Whenever you pass or obtain pointers to/from a rocALUTION object, you need to use the same memory allocation/free functions. Please check the source code for that (for host <em>src/utils/allocate_free.cpp</em> and for HIP <em>src/base/hip/hip_allocate_free.cpp</em>)</p>
</div>
</div>
</div>
<div class="section" id="copy-csr-matrix-host-data">
<h3>Copy CSR Matrix Host Data<a class="headerlink" href="#copy-csr-matrix-host-data" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv3N10rocalution11LocalMatrix15CopyFromHostCSREPKiPKiPK9ValueTypeKNSt6stringEiii">
<span id="_CPPv2N10rocalution11LocalMatrix15CopyFromHostCSREPKiPKiPK9ValueTypeKNSt6stringEiii"></span><span id="rocalution::LocalMatrix::CopyFromHostCSR__iCP.iCP.ValueTypeCP.ssC.i.i.i"></span><span class="target" id="classrocalution_1_1_local_matrix_1a4b22c7c6c5264370fa6c141b2ba7d5f1"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">CopyFromHostCSR</code><span class="sig-paren">(</span><em class="property">const</em> int *<em>row_offset</em>, <em class="property">const</em> int *<em>col</em>, <em class="property">const</em> ValueType *<em>val</em>, <em class="property">const</em> std::string <em>name</em>, int <em>nnz</em>, int <em>nrow</em>, int <em>ncol</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Allocates and copies (imports) a host CSR matrix. </p>
<p>If the CSR matrix data pointers are only accessible as constant, the user can create a <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> object and pass const CSR host pointers. The <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> will then be allocated and the data will be copied to the corresponding backend, where the original object was located at.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">row_offset</span></code>: CSR matrix row offset pointers. </li>
<li><code class="docutils literal notranslate"><span class="pre">col</span></code>: CSR matrix column indices. </li>
<li><code class="docutils literal notranslate"><span class="pre">val</span></code>: CSR matrix values array. </li>
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: Matrix object name. </li>
<li><code class="docutils literal notranslate"><span class="pre">nnz</span></code>: Number of non-zero elements. </li>
<li><code class="docutils literal notranslate"><span class="pre">nrow</span></code>: Number of rows. </li>
<li><code class="docutils literal notranslate"><span class="pre">ncol</span></code>: Number of columns. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="copy-data">
<h3>Copy Data<a class="headerlink" href="#copy-data" title="Permalink to this headline">¶</a></h3>
<p>The user can copy data to and from a local vector by using <em>CopyFromData()</em> <em>CopyToData()</em>.</p>
<dl class="function">
<dt id="_CPPv3N10rocalution11LocalVector12CopyFromDataEPK9ValueType">
<span id="_CPPv2N10rocalution11LocalVector12CopyFromDataEPK9ValueType"></span><span id="rocalution::LocalVector::CopyFromData__ValueTypeCP"></span><span class="target" id="classrocalution_1_1_local_vector_1acecc27f2c96f010bb8f43749f1f643ce"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVectorE" title="rocalution::LocalVector">LocalVector</a><code class="descclassname">::</code></code><code class="descname">CopyFromData</code><span class="sig-paren">(</span><em class="property">const</em> ValueType *<em>data</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Copy (import) vector. </p>
<p>Copy (import) vector data that is described in one array (values). The object data has to be allocated with <a class="reference internal" href="#classrocalution_1_1_local_vector_1ae9ad82b77b1fa3f94112092d69354a15"><span class="std std-ref">Allocate()</span></a>, using the corresponding size of the data, first.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">data</span></code>: data to be imported. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK10rocalution11LocalVector10CopyToDataEP9ValueType">
<span id="_CPPv2NK10rocalution11LocalVector10CopyToDataEP9ValueType"></span><span id="rocalution::LocalVector::CopyToData__ValueTypePC"></span><span class="target" id="classrocalution_1_1_local_vector_1aad7c0fe9094784b24ca6fd1be7749e64"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVectorE" title="rocalution::LocalVector">LocalVector</a><code class="descclassname">::</code></code><code class="descname">CopyToData</code><span class="sig-paren">(</span>ValueType *<em>data</em><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>Copy (export) vector. </p>
<p>Copy (export) vector data that is described in one array (values). The output array has to be allocated, using the corresponding size of the data, first. Size can be obtain by <a class="reference internal" href="api.html#classrocalution_1_1_vector_1a69a7295c57e35e030999c5764c05cfe7"><span class="std std-ref">GetSize()</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">data</span></code>: exported data. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="object-info">
<h3>Object Info<a class="headerlink" href="#object-info" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv3NK10rocalution14BaseRocalution4InfoEv">
<span id="_CPPv2NK10rocalution14BaseRocalution4InfoEv"></span><span id="rocalution::BaseRocalution::Info__voidC"></span><span class="target" id="classrocalution_1_1_base_rocalution_1a62720e4ccdd3879dcf093abc2688076e"></span><em class="property">virtual</em> void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution14BaseRocalutionE" title="rocalution::BaseRocalution">BaseRocalution</a><code class="descclassname">::</code></code><code class="descname">Info</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span> <em class="property">const</em> = 0<br /></dt>
<dd><p>Print object information. </p>
<p><code class="docutils literal notranslate"><span class="pre">Info</span></code> can print object information about any rocALUTION object. This information consists of object properties and backend data.</p>
<p><dl class="docutils">
<dt><strong>Example</strong></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mat</span><span class="o">.</span><span class="n">Info</span><span class="p">();</span>
<span class="n">vec</span><span class="o">.</span><span class="n">Info</span><span class="p">();</span>
</pre></div>
</div>
 </dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="copy">
<h3>Copy<a class="headerlink" href="#copy" title="Permalink to this headline">¶</a></h3>
<p>All matrix and vector objects provide a <em>CopyFrom()</em> function. The destination object should have the same size or be empty. In the latter case, the object is allocated at the source platform.</p>
<dl class="function">
<dt id="_CPPv3N10rocalution11LocalVector8CopyFromERK11LocalVectorI9ValueTypeE">
<span id="_CPPv2N10rocalution11LocalVector8CopyFromERK11LocalVectorI9ValueTypeE"></span><span id="rocalution::LocalVector::CopyFrom__LocalVector:ValueType:CR"></span><span class="target" id="classrocalution_1_1_local_vector_1abf2ee09b2fccba75add5ca106026cb25"></span><em class="property">virtual</em> void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVectorE" title="rocalution::LocalVector">LocalVector</a><code class="descclassname">::</code></code><code class="descname">CopyFrom</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVectorE" title="rocalution::LocalVector">LocalVector</a>&lt;ValueType&gt; &amp;<em>src</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Copy vector from another vector. </p>
<p><code class="docutils literal notranslate"><span class="pre">CopyFrom</span></code> copies values from another vector.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function allows cross platform copying. One of the objects could be allocated on the accelerator backend.</dd>
<dt><strong>Example</strong></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LocalVector</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span> <span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Allocate</span> <span class="ow">and</span> <span class="n">initialize</span> <span class="n">vec1</span> <span class="ow">and</span> <span class="n">vec2</span>
<span class="o">//</span> <span class="o">...</span>

<span class="o">//</span> <span class="n">Move</span> <span class="n">vec1</span> <span class="n">to</span> <span class="n">accelerator</span>
<span class="o">//</span> <span class="n">vec1</span><span class="o">.</span><span class="n">MoveToAccelerator</span><span class="p">();</span>

<span class="o">//</span> <span class="n">Now</span><span class="p">,</span> <span class="n">vec1</span> <span class="ow">is</span> <span class="n">on</span> <span class="n">the</span> <span class="n">accelerator</span> <span class="p">(</span><span class="k">if</span> <span class="n">available</span><span class="p">)</span>
<span class="o">//</span> <span class="ow">and</span> <span class="n">vec2</span> <span class="ow">is</span> <span class="n">on</span> <span class="n">the</span> <span class="n">host</span>

<span class="o">//</span> <span class="n">Copy</span> <span class="n">vec1</span> <span class="n">to</span> <span class="n">vec2</span> <span class="p">(</span><span class="ow">or</span> <span class="n">vice</span> <span class="n">versa</span><span class="p">)</span> <span class="n">will</span> <span class="n">move</span> <span class="n">data</span> <span class="n">between</span> <span class="n">host</span> <span class="ow">and</span>
<span class="o">//</span> <span class="n">accelerator</span> <span class="n">backend</span>
<span class="n">vec1</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="n">vec2</span><span class="p">);</span>
</pre></div>
</div>
 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">src</span></code>: <a class="reference internal" href="api.html#classrocalution_1_1_vector"><span class="std std-ref">Vector</span></a>, where values should be copied from.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11LocalMatrix8CopyFromERK11LocalMatrixI9ValueTypeE">
<span id="_CPPv2N10rocalution11LocalMatrix8CopyFromERK11LocalMatrixI9ValueTypeE"></span><span id="rocalution::LocalMatrix::CopyFrom__LocalMatrix:ValueType:CR"></span><span class="target" id="classrocalution_1_1_local_matrix_1a2b667e9fd28f21eaaefdd194ed15158f"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">CopyFrom</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a>&lt;ValueType&gt; &amp;<em>src</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Copy matrix from another <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a>. </p>
<p><code class="docutils literal notranslate"><span class="pre">CopyFrom</span></code> copies values and structure from another local matrix. Source and destination matrix should be in the same format.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function allows cross platform copying. One of the objects could be allocated on the accelerator backend.</dd>
<dt><strong>Example</strong></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LocalMatrix</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span> <span class="n">mat1</span><span class="p">,</span> <span class="n">mat2</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Allocate</span> <span class="ow">and</span> <span class="n">initialize</span> <span class="n">mat1</span> <span class="ow">and</span> <span class="n">mat2</span>
<span class="o">//</span> <span class="o">...</span>

<span class="o">//</span> <span class="n">Move</span> <span class="n">mat1</span> <span class="n">to</span> <span class="n">accelerator</span>
<span class="o">//</span> <span class="n">mat1</span><span class="o">.</span><span class="n">MoveToAccelerator</span><span class="p">();</span>

<span class="o">//</span> <span class="n">Now</span><span class="p">,</span> <span class="n">mat1</span> <span class="ow">is</span> <span class="n">on</span> <span class="n">the</span> <span class="n">accelerator</span> <span class="p">(</span><span class="k">if</span> <span class="n">available</span><span class="p">)</span>
<span class="o">//</span> <span class="ow">and</span> <span class="n">mat2</span> <span class="ow">is</span> <span class="n">on</span> <span class="n">the</span> <span class="n">host</span>

<span class="o">//</span> <span class="n">Copy</span> <span class="n">mat1</span> <span class="n">to</span> <span class="n">mat2</span> <span class="p">(</span><span class="ow">or</span> <span class="n">vice</span> <span class="n">versa</span><span class="p">)</span> <span class="n">will</span> <span class="n">move</span> <span class="n">data</span> <span class="n">between</span> <span class="n">host</span> <span class="ow">and</span>
<span class="o">//</span> <span class="n">accelerator</span> <span class="n">backend</span>
<span class="n">mat1</span><span class="o">.</span><span class="n">CopyFrom</span><span class="p">(</span><span class="n">mat2</span><span class="p">);</span>
</pre></div>
</div>
 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">src</span></code>: Local matrix where values and structure should be copied from.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For vectors, the user can specify source and destination offsets and thus copy only a part of the whole vector into another vector.</p>
</div>
<dl class="function">
<dt id="_CPPv3N10rocalution11LocalVector8CopyFromERK11LocalVectorI9ValueTypeEiii">
<span id="_CPPv2N10rocalution11LocalVector8CopyFromERK11LocalVectorI9ValueTypeEiii"></span><span id="rocalution::LocalVector::CopyFrom__LocalVector:ValueType:CR.i.i.i"></span><span class="target" id="classrocalution_1_1_local_vector_1a54ca27df605bb2c1567e3387ae7d57de"></span><em class="property">virtual</em> void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVectorE" title="rocalution::LocalVector">LocalVector</a><code class="descclassname">::</code></code><code class="descname">CopyFrom</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVectorE" title="rocalution::LocalVector">LocalVector</a>&lt;ValueType&gt; &amp;<em>src</em>, int <em>src_offset</em>, int <em>dst_offset</em>, int <em>size</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Copy vector from another vector with offsets and size. </p>
<p><code class="docutils literal notranslate"><span class="pre">CopyFrom</span></code> copies values with specific source and destination offsets and sizes from another vector.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function allows cross platform copying. One of the objects could be allocated on the accelerator backend.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">src</span></code>: <a class="reference internal" href="api.html#classrocalution_1_1_vector"><span class="std std-ref">Vector</span></a>, where values should be copied from. </li>
<li><code class="docutils literal notranslate"><span class="pre">src_offset</span></code>: source offset. </li>
<li><code class="docutils literal notranslate"><span class="pre">dst_offset</span></code>: destination offset. </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: number of entries to be copied. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="clone">
<h3>Clone<a class="headerlink" href="#clone" title="Permalink to this headline">¶</a></h3>
<p>The copy operators allow you to copy the values of the object to another object, without changing the backend specification of the object. In many algorithms, you might need auxiliary vectors or matrices. These objects can be cloned with CloneFrom().</p>
<div class="section" id="clonefrom">
<h4>CloneFrom<a class="headerlink" href="#clonefrom" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="_CPPv3N10rocalution11LocalVector9CloneFromERK11LocalVectorI9ValueTypeE">
<span id="_CPPv2N10rocalution11LocalVector9CloneFromERK11LocalVectorI9ValueTypeE"></span><span id="rocalution::LocalVector::CloneFrom__LocalVector:ValueType:CR"></span><span class="target" id="classrocalution_1_1_local_vector_1a9eeae5cca8f0af5c5723510b1b280e60"></span><em class="property">virtual</em> void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVectorE" title="rocalution::LocalVector">LocalVector</a><code class="descclassname">::</code></code><code class="descname">CloneFrom</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVectorE" title="rocalution::LocalVector">LocalVector</a>&lt;ValueType&gt; &amp;<em>src</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N10rocalution11LocalVector9CloneFromERK11LocalVectorI9ValueTypeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clone the vector. </p>
<p><code class="docutils literal notranslate"><span class="pre">CloneFrom</span></code> clones the entire vector, including data and backend descriptor from another <a class="reference internal" href="api.html#classrocalution_1_1_vector"><span class="std std-ref">Vector</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Example</strong></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LocalVector</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Allocate</span> <span class="ow">and</span> <span class="n">initialize</span> <span class="n">vec</span> <span class="p">(</span><span class="n">host</span> <span class="ow">or</span> <span class="n">accelerator</span><span class="p">)</span>
<span class="o">//</span> <span class="o">...</span>

<span class="n">LocalVector</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span> <span class="n">tmp</span><span class="p">;</span>

<span class="o">//</span> <span class="n">By</span> <span class="n">cloning</span> <span class="n">vec</span><span class="p">,</span> <span class="n">tmp</span> <span class="n">will</span> <span class="n">have</span> <span class="n">identical</span> <span class="n">values</span> <span class="ow">and</span> <span class="n">will</span> <span class="n">be</span> <span class="n">on</span> <span class="n">the</span> <span class="n">same</span>
<span class="o">//</span> <span class="n">backend</span> <span class="k">as</span> <span class="n">vec</span>
<span class="n">tmp</span><span class="o">.</span><span class="n">CloneFrom</span><span class="p">(</span><span class="n">vec</span><span class="p">);</span>
</pre></div>
</div>
 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">src</span></code>: <a class="reference internal" href="api.html#classrocalution_1_1_vector"><span class="std std-ref">Vector</span></a> to clone from.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11LocalMatrix9CloneFromERK11LocalMatrixI9ValueTypeE">
<span id="_CPPv2N10rocalution11LocalMatrix9CloneFromERK11LocalMatrixI9ValueTypeE"></span><span id="rocalution::LocalMatrix::CloneFrom__LocalMatrix:ValueType:CR"></span><span class="target" id="classrocalution_1_1_local_matrix_1acd9898aa33dc1f333a8eac885482e485"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">CloneFrom</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a>&lt;ValueType&gt; &amp;<em>src</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Clone the matrix. </p>
<p><code class="docutils literal notranslate"><span class="pre">CloneFrom</span></code> clones the entire matrix, including values, structure and backend descriptor from another <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Example</strong></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LocalMatrix</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span> <span class="n">mat</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Allocate</span> <span class="ow">and</span> <span class="n">initialize</span> <span class="n">mat</span> <span class="p">(</span><span class="n">host</span> <span class="ow">or</span> <span class="n">accelerator</span><span class="p">)</span>
<span class="o">//</span> <span class="o">...</span>

<span class="n">LocalMatrix</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span> <span class="n">tmp</span><span class="p">;</span>

<span class="o">//</span> <span class="n">By</span> <span class="n">cloning</span> <span class="n">mat</span><span class="p">,</span> <span class="n">tmp</span> <span class="n">will</span> <span class="n">have</span> <span class="n">identical</span> <span class="n">values</span> <span class="ow">and</span> <span class="n">structure</span> <span class="ow">and</span> <span class="n">will</span> <span class="n">be</span> <span class="n">on</span>
<span class="o">//</span> <span class="n">the</span> <span class="n">same</span> <span class="n">backend</span> <span class="k">as</span> <span class="n">mat</span>
<span class="n">tmp</span><span class="o">.</span><span class="n">CloneFrom</span><span class="p">(</span><span class="n">mat</span><span class="p">);</span>
</pre></div>
</div>
 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">src</span></code>: <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> to clone from.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="clonebackend">
<h4>CloneBackend<a class="headerlink" href="#clonebackend" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="_CPPv3N10rocalution14BaseRocalution12CloneBackendERK14BaseRocalutionI9ValueTypeE">
<span id="_CPPv2N10rocalution14BaseRocalution12CloneBackendERK14BaseRocalutionI9ValueTypeE"></span><span id="rocalution::BaseRocalution::CloneBackend__BaseRocalution:ValueType:CR"></span><span class="target" id="classrocalution_1_1_base_rocalution_1a85acdb9844b7c6a630f14ace59d99f5d"></span><em class="property">virtual</em> void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution14BaseRocalutionE" title="rocalution::BaseRocalution">BaseRocalution</a><code class="descclassname">::</code></code><code class="descname">CloneBackend</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="api.html#_CPPv3N10rocalution14BaseRocalutionE" title="rocalution::BaseRocalution">BaseRocalution</a>&lt;ValueType&gt; &amp;<em>src</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Clone the Backend descriptor from another object. </p>
<p>With <code class="docutils literal notranslate"><span class="pre">CloneBackend</span></code>, the backend can be cloned without copying any data. This is especially useful, if several objects should reside on the same backend, but keep their original data.</p>
<p><dl class="docutils">
<dt><strong>Example</strong></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LocalVector</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="n">LocalMatrix</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span> <span class="n">mat</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Allocate</span> <span class="ow">and</span> <span class="n">initialize</span> <span class="n">vec</span> <span class="ow">and</span> <span class="n">mat</span>
<span class="o">//</span> <span class="o">...</span>

<span class="n">LocalVector</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span> <span class="n">tmp</span><span class="p">;</span>
<span class="o">//</span> <span class="n">By</span> <span class="n">cloning</span> <span class="n">backend</span><span class="p">,</span> <span class="n">tmp</span> <span class="ow">and</span> <span class="n">vec</span> <span class="n">will</span> <span class="n">have</span> <span class="n">the</span> <span class="n">same</span> <span class="n">backend</span> <span class="k">as</span> <span class="n">mat</span>
<span class="n">tmp</span><span class="o">.</span><span class="n">CloneBackend</span><span class="p">(</span><span class="n">mat</span><span class="p">);</span>
<span class="n">vec</span><span class="o">.</span><span class="n">CloneBackend</span><span class="p">(</span><span class="n">mat</span><span class="p">);</span>

<span class="o">//</span> <span class="n">The</span> <span class="n">following</span> <span class="n">matrix</span> <span class="n">vector</span> <span class="n">multiplication</span> <span class="n">will</span> <span class="n">be</span> <span class="n">performed</span> <span class="n">on</span> <span class="n">the</span> <span class="n">backend</span>
<span class="o">//</span> <span class="n">selected</span> <span class="ow">in</span> <span class="n">mat</span>
<span class="n">mat</span><span class="o">.</span><span class="n">Apply</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
</pre></div>
</div>
 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">src</span></code>: Object, where the backend should be cloned from.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</div>
<div class="section" id="check">
<h3>Check<a class="headerlink" href="#check" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv3NK10rocalution11LocalVector5CheckEv">
<span id="_CPPv2NK10rocalution11LocalVector5CheckEv"></span><span id="rocalution::LocalVector::Check__voidC"></span><span class="target" id="classrocalution_1_1_local_vector_1a83a0ca326ebe939dac9cea93022dc663"></span><em class="property">virtual</em> bool <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVectorE" title="rocalution::LocalVector">LocalVector</a><code class="descclassname">::</code></code><code class="descname">Check</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK10rocalution11LocalVector5CheckEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Perform a sanity check of the vector. </p>
<p>Checks, if the vector contains valid data, i.e. if the values are not infinity and not NaN (not a number).</p>
<p><dl class="docutils">
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">true</span></code>: if the vector is ok (empty vector is also ok). </li>
<li><code class="docutils literal notranslate"><span class="pre">false</span></code>: if there is something wrong with the values. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK10rocalution11LocalMatrix5CheckEv">
<span id="_CPPv2NK10rocalution11LocalMatrix5CheckEv"></span><span id="rocalution::LocalMatrix::Check__voidC"></span><span class="target" id="classrocalution_1_1_local_matrix_1a69e093022f1ccd32d046422c4e6196f1"></span>bool <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">Check</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>Perform a sanity check of the matrix. </p>
<p>Checks, if the matrix contains valid data, i.e. if the values are not infinity and not NaN (not a number) and if the structure of the matrix is correct (e.g. indices cannot be negative, CSR and COO matrices have to be sorted, etc.).</p>
<p><dl class="docutils">
<dt><strong>Return Value</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">true</span></code>: if the matrix is ok (empty matrix is also ok). </li>
<li><code class="docutils literal notranslate"><span class="pre">false</span></code>: if there is something wrong with the structure or values. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<p>Checks, if the object contains valid data. For vectors, the function checks if the values are not infinity and not NaN (not a number). For matrices, this function checks the values and if the structure of the matrix is correct (e.g. indices cannot be negative, CSR and COO matrices have to be sorted, etc.).</p>
</div>
<div class="section" id="sort">
<h3>Sort<a class="headerlink" href="#sort" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv3N10rocalution11LocalMatrix4SortEv">
<span id="_CPPv2N10rocalution11LocalMatrix4SortEv"></span><span id="rocalution::LocalMatrix::Sort__void"></span><span class="target" id="classrocalution_1_1_local_matrix_1af06a2e47ded5fba67bdffc4d78240351"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">Sort</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Sort the matrix indices. </p>
<p>Sorts the matrix by indices.<ul class="simple">
<li>For CSR matrices, column values are sorted.</li>
<li>For COO matrices, row indices are sorted. </li>
</ul>
</p>
</dd></dl>

</div>
<div class="section" id="keying">
<h3>Keying<a class="headerlink" href="#keying" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv3NK10rocalution11LocalMatrix3KeyERlRlRl">
<span id="_CPPv2NK10rocalution11LocalMatrix3KeyERlRlRl"></span><span id="rocalution::LocalMatrix::Key__l-iR.l-iR.l-iRC"></span><span class="target" id="classrocalution_1_1_local_matrix_1a97e57c0b9a5637e2b067eab0636f0c31"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">Key</code><span class="sig-paren">(</span>long int &amp;<em>row_key</em>, long int &amp;<em>col_key</em>, long int &amp;<em>val_key</em><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>Compute a unique hash key for the matrix arrays. </p>
<p>Typically, it is hard to compare if two matrices have the same structure (and values). To do so, rocALUTION provides a keying function, that generates three keys, for the row index, column index and values array.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">row_key</span></code>: row index array key </li>
<li><code class="docutils literal notranslate"><span class="pre">col_key</span></code>: column index array key </li>
<li><code class="docutils literal notranslate"><span class="pre">val_key</span></code>: values array key </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="graph-analyzers">
<h3>Graph Analyzers<a class="headerlink" href="#graph-analyzers" title="Permalink to this headline">¶</a></h3>
<p>The following functions are available for analyzing the connectivity in graph of the underlying sparse matrix.</p>
<ul class="simple">
<li>(R)CMK Ordering</li>
<li>Maximal Independent Set</li>
<li>Multi-Coloring</li>
<li>Zero Block Permutation</li>
<li>Connectivity Ordering</li>
</ul>
<p>All graph analyzing functions return a permutation vector (integer type), which is supposed to be used with the <a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrix7PermuteERK11LocalVectorIiE" title="rocalution::LocalMatrix::Permute"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::LocalMatrix::Permute()</span></code></a> and <a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrix15PermuteBackwardERK11LocalVectorIiE" title="rocalution::LocalMatrix::PermuteBackward"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::LocalMatrix::PermuteBackward()</span></code></a> functions in the matrix and vector classes.</p>
<p>For further details, see <a href="#id11"><span class="problematic" id="id12">:cite:`SAAD`</span></a>.</p>
<div class="section" id="cuthill-mckee-ordering">
<h4>Cuthill-McKee Ordering<a class="headerlink" href="#cuthill-mckee-ordering" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="_CPPv3NK10rocalution11LocalMatrix3CMKEP11LocalVectorIiE">
<span id="_CPPv2NK10rocalution11LocalMatrix3CMKEP11LocalVectorIiE"></span><span id="rocalution::LocalMatrix::CMK__LocalVector:i:PC"></span><span class="target" id="classrocalution_1_1_local_matrix_1a14788d661ea22a00f7a74601e132bb50"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">CMK</code><span class="sig-paren">(</span><a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVectorE" title="rocalution::LocalVector">LocalVector</a>&lt;int&gt; *<em>permutation</em><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>Create permutation vector for CMK reordering of the matrix. </p>
<p>The Cuthill-McKee ordering minimize the bandwidth of a given sparse matrix.</p>
<p><dl class="docutils">
<dt><strong>Example</strong></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LocalVector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span> <span class="n">cmk</span><span class="p">;</span>

<span class="n">mat</span><span class="o">.</span><span class="n">CMK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmk</span><span class="p">);</span>
<span class="n">mat</span><span class="o">.</span><span class="n">Permute</span><span class="p">(</span><span class="n">cmk</span><span class="p">);</span>
</pre></div>
</div>
 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">permutation</span></code>: permutation vector for CMK reordering</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK10rocalution11LocalMatrix4RCMKEP11LocalVectorIiE">
<span id="_CPPv2NK10rocalution11LocalMatrix4RCMKEP11LocalVectorIiE"></span><span id="rocalution::LocalMatrix::RCMK__LocalVector:i:PC"></span><span class="target" id="classrocalution_1_1_local_matrix_1aaed8576707da922ffa1107f1ce427052"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">RCMK</code><span class="sig-paren">(</span><a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVectorE" title="rocalution::LocalVector">LocalVector</a>&lt;int&gt; *<em>permutation</em><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>Create permutation vector for reverse CMK reordering of the matrix. </p>
<p>The Reverse Cuthill-McKee ordering minimize the bandwidth of a given sparse matrix.</p>
<p><dl class="docutils">
<dt><strong>Example</strong></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LocalVector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span> <span class="n">rcmk</span><span class="p">;</span>

<span class="n">mat</span><span class="o">.</span><span class="n">RCMK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rcmk</span><span class="p">);</span>
<span class="n">mat</span><span class="o">.</span><span class="n">Permute</span><span class="p">(</span><span class="n">rcmk</span><span class="p">);</span>
</pre></div>
</div>
 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">permutation</span></code>: permutation vector for reverse CMK reordering</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="maximal-independent-set">
<h4>Maximal Independent Set<a class="headerlink" href="#maximal-independent-set" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="_CPPv3NK10rocalution11LocalMatrix21MaximalIndependentSetERiP11LocalVectorIiE">
<span id="_CPPv2NK10rocalution11LocalMatrix21MaximalIndependentSetERiP11LocalVectorIiE"></span><span id="rocalution::LocalMatrix::MaximalIndependentSet__iR.LocalVector:i:PC"></span><span class="target" id="classrocalution_1_1_local_matrix_1ac8448fee69b9c9be5335083878ae5aa9"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">MaximalIndependentSet</code><span class="sig-paren">(</span>int &amp;<em>size</em>, <a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVectorE" title="rocalution::LocalVector">LocalVector</a>&lt;int&gt; *<em>permutation</em><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>Perform maximal independent set decomposition of the matrix. </p>
<p>The Maximal Independent Set algorithm finds a set with maximal size, that contains elements that do not depend on other elements in this set.</p>
<p><dl class="docutils">
<dt><strong>Example</strong></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LocalVector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span> <span class="n">mis</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">size</span><span class="p">;</span>

<span class="n">mat</span><span class="o">.</span><span class="n">MaximalIndependentSet</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mis</span><span class="p">);</span>
<span class="n">mat</span><span class="o">.</span><span class="n">Permute</span><span class="p">(</span><span class="n">mis</span><span class="p">);</span>
</pre></div>
</div>
 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: number of independent sets </li>
<li><code class="docutils literal notranslate"><span class="pre">permutation</span></code>: permutation vector for maximal independent set reordering</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="multi-coloring">
<h4>Multi-Coloring<a class="headerlink" href="#multi-coloring" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="_CPPv3NK10rocalution11LocalMatrix13MultiColoringERiPPiP11LocalVectorIiE">
<span id="_CPPv2NK10rocalution11LocalMatrix13MultiColoringERiPPiP11LocalVectorIiE"></span><span id="rocalution::LocalMatrix::MultiColoring__iR.iPP.LocalVector:i:PC"></span><span class="target" id="classrocalution_1_1_local_matrix_1a55000bad263b499ab9638ec95b852a1e"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">MultiColoring</code><span class="sig-paren">(</span>int &amp;<em>num_colors</em>, int **<em>size_colors</em>, <a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVectorE" title="rocalution::LocalVector">LocalVector</a>&lt;int&gt; *<em>permutation</em><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>Perform multi-coloring decomposition of the matrix. </p>
<p>The Multi-Coloring algorithm builds a permutation (coloring of the matrix) in a way such that no two adjacent nodes in the sparse matrix have the same color.</p>
<p><dl class="docutils">
<dt><strong>Example</strong></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LocalVector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span> <span class="n">mc</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">num_colors</span><span class="p">;</span>
<span class="nb">int</span><span class="o">*</span> <span class="n">block_colors</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>

<span class="n">mat</span><span class="o">.</span><span class="n">MultiColoring</span><span class="p">(</span><span class="n">num_colors</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block_colors</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mc</span><span class="p">);</span>
<span class="n">mat</span><span class="o">.</span><span class="n">Permute</span><span class="p">(</span><span class="n">mc</span><span class="p">);</span>
</pre></div>
</div>
 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">num_colors</span></code>: number of colors </li>
<li><code class="docutils literal notranslate"><span class="pre">size_colors</span></code>: pointer to array that holds the number of nodes for each color </li>
<li><code class="docutils literal notranslate"><span class="pre">permutation</span></code>: permutation vector for multi-coloring reordering</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="zero-block-permutation">
<h4>Zero Block Permutation<a class="headerlink" href="#zero-block-permutation" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="_CPPv3NK10rocalution11LocalMatrix20ZeroBlockPermutationERiP11LocalVectorIiE">
<span id="_CPPv2NK10rocalution11LocalMatrix20ZeroBlockPermutationERiP11LocalVectorIiE"></span><span id="rocalution::LocalMatrix::ZeroBlockPermutation__iR.LocalVector:i:PC"></span><span class="target" id="classrocalution_1_1_local_matrix_1a378871e3f6570a110c844d4b77fdb5c9"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">ZeroBlockPermutation</code><span class="sig-paren">(</span>int &amp;<em>size</em>, <a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVectorE" title="rocalution::LocalVector">LocalVector</a>&lt;int&gt; *<em>permutation</em><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>Return a permutation for saddle-point problems (zero diagonal entries) </p>
<p>For Saddle-Point problems, (i.e. matrices with zero diagonal entries), the Zero Block Permutation maps all zero-diagonal elements to the last block of the matrix.</p>
<p><dl class="docutils">
<dt><strong>Example</strong></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LocalVector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span> <span class="n">zbp</span><span class="p">;</span>
<span class="nb">int</span> <span class="n">size</span><span class="p">;</span>

<span class="n">mat</span><span class="o">.</span><span class="n">ZeroBlockPermutation</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">zbp</span><span class="p">);</span>
<span class="n">mat</span><span class="o">.</span><span class="n">Permute</span><span class="p">(</span><span class="n">zbp</span><span class="p">);</span>
</pre></div>
</div>
 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: </li>
<li><code class="docutils literal notranslate"><span class="pre">permutation</span></code>: permutation vector for zero block permutation</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="connectivity-ordering">
<h4>Connectivity Ordering<a class="headerlink" href="#connectivity-ordering" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="_CPPv3NK10rocalution11LocalMatrix17ConnectivityOrderEP11LocalVectorIiE">
<span id="_CPPv2NK10rocalution11LocalMatrix17ConnectivityOrderEP11LocalVectorIiE"></span><span id="rocalution::LocalMatrix::ConnectivityOrder__LocalVector:i:PC"></span><span class="target" id="classrocalution_1_1_local_matrix_1a433a6b2f5e09f3260b269776e8322a4f"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a><code class="descclassname">::</code></code><code class="descname">ConnectivityOrder</code><span class="sig-paren">(</span><a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVectorE" title="rocalution::LocalVector">LocalVector</a>&lt;int&gt; *<em>permutation</em><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>Create permutation vector for connectivity reordering of the matrix. </p>
<p>Connectivity ordering returns a permutation, that sorts the matrix by non-zero entries per row.</p>
<p><dl class="docutils">
<dt><strong>Example</strong></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LocalVector</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span> <span class="n">conn</span><span class="p">;</span>

<span class="n">mat</span><span class="o">.</span><span class="n">ConnectivityOrder</span><span class="p">(</span><span class="o">&amp;</span><span class="n">conn</span><span class="p">);</span>
<span class="n">mat</span><span class="o">.</span><span class="n">Permute</span><span class="p">(</span><span class="n">conn</span><span class="p">);</span>
</pre></div>
</div>
 </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">permutation</span></code>: permutation vector for connectivity reordering</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</div>
<div class="section" id="basic-linear-algebra-operations">
<h3>Basic Linear Algebra Operations<a class="headerlink" href="#basic-linear-algebra-operations" title="Permalink to this headline">¶</a></h3>
<p>For a full list of functions and routines involving operators and vectors, see the API specifications.</p>
</div>
</div>
<div class="section" id="multi-node-computation">
<h2>Multi-node Computation<a class="headerlink" href="#multi-node-computation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id13">
<h3>Introduction<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<p>This chapter describes all base objects (matrices and vectors) for computation on multi-node (distributed memory) systems.</p>
<img alt="multi-node system configuration" class="align-center" id="multi-node1" src="_images/multi-node1.png" />
<p><strong>An example for a multi-node configuration, where all nodes are connected via network. Single socket systems with a single accelerator</strong></p>
<img alt="multi-node system configuration" class="align-center" src="_images/multi-node2.png" />
<p><strong>An example for a multi-node configuration, where all nodes are connected via network. Dual socket systems with two accelerators attached to each node</strong></p>
<p>To each compute node, one or more accelerators can be attached. The compute node could be any kind of shared-memory (single, dual, quad CPU) system, details on a single-node can be found in <code class="xref std std-numref docutils literal notranslate"><span class="pre">single-node</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The memory of accelerator and host are physically different. All nodes can communicate with each other via network.</p>
</div>
<p>For the communication channel between different nodes (and between the accelerators on single or multiple nodes) the MPI library is used.</p>
<p>rocALUTION supports non-overlapping type of distribution, where the computational domain is split into several sub-domain with the corresponding information about the boundary and ghost layers. An example is shown in <code class="xref std std-numref docutils literal notranslate"><span class="pre">domain1</span></code>. The square box domain is distributed into four sub-domains. Each subdomain belongs to a process <em>P0</em>, <em>P1</em>, <em>P2</em> and <em>P3</em>.</p>
<img alt="domain distribution" class="align-center" id="domain1" src="_images/domain1.png" />
<p><strong>An example for domain distribution</strong></p>
<p>To perform a sparse matrix-vector multiplication (SpMV), each process need to multiply its own portion of the domain and update the corresponding ghost elements. For <em>P0</em>, this multiplication reads</p>
<div class="math notranslate nohighlight">
\[\begin{split}Ax = y, \\
A_I x_I + A_G x_G = y_I,\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(I\)</span> stands for interior and <span class="math notranslate nohighlight">\(G\)</span> stands for ghost. <span class="math notranslate nohighlight">\(x_G\)</span> is a vector with three sections, coming from <em>P1</em>, <em>P2</em> and <em>P3</em>. The whole ghost part of the global vector is used mainly for the SpMV product. It does not play any role in the computation of vector-vector operations.</p>
</div>
<div class="section" id="id14">
<h3>Code Structure<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<p>Each object contains two local sub-objects. The global matrix stores interior and ghost matrix by local objects. Similarily, the global vector stores its data by two local objects. In addition to the local data, the global objects have information about the global communication through the parallel manager.</p>
<img alt="global matrices and vectors" class="align-center" id="global-objects" src="_images/global_objects.png" />
<p><strong>Global matrices and vectors</strong></p>
</div>
<div class="section" id="parallel-manager">
<h3>Parallel Manager<a class="headerlink" href="#parallel-manager" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv3N10rocalution15ParallelManagerE">
<span id="_CPPv2N10rocalution15ParallelManagerE"></span><span id="rocalution::ParallelManager"></span><span class="target" id="classrocalution_1_1_parallel_manager"></span><em class="property">class </em><code class="descname">ParallelManager</code> : <em class="property">public</em> rocalution::RocalutionObj<br /></dt>
<dd><p>Parallel Manager class. </p>
<p>The parallel manager class handles the communication and the mapping of the global operators. Each global operator and vector need to be initialized with a valid parallel manager in order to perform any operation. For many distributed simulations, the underlying operator is already distributed. This information need to be passed to the parallel manager. </p>
</dd></dl>

<p>The parallel manager class hosts the following functions:</p>
<dl class="function">
<dt id="_CPPv3N10rocalution15ParallelManager18SetMPICommunicatorEPKv">
<span id="_CPPv2N10rocalution15ParallelManager18SetMPICommunicatorEPKv"></span><span id="rocalution::ParallelManager::SetMPICommunicator__voidCP"></span><span class="target" id="classrocalution_1_1_parallel_manager_1aefdb9831f66c0ca18532e47b2c5246a4"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution15ParallelManagerE" title="rocalution::ParallelManager">ParallelManager</a><code class="descclassname">::</code></code><code class="descname">SetMPICommunicator</code><span class="sig-paren">(</span><em class="property">const</em> void *<em>comm</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the MPI communicator. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution15ParallelManager5ClearEv">
<span id="_CPPv2N10rocalution15ParallelManager5ClearEv"></span><span id="rocalution::ParallelManager::Clear__void"></span><span class="target" id="classrocalution_1_1_parallel_manager_1a8a0136bfba7b4cee5d17b1f1e1aab580"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution15ParallelManagerE" title="rocalution::ParallelManager">ParallelManager</a><code class="descclassname">::</code></code><code class="descname">Clear</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Clear all allocated resources. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK10rocalution15ParallelManager13GetGlobalSizeEv">
<span id="_CPPv2NK10rocalution15ParallelManager13GetGlobalSizeEv"></span><span id="rocalution::ParallelManager::GetGlobalSize__voidC"></span><span class="target" id="classrocalution_1_1_parallel_manager_1a686ba88f36cbfb8537e40270a57a9f60"></span>IndexType2 <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution15ParallelManagerE" title="rocalution::ParallelManager">ParallelManager</a><code class="descclassname">::</code></code><code class="descname">GetGlobalSize</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>Return the global size. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK10rocalution15ParallelManager12GetLocalSizeEv">
<span id="_CPPv2NK10rocalution15ParallelManager12GetLocalSizeEv"></span><span id="rocalution::ParallelManager::GetLocalSize__voidC"></span><span class="target" id="classrocalution_1_1_parallel_manager_1a5ab207c389a3342e8a9d4bccd6df0a27"></span>int <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution15ParallelManagerE" title="rocalution::ParallelManager">ParallelManager</a><code class="descclassname">::</code></code><code class="descname">GetLocalSize</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>Return the local size. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK10rocalution15ParallelManager15GetNumReceiversEv">
<span id="_CPPv2NK10rocalution15ParallelManager15GetNumReceiversEv"></span><span id="rocalution::ParallelManager::GetNumReceivers__voidC"></span><span class="target" id="classrocalution_1_1_parallel_manager_1a601ceb971f16e0f44351f0953bd403c5"></span>int <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution15ParallelManagerE" title="rocalution::ParallelManager">ParallelManager</a><code class="descclassname">::</code></code><code class="descname">GetNumReceivers</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>Return the number of receivers. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK10rocalution15ParallelManager13GetNumSendersEv">
<span id="_CPPv2NK10rocalution15ParallelManager13GetNumSendersEv"></span><span id="rocalution::ParallelManager::GetNumSenders__voidC"></span><span class="target" id="classrocalution_1_1_parallel_manager_1a79f4ba4c2f552fbb5355bca1e11858ca"></span>int <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution15ParallelManagerE" title="rocalution::ParallelManager">ParallelManager</a><code class="descclassname">::</code></code><code class="descname">GetNumSenders</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>Return the number of senders. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK10rocalution15ParallelManager11GetNumProcsEv">
<span id="_CPPv2NK10rocalution15ParallelManager11GetNumProcsEv"></span><span id="rocalution::ParallelManager::GetNumProcs__voidC"></span><span class="target" id="classrocalution_1_1_parallel_manager_1a504931964a2b65a5cac1f7acc08bd5b1"></span>int <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution15ParallelManagerE" title="rocalution::ParallelManager">ParallelManager</a><code class="descclassname">::</code></code><code class="descname">GetNumProcs</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>Return the number of involved processes. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution15ParallelManager13SetGlobalSizeE10IndexType2">
<span id="_CPPv2N10rocalution15ParallelManager13SetGlobalSizeE10IndexType2"></span><span id="rocalution::ParallelManager::SetGlobalSize__IndexType2"></span><span class="target" id="classrocalution_1_1_parallel_manager_1ab0e344d56f2b46daef9e26c81468803e"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution15ParallelManagerE" title="rocalution::ParallelManager">ParallelManager</a><code class="descclassname">::</code></code><code class="descname">SetGlobalSize</code><span class="sig-paren">(</span>IndexType2 <em>size</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize the global size. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution15ParallelManager12SetLocalSizeEi">
<span id="_CPPv2N10rocalution15ParallelManager12SetLocalSizeEi"></span><span id="rocalution::ParallelManager::SetLocalSize__i"></span><span class="target" id="classrocalution_1_1_parallel_manager_1acb4593542cf35bb0ae204431cc0512de"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution15ParallelManagerE" title="rocalution::ParallelManager">ParallelManager</a><code class="descclassname">::</code></code><code class="descname">SetLocalSize</code><span class="sig-paren">(</span>int <em>size</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize the local size. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution15ParallelManager16SetBoundaryIndexEiPKi">
<span id="_CPPv2N10rocalution15ParallelManager16SetBoundaryIndexEiPKi"></span><span id="rocalution::ParallelManager::SetBoundaryIndex__i.iCP"></span><span class="target" id="classrocalution_1_1_parallel_manager_1a9482ad4c25b1594393cb8d85a9bb71e7"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution15ParallelManagerE" title="rocalution::ParallelManager">ParallelManager</a><code class="descclassname">::</code></code><code class="descname">SetBoundaryIndex</code><span class="sig-paren">(</span>int <em>size</em>, <em class="property">const</em> int *<em>index</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set all boundary indices of this ranks process. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution15ParallelManager12SetReceiversEiPKiPKi">
<span id="_CPPv2N10rocalution15ParallelManager12SetReceiversEiPKiPKi"></span><span id="rocalution::ParallelManager::SetReceivers__i.iCP.iCP"></span><span class="target" id="classrocalution_1_1_parallel_manager_1a0fc6bd3785eb225288323b8ab688b945"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution15ParallelManagerE" title="rocalution::ParallelManager">ParallelManager</a><code class="descclassname">::</code></code><code class="descname">SetReceivers</code><span class="sig-paren">(</span>int <em>nrecv</em>, <em class="property">const</em> int *<em>recvs</em>, <em class="property">const</em> int *<em>recv_offset</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Number of processes, the current process is receiving data from, array of the processes, the current process is receiving data from and offsets, where the boundary for process ‘receiver’ starts. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution15ParallelManager10SetSendersEiPKiPKi">
<span id="_CPPv2N10rocalution15ParallelManager10SetSendersEiPKiPKi"></span><span id="rocalution::ParallelManager::SetSenders__i.iCP.iCP"></span><span class="target" id="classrocalution_1_1_parallel_manager_1abcf826d069bc9006fea0a2da87cc4165"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution15ParallelManagerE" title="rocalution::ParallelManager">ParallelManager</a><code class="descclassname">::</code></code><code class="descname">SetSenders</code><span class="sig-paren">(</span>int <em>nsend</em>, <em class="property">const</em> int *<em>sends</em>, <em class="property">const</em> int *<em>send_offset</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Number of processes, the current process is sending data to, array of the processes, the current process is sending data to and offsets where the ghost part for process ‘sender’ starts. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution15ParallelManager13ReadFileASCIIEKNSt6stringE">
<span id="_CPPv2N10rocalution15ParallelManager13ReadFileASCIIEKNSt6stringE"></span><span id="rocalution::ParallelManager::ReadFileASCII__ssC"></span><span class="target" id="classrocalution_1_1_parallel_manager_1a159317f7d0b72501de8c452ad07286e3"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution15ParallelManagerE" title="rocalution::ParallelManager">ParallelManager</a><code class="descclassname">::</code></code><code class="descname">ReadFileASCII</code><span class="sig-paren">(</span><em class="property">const</em> std::string <em>filename</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Read file that contains all relevant parallel manager data. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK10rocalution15ParallelManager14WriteFileASCIIEKNSt6stringE">
<span id="_CPPv2NK10rocalution15ParallelManager14WriteFileASCIIEKNSt6stringE"></span><span id="rocalution::ParallelManager::WriteFileASCII__ssCC"></span><span class="target" id="classrocalution_1_1_parallel_manager_1af0b697c6a34544b3091c909def74eb9c"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution15ParallelManagerE" title="rocalution::ParallelManager">ParallelManager</a><code class="descclassname">::</code></code><code class="descname">WriteFileASCII</code><span class="sig-paren">(</span><em class="property">const</em> std::string <em>filename</em><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>Write file that contains all relevant parallel manager data. </p>
</dd></dl>

<p>To setup a parallel manager, the required information is:</p>
<ul class="simple">
<li>Global size</li>
<li>Local size of the interior/ghost for each process</li>
<li>Communication pattern (what information need to be sent to whom)</li>
</ul>
</div>
<div class="section" id="global-matrices-and-vectors">
<h3>Global Matrices and Vectors<a class="headerlink" href="#global-matrices-and-vectors" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="_CPPv3NK10rocalution12GlobalMatrix11GetInteriorEv">
<span id="_CPPv2NK10rocalution12GlobalMatrix11GetInteriorEv"></span><span id="rocalution::GlobalMatrix::GetInteriorC"></span><span class="target" id="classrocalution_1_1_global_matrix_1a06388f5fee7036aafbc89c5e3cccad8d"></span><em class="property">const</em> <a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a>&lt;ValueType&gt; &amp;<code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution12GlobalMatrixE" title="rocalution::GlobalMatrix">GlobalMatrix</a><code class="descclassname">::</code></code><code class="descname">GetInterior</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK10rocalution12GlobalMatrix11GetInteriorEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3NK10rocalution12GlobalMatrix8GetGhostEv">
<span id="_CPPv2NK10rocalution12GlobalMatrix8GetGhostEv"></span><span id="rocalution::GlobalMatrix::GetGhostC"></span><span class="target" id="classrocalution_1_1_global_matrix_1a288b50d8be6f7e8673a6847cf8505b8f"></span><em class="property">const</em> <a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a>&lt;ValueType&gt; &amp;<code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution12GlobalMatrixE" title="rocalution::GlobalMatrix">GlobalMatrix</a><code class="descclassname">::</code></code><code class="descname">GetGhost</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK10rocalution12GlobalMatrix8GetGhostEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution12GlobalVector11GetInteriorEv">
<span id="_CPPv2N10rocalution12GlobalVector11GetInteriorEv"></span><span id="rocalution::GlobalVector::GetInterior"></span><span class="target" id="classrocalution_1_1_global_vector_1a2975c1146ee59b3f742e59413991b453"></span><a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVectorE" title="rocalution::LocalVector">LocalVector</a>&lt;ValueType&gt; &amp;<code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution12GlobalVectorE" title="rocalution::GlobalVector">GlobalVector</a><code class="descclassname">::</code></code><code class="descname">GetInterior</code><span class="sig-paren">(</span><span class="sig-paren">)</span><br /></dt>
<dd></dd></dl>

<p>The global matrices and vectors store their data via two local objects. For the global matrix, the interior can be access via the <a class="reference internal" href="#_CPPv3NK10rocalution12GlobalMatrix11GetInteriorEv" title="rocalution::GlobalMatrix::GetInterior"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::GlobalMatrix::GetInterior()</span></code></a> and <a class="reference internal" href="#_CPPv3NK10rocalution12GlobalMatrix8GetGhostEv" title="rocalution::GlobalMatrix::GetGhost"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::GlobalMatrix::GetGhost()</span></code></a> functions, which point to two valid local matrices. Similarily, the global vector can be accessed by <a class="reference internal" href="#_CPPv3NK10rocalution12GlobalVector11GetInteriorEv" title="rocalution::GlobalVector::GetInterior"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::GlobalVector::GetInterior()</span></code></a>.</p>
<div class="section" id="asynchronous-spmv">
<h4>Asynchronous SpMV<a class="headerlink" href="#asynchronous-spmv" title="Permalink to this headline">¶</a></h4>
<p>To minimize latency and to increase scalability, rocALUTION supports asynchronous sparse matrix-vector multiplication. The implementation of the SpMV starts with asynchronous transfer of the required ghost buffers, while at the same time it computes the interior matrix-vector product. When the computation of the interior SpMV is done, the ghost transfer is synchronized and the ghost SpMV is performed. To minimize the PCI-E bus, the HIP implementation provides a special packaging technique for transferring all ghost data into a contiguous memory buffer.</p>
</div>
</div>
<div class="section" id="id15">
<h3>File I/O<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<p>The user can store and load all global structures from and to files. For a solver, the necessary data would be</p>
<ul class="simple">
<li>the parallel manager</li>
<li>the sparse matrix</li>
<li>and the vector</li>
</ul>
<p>Reading/writing from/to files can be done fully in parallel without any communication. <code class="xref std std-numref docutils literal notranslate"><span class="pre">4x4_mpi</span></code> visualizes data of a <span class="math notranslate nohighlight">\(4 \times 4\)</span> grid example which is distributed among 4 MPI processes (organized in <span class="math notranslate nohighlight">\(2 \times 2\)</span>). Each local matrix stores the local unknowns (with local indexing). <code class="xref std std-numref docutils literal notranslate"><span class="pre">4x4_mpi_rank0</span></code> furthermore illustrates the data associated with <em>RANK0</em>.</p>
<img alt="4x4 grid, distributed in 4 domains (2x2)" class="align-center" id="x4-mpi" src="_images/4x4_mpi.png" />
<p><strong>An example of :math:`4 times 4` grid, distributed in 4 domains (:math:`2 times 2`)</strong></p>
<img alt="4x4 grid, distributed in 4 domains (2x2), showing rank0" class="align-center" id="x4-mpi-rank0" src="_images/4x4_mpi_rank0.png" />
<p><strong>An example of 4 MPI processes and the data associated with *RANK0</strong></p>
<div class="section" id="file-organization">
<h4>File Organization<a class="headerlink" href="#file-organization" title="Permalink to this headline">¶</a></h4>
<p>When the parallel manager, global matrix or global vector are writing to a file, the main file (passed as a file name to this function) will contain information for all files on all ranks.</p>
<div class="highlight-RST notranslate"><div class="highlight"><pre><span></span>parallelmanager.dat.rank.0
parallelmanager.dat.rank.1
parallelmanager.dat.rank.2
parallelmanager.dat.rank.3
</pre></div>
</div>
<div class="highlight-RST notranslate"><div class="highlight"><pre><span></span>matrix.mtx.interior.rank.0
matrix.mtx.ghost.rank.0
matrix.mtx.interior.rank.1
matrix.mtx.ghost.rank.1
matrix.mtx.interior.rank.2
matrix.mtx.ghost.rank.2
matrix.mtx.interior.rank.3
matrix.mtx.ghost.rank.3
</pre></div>
</div>
<div class="highlight-RST notranslate"><div class="highlight"><pre><span></span>rhs.dat.rank.0
rhs.dat.rank.1
rhs.dat.rank.2
rhs.dat.rank.3
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h4>Parallel Manager<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h4>
<p>The data for each rank can be split into receiving and sending information. For receiving data from neighboring processes, see <code class="xref std std-numref docutils literal notranslate"><span class="pre">receiving</span></code>, <em>RANK0</em> need to know what type of data will be received and from whom. For sending data to neighboring processes, see <code class="xref std std-numref docutils literal notranslate"><span class="pre">sending</span></code>, <em>RANK0</em> need to know where and what to send.</p>
<img alt="receiving data example" class="align-center" id="receiving" src="_images/receiving.png" />
<p><strong>An example of 4 MPI processes, *RANK0* receives data (the associated data is marked bold)</strong></p>
<p>To receive data, <em>RANK0</em> requires:</p>
<ul class="simple">
<li>Number of MPI ranks, which will send data to <em>RANK0</em> (NUMBER_OF_RECEIVERS - integer value).</li>
<li>Which are the MPI ranks, sending the data (RECEIVERS_RANK - integer array).</li>
<li>How will the received data (from each rank) be stored in the ghost vector (RECEIVERS_INDEX_OFFSET - integer array). In this example, the first 30 elements will be received from <em>P1</em> <span class="math notranslate nohighlight">\([0, 2)\)</span> and the second 30 from <em>P2</em> <span class="math notranslate nohighlight">\([2, 4)\)</span>.</li>
</ul>
<img alt="sending data example" class="align-center" id="sending" src="_images/sending.png" />
<p><strong>An example of 4 MPI processes, *RANK0* sends data (the associated data is marked bold)</strong></p>
<p>To send data, <em>RANK0</em> requires:</p>
<ul class="simple">
<li>Total size of the sending information (BOUNDARY_SIZE - integer value).</li>
<li>Number of MPI ranks, which will receive data from <em>RANK0</em> (NUMBER_OF_SENDERS - integer value).</li>
<li>Which are the MPI ranks, receiving the data (SENDERS_RANK - integer array).</li>
<li>How will the sending data (from each rank) be stored in the sending buffer (SENDERS_INDEX_OFFSET - integer array). In this example, the first 30 elements will be sent to <em>P1</em> <span class="math notranslate nohighlight">\([0, 2)\)</span> and the second 30 to <em>P2</em> <span class="math notranslate nohighlight">\([2, 4)\)</span>.</li>
<li>The elements, which need to be send (BOUNDARY_INDEX - integer array). In this example, the data which need to be send to <em>P1</em> and <em>P2</em> is the ghost layer, marked as ghost <em>P0</em>. The vertical stripe need to be send to <em>P1</em> and the horizontal stripe to <em>P2</em>. The numbering of local unknowns (in local indexing) for <em>P1</em> (the vertical stripes) are 1, 2 (size of 2) and stored in the BOUNDARY_INDEX. After 2 elements, the elements for <em>P2</em> are stored, they are 2, 3 (2 elements).</li>
</ul>
</div>
<div class="section" id="matrices">
<h4>Matrices<a class="headerlink" href="#matrices" title="Permalink to this headline">¶</a></h4>
<p>Each rank hosts two local matrices, interior and ghost matrix. They can be stored in separate files, one for each matrix. The file format could be Matrix Market (MTX) or binary.</p>
</div>
<div class="section" id="vectors">
<h4>Vectors<a class="headerlink" href="#vectors" title="Permalink to this headline">¶</a></h4>
<p>Each rank holds the local interior vector only. It is stored in a single file. The file could be ASCII or binary.</p>
</div>
</div>
</div>
<div class="section" id="solvers">
<h2>Solvers<a class="headerlink" href="#solvers" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id17">
<h3>Code Structure<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv3N10rocalution6SolverE">
<span id="_CPPv2N10rocalution6SolverE"></span><span id="rocalution::Solver"></span><span class="target" id="classrocalution_1_1_solver"></span><em class="property">template </em>&lt;class <em>OperatorType</em>, class <em>VectorType</em>, typename <em>ValueType</em>&gt;<br /><em class="property">class </em><code class="descname">Solver</code> : <em class="property">public</em> rocalution::RocalutionObj<br /></dt>
<dd><p>Base class for all solvers and preconditioners. </p>
<p>Most of the solvers can be performed on linear operators <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a>, <a class="reference internal" href="#classrocalution_1_1_local_stencil"><span class="std std-ref">LocalStencil</span></a> and <a class="reference internal" href="#classrocalution_1_1_global_matrix"><span class="std std-ref">GlobalMatrix</span></a> - i.e. the solvers can be performed locally (on a shared memory system) or in a distributed manner (on a cluster) via MPI. The only exception is the AMG (Algebraic Multigrid) solver which has two versions (one for <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> and one for <a class="reference internal" href="#classrocalution_1_1_global_matrix"><span class="std std-ref">GlobalMatrix</span></a> class). The only pure local solvers (which do not support global/MPI operations) are the mixed-precision defect-correction solver and all direct solvers.</p>
<p>All solvers need three template parameters - Operators, Vectors and Scalar type.</p>
<p>The <a class="reference internal" href="#classrocalution_1_1_solver"><span class="std std-ref">Solver</span></a> class is purely virtual and provides an interface for<ul class="simple">
<li><a class="reference internal" href="#classrocalution_1_1_solver_1a12765b63efe75bc88406a8d6ebb5aacc"><span class="std std-ref">SetOperator()</span></a> to set the operator <span class="math notranslate nohighlight">\(A\)</span>, i.e. the user can pass the matrix here.</li>
<li><a class="reference internal" href="#classrocalution_1_1_solver_1a84754d7422ad3fb35c17c61f0a609c7a"><span class="std std-ref">Build()</span></a> to build the solver (including preconditioners, sub-solvers, etc.). The user need to specify the operator first before calling <a class="reference internal" href="#classrocalution_1_1_solver_1a84754d7422ad3fb35c17c61f0a609c7a"><span class="std std-ref">Build()</span></a>.</li>
<li><a class="reference internal" href="#classrocalution_1_1_solver_1a69025eb1d2bc7f1266899c2739c82725"><span class="std std-ref">Solve()</span></a> to solve the system <span class="math notranslate nohighlight">\(Ax = b\)</span>. The user need to pass a right-hand-side <span class="math notranslate nohighlight">\(b\)</span> and a vector <span class="math notranslate nohighlight">\(x\)</span>, where the solution will be obtained.</li>
<li><a class="reference internal" href="#classrocalution_1_1_solver_1a57992cfc687f3bf260964ad2fc19c467"><span class="std std-ref">Print()</span></a> to show solver information.</li>
<li><a class="reference internal" href="#classrocalution_1_1_solver_1acd20a051f0560a77645e35361df8f87c"><span class="std std-ref">ReBuildNumeric()</span></a> to only re-build the solver numerically (if possible).</li>
<li><a class="reference internal" href="#classrocalution_1_1_solver_1a3c263e65898816f5838184c0af78a044"><span class="std std-ref">MoveToHost()</span></a> and <a class="reference internal" href="#classrocalution_1_1_solver_1ab1b6410cd134c9ad00c1851d400cf0f8"><span class="std std-ref">MoveToAccelerator()</span></a> to offload the solver (including preconditioners and sub-solvers) to the host/accelerator.</li>
</ul>
</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a>, <a class="reference internal" href="#classrocalution_1_1_global_matrix"><span class="std std-ref">GlobalMatrix</span></a> or <a class="reference internal" href="#classrocalution_1_1_local_stencil"><span class="std std-ref">LocalStencil</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> or <a class="reference internal" href="#classrocalution_1_1_global_vector"><span class="std std-ref">GlobalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
<p>Subclassed by <a class="reference internal" href="#classrocalution_1_1_direct_linear_solver"><span class="std std-ref">rocalution::DirectLinearSolver&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_iterative_linear_solver"><span class="std std-ref">rocalution::IterativeLinearSolver&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_preconditioner"><span class="std std-ref">rocalution::Preconditioner&lt; OperatorType, VectorType, ValueType &gt;</span></a></p>
</dd></dl>

<p>It provides an interface for</p>
<dl class="function">
<dt id="_CPPv3N10rocalution6Solver11SetOperatorERK12OperatorType">
<span id="_CPPv2N10rocalution6Solver11SetOperatorERK12OperatorType"></span><span id="rocalution::Solver::SetOperator__OperatorTypeCR"></span><span class="target" id="classrocalution_1_1_solver_1a12765b63efe75bc88406a8d6ebb5aacc"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution6SolverE" title="rocalution::Solver">Solver</a><code class="descclassname">::</code></code><code class="descname">SetOperator</code><span class="sig-paren">(</span><em class="property">const</em> OperatorType &amp;<em>op</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the <a class="reference internal" href="api.html#classrocalution_1_1_operator"><span class="std std-ref">Operator</span></a> of the solver. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution6Solver5BuildEv">
<span id="_CPPv2N10rocalution6Solver5BuildEv"></span><span id="rocalution::Solver::Build__void"></span><span class="target" id="classrocalution_1_1_solver_1a84754d7422ad3fb35c17c61f0a609c7a"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution6SolverE" title="rocalution::Solver">Solver</a><code class="descclassname">::</code></code><code class="descname">Build</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Build the solver (data allocation, structure and numerical computation) </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution6Solver5ClearEv">
<span id="_CPPv2N10rocalution6Solver5ClearEv"></span><span id="rocalution::Solver::Clear__void"></span><span class="target" id="classrocalution_1_1_solver_1aa8839d3ba527d75fedd29fdbe9bd651f"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution6SolverE" title="rocalution::Solver">Solver</a><code class="descclassname">::</code></code><code class="descname">Clear</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Clear (free all local data) the solver. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution6Solver5SolveERK10VectorTypeP10VectorType">
<span id="_CPPv2N10rocalution6Solver5SolveERK10VectorTypeP10VectorType"></span><span id="rocalution::Solver::Solve__VectorTypeCR.VectorTypeP"></span><span class="target" id="classrocalution_1_1_solver_1a69025eb1d2bc7f1266899c2739c82725"></span><em class="property">virtual</em> void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution6SolverE" title="rocalution::Solver">Solver</a><code class="descclassname">::</code></code><code class="descname">Solve</code><span class="sig-paren">(</span><em class="property">const</em> VectorType &amp;<em>rhs</em>, VectorType *<em>x</em><span class="sig-paren">)</span> = 0<br /></dt>
<dd><p>Solve <a class="reference internal" href="api.html#classrocalution_1_1_operator"><span class="std std-ref">Operator</span></a> x = rhs. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK10rocalution6Solver5PrintEv">
<span id="_CPPv2NK10rocalution6Solver5PrintEv"></span><span id="rocalution::Solver::Print__voidC"></span><span class="target" id="classrocalution_1_1_solver_1a57992cfc687f3bf260964ad2fc19c467"></span><em class="property">virtual</em> void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution6SolverE" title="rocalution::Solver">Solver</a><code class="descclassname">::</code></code><code class="descname">Print</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span> <em class="property">const</em> = 0<br /></dt>
<dd><p>Print information about the solver. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution6Solver14ReBuildNumericEv">
<span id="_CPPv2N10rocalution6Solver14ReBuildNumericEv"></span><span id="rocalution::Solver::ReBuildNumeric__void"></span><span class="target" id="classrocalution_1_1_solver_1acd20a051f0560a77645e35361df8f87c"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution6SolverE" title="rocalution::Solver">Solver</a><code class="descclassname">::</code></code><code class="descname">ReBuildNumeric</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Rebuild the solver only with numerical computation (no allocation or data structure computation) </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution6Solver10MoveToHostEv">
<span id="_CPPv2N10rocalution6Solver10MoveToHostEv"></span><span id="rocalution::Solver::MoveToHost__void"></span><span class="target" id="classrocalution_1_1_solver_1a3c263e65898816f5838184c0af78a044"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution6SolverE" title="rocalution::Solver">Solver</a><code class="descclassname">::</code></code><code class="descname">MoveToHost</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Move all data (i.e. </p>
<p>move the solver) to the host </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution6Solver17MoveToAcceleratorEv">
<span id="_CPPv2N10rocalution6Solver17MoveToAcceleratorEv"></span><span id="rocalution::Solver::MoveToAccelerator__void"></span><span class="target" id="classrocalution_1_1_solver_1ab1b6410cd134c9ad00c1851d400cf0f8"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution6SolverE" title="rocalution::Solver">Solver</a><code class="descclassname">::</code></code><code class="descname">MoveToAccelerator</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Move all data (i.e. </p>
<p>move the solver) to the accelerator </p>
</dd></dl>

</div>
<div class="section" id="iterative-linear-solvers">
<h3>Iterative Linear Solvers<a class="headerlink" href="#iterative-linear-solvers" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv3N10rocalution21IterativeLinearSolverE">
<span id="_CPPv2N10rocalution21IterativeLinearSolverE"></span><span id="rocalution::IterativeLinearSolver"></span><span class="target" id="classrocalution_1_1_iterative_linear_solver"></span><em class="property">template </em>&lt;class <em>OperatorType</em>, class <em>VectorType</em>, typename <em>ValueType</em>&gt;<br /><em class="property">class </em><code class="descname">IterativeLinearSolver</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution6SolverE" title="rocalution::Solver">Solver</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Base class for all linear iterative solvers. </p>
<p>The iterative solvers are controlled by an iteration control object, which monitors the convergence properties of the solver, i.e. maximum number of iteration, relative tolerance, absolute tolerance and divergence tolerance. The iteration control can also record the residual history and store it in an ASCII file.<ul class="simple">
<li><a class="reference internal" href="#classrocalution_1_1_iterative_linear_solver_1a2a8eebb0b187469ed92c675bd75e34b8"><span class="std std-ref">Init()</span></a>, <a class="reference internal" href="#classrocalution_1_1_iterative_linear_solver_1a025c99dd56f7b09ebfd9df3905093c8e"><span class="std std-ref">InitMinIter()</span></a>, <a class="reference internal" href="#classrocalution_1_1_iterative_linear_solver_1a3b248faab2ff42e9106b6e38e5e0bbe2"><span class="std std-ref">InitMaxIter()</span></a> and <a class="reference internal" href="#classrocalution_1_1_iterative_linear_solver_1a05b570833a869738be46986d255b3c39"><span class="std std-ref">InitTol()</span></a> initialize the solver and set the stopping criteria.</li>
<li><a class="reference internal" href="#classrocalution_1_1_iterative_linear_solver_1a0a5fd39c7f75f4339eaa41b67868653d"><span class="std std-ref">RecordResidualHistory()</span></a> and <a class="reference internal" href="#classrocalution_1_1_iterative_linear_solver_1ae13555f823f7cd1a5c3a7ef3b4427f74"><span class="std std-ref">RecordHistory()</span></a> start the recording of the residual and write it into a file.</li>
<li><a class="reference internal" href="#classrocalution_1_1_iterative_linear_solver_1ac88dc520e41c9d1a2de5ad8c95e644c2"><span class="std std-ref">Verbose()</span></a> sets the level of verbose output of the solver (0 - no output, 2 - detailed output, including residual and iteration information).</li>
<li><a class="reference internal" href="#classrocalution_1_1_iterative_linear_solver_1ac40a58d97330f7bf41d2ae116bc45f80"><span class="std std-ref">SetPreconditioner()</span></a> sets the preconditioning.</li>
</ul>
</p>
<p>All iterative solvers are controlled based on<ul class="simple">
<li>Absolute stopping criteria, when <span class="math notranslate nohighlight">\(|r_{k}|_{L_{p}} \lt \epsilon_{abs}\)</span></li>
<li>Relative stopping criteria, when <span class="math notranslate nohighlight">\(|r_{k}|_{L_{p}} / |r_{1}|_{L_{p}} \leq \epsilon_{rel}\)</span></li>
<li>Divergence stopping criteria, when <span class="math notranslate nohighlight">\(|r_{k}|_{L_{p}} / |r_{1}|_{L_{p}} \geq \epsilon_{div}\)</span></li>
<li>Maximum number of iteration <span class="math notranslate nohighlight">\(N\)</span>, when <span class="math notranslate nohighlight">\(k = N\)</span></li>
</ul>
</p>
<p>where <span class="math notranslate nohighlight">\(k\)</span> is the current iteration, <span class="math notranslate nohighlight">\(r_{k}\)</span> the residual for the current iteration <span class="math notranslate nohighlight">\(k\)</span> (i.e. <span class="math notranslate nohighlight">\(r_{k} = b - Ax_{k}\)</span>) and <span class="math notranslate nohighlight">\(r_{1}\)</span> the starting residual (i.e. <span class="math notranslate nohighlight">\(r_{1} = b - Ax_{init}\)</span>). In addition, the minimum number of iterations <span class="math notranslate nohighlight">\(M\)</span> can be specified. In this case, the solver will not stop to iterate, before <span class="math notranslate nohighlight">\(k \geq M\)</span>.</p>
<p>The <span class="math notranslate nohighlight">\(L_{p}\)</span> norm is used for the computation, where <span class="math notranslate nohighlight">\(p\)</span> could be 1, 2 and <span class="math notranslate nohighlight">\(\infty\)</span>. The norm computation can be set with <a class="reference internal" href="#classrocalution_1_1_iterative_linear_solver_1a9a7610d7c31f7259f4365d79187cfa78"><span class="std std-ref">SetResidualNorm()</span></a> with 1 for <span class="math notranslate nohighlight">\(L_{1}\)</span>, 2 for <span class="math notranslate nohighlight">\(L_{2}\)</span> and 3 for <span class="math notranslate nohighlight">\(L_{\infty}\)</span>. For the computation with <span class="math notranslate nohighlight">\(L_{\infty}\)</span>, the index of the maximum value can be obtained with <a class="reference internal" href="#classrocalution_1_1_iterative_linear_solver_1a20f2516ef96cebecbe83ba153bfacc8e"><span class="std std-ref">GetAmaxResidualIndex()</span></a>. If this function is called and <span class="math notranslate nohighlight">\(L_{\infty}\)</span> was not selected, this function will return -1.</p>
<p>The reached criteria can be obtained with <a class="reference internal" href="#classrocalution_1_1_iterative_linear_solver_1a814064201608ca980284fbea51792137"><span class="std std-ref">GetSolverStatus()</span></a>, returning<ul class="simple">
<li>0, if no criteria has been reached yet</li>
<li>1, if absolute tolerance has been reached</li>
<li>2, if relative tolerance has been reached</li>
<li>3, if divergence tolerance has been reached</li>
<li>4, if maximum number of iteration has been reached</li>
</ul>
</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a>, <a class="reference internal" href="#classrocalution_1_1_global_matrix"><span class="std std-ref">GlobalMatrix</span></a> or <a class="reference internal" href="#classrocalution_1_1_local_stencil"><span class="std std-ref">LocalStencil</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> or <a class="reference internal" href="#classrocalution_1_1_global_vector"><span class="std std-ref">GlobalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
<p>Subclassed by <a class="reference internal" href="#classrocalution_1_1_base_multi_grid"><span class="std std-ref">rocalution::BaseMultiGrid&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_bi_c_g_stab"><span class="std std-ref">rocalution::BiCGStab&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_bi_c_g_stabl"><span class="std std-ref">rocalution::BiCGStabl&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_c_g"><span class="std std-ref">rocalution::CG&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_chebyshev"><span class="std std-ref">rocalution::Chebyshev&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_c_r"><span class="std std-ref">rocalution::CR&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_f_c_g"><span class="std std-ref">rocalution::FCG&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_f_g_m_r_e_s"><span class="std std-ref">rocalution::FGMRES&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_fixed_point"><span class="std std-ref">rocalution::FixedPoint&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_g_m_r_e_s"><span class="std std-ref">rocalution::GMRES&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_i_d_r"><span class="std std-ref">rocalution::IDR&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_q_m_r_c_g_stab"><span class="std std-ref">rocalution::QMRCGStab&lt; OperatorType, VectorType, ValueType &gt;</span></a></p>
</dd></dl>

<p>It provides an interface for</p>
<dl class="function">
<dt id="_CPPv3N10rocalution21IterativeLinearSolver4InitEdddi">
<span id="_CPPv2N10rocalution21IterativeLinearSolver4InitEdddi"></span><span id="rocalution::IterativeLinearSolver::Init__double.double.double.i"></span><span class="target" id="classrocalution_1_1_iterative_linear_solver_1a2a8eebb0b187469ed92c675bd75e34b8"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution21IterativeLinearSolverE" title="rocalution::IterativeLinearSolver">IterativeLinearSolver</a><code class="descclassname">::</code></code><code class="descname">Init</code><span class="sig-paren">(</span>double <em>abs_tol</em>, double <em>rel_tol</em>, double <em>div_tol</em>, int <em>max_iter</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize the solver with absolute/relative/divergence tolerance and maximum number of iterations. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution21IterativeLinearSolver4InitEdddii">
<span id="_CPPv2N10rocalution21IterativeLinearSolver4InitEdddii"></span><span id="rocalution::IterativeLinearSolver::Init__double.double.double.i.i"></span><span class="target" id="classrocalution_1_1_iterative_linear_solver_1a0c6fb1aeaf491a1e4891dc13d4b893b2"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution21IterativeLinearSolverE" title="rocalution::IterativeLinearSolver">IterativeLinearSolver</a><code class="descclassname">::</code></code><code class="descname">Init</code><span class="sig-paren">(</span>double <em>abs_tol</em>, double <em>rel_tol</em>, double <em>div_tol</em>, int <em>min_iter</em>, int <em>max_iter</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize the solver with absolute/relative/divergence tolerance and minimum/maximum number of iterations. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution21IterativeLinearSolver11InitMinIterEi">
<span id="_CPPv2N10rocalution21IterativeLinearSolver11InitMinIterEi"></span><span id="rocalution::IterativeLinearSolver::InitMinIter__i"></span><span class="target" id="classrocalution_1_1_iterative_linear_solver_1a025c99dd56f7b09ebfd9df3905093c8e"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution21IterativeLinearSolverE" title="rocalution::IterativeLinearSolver">IterativeLinearSolver</a><code class="descclassname">::</code></code><code class="descname">InitMinIter</code><span class="sig-paren">(</span>int <em>min_iter</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the minimum number of iterations. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution21IterativeLinearSolver11InitMaxIterEi">
<span id="_CPPv2N10rocalution21IterativeLinearSolver11InitMaxIterEi"></span><span id="rocalution::IterativeLinearSolver::InitMaxIter__i"></span><span class="target" id="classrocalution_1_1_iterative_linear_solver_1a3b248faab2ff42e9106b6e38e5e0bbe2"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution21IterativeLinearSolverE" title="rocalution::IterativeLinearSolver">IterativeLinearSolver</a><code class="descclassname">::</code></code><code class="descname">InitMaxIter</code><span class="sig-paren">(</span>int <em>max_iter</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the maximum number of iterations. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution21IterativeLinearSolver7InitTolEddd">
<span id="_CPPv2N10rocalution21IterativeLinearSolver7InitTolEddd"></span><span id="rocalution::IterativeLinearSolver::InitTol__double.double.double"></span><span class="target" id="classrocalution_1_1_iterative_linear_solver_1a05b570833a869738be46986d255b3c39"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution21IterativeLinearSolverE" title="rocalution::IterativeLinearSolver">IterativeLinearSolver</a><code class="descclassname">::</code></code><code class="descname">InitTol</code><span class="sig-paren">(</span>double <em>abs</em>, double <em>rel</em>, double <em>div</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the absolute/relative/divergence tolerance. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution21IterativeLinearSolver21RecordResidualHistoryEv">
<span id="_CPPv2N10rocalution21IterativeLinearSolver21RecordResidualHistoryEv"></span><span id="rocalution::IterativeLinearSolver::RecordResidualHistory__void"></span><span class="target" id="classrocalution_1_1_iterative_linear_solver_1a0a5fd39c7f75f4339eaa41b67868653d"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution21IterativeLinearSolverE" title="rocalution::IterativeLinearSolver">IterativeLinearSolver</a><code class="descclassname">::</code></code><code class="descname">RecordResidualHistory</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Record the residual history. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK10rocalution21IterativeLinearSolver13RecordHistoryEKNSt6stringE">
<span id="_CPPv2NK10rocalution21IterativeLinearSolver13RecordHistoryEKNSt6stringE"></span><span id="rocalution::IterativeLinearSolver::RecordHistory__ssCC"></span><span class="target" id="classrocalution_1_1_iterative_linear_solver_1ae13555f823f7cd1a5c3a7ef3b4427f74"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution21IterativeLinearSolverE" title="rocalution::IterativeLinearSolver">IterativeLinearSolver</a><code class="descclassname">::</code></code><code class="descname">RecordHistory</code><span class="sig-paren">(</span><em class="property">const</em> std::string <em>filename</em><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>Write the history to file. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution21IterativeLinearSolver7VerboseEi">
<span id="_CPPv2N10rocalution21IterativeLinearSolver7VerboseEi"></span><span id="rocalution::IterativeLinearSolver::Verbose__i"></span><span class="target" id="classrocalution_1_1_iterative_linear_solver_1ac88dc520e41c9d1a2de5ad8c95e644c2"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution21IterativeLinearSolverE" title="rocalution::IterativeLinearSolver">IterativeLinearSolver</a><code class="descclassname">::</code></code><code class="descname">Verbose</code><span class="sig-paren">(</span>int <em>verb</em> = 1<span class="sig-paren">)</span><br /></dt>
<dd><p>Set the solver verbosity output. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution21IterativeLinearSolver17SetPreconditionerER6SolverI12OperatorType10VectorType9ValueTypeE">
<span id="_CPPv2N10rocalution21IterativeLinearSolver17SetPreconditionerER6SolverI12OperatorType10VectorType9ValueTypeE"></span><span id="rocalution::IterativeLinearSolver::SetPreconditioner__Solver:OperatorType.VectorType.ValueType:R"></span><span class="target" id="classrocalution_1_1_iterative_linear_solver_1ac40a58d97330f7bf41d2ae116bc45f80"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution21IterativeLinearSolverE" title="rocalution::IterativeLinearSolver">IterativeLinearSolver</a><code class="descclassname">::</code></code><code class="descname">SetPreconditioner</code><span class="sig-paren">(</span><a class="reference internal" href="api.html#_CPPv3N10rocalution6SolverE" title="rocalution::Solver">Solver</a>&lt;OperatorType, VectorType, ValueType&gt; &amp;<em>precond</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set a preconditioner of the linear solver. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution21IterativeLinearSolver15SetResidualNormEi">
<span id="_CPPv2N10rocalution21IterativeLinearSolver15SetResidualNormEi"></span><span id="rocalution::IterativeLinearSolver::SetResidualNorm__i"></span><span class="target" id="classrocalution_1_1_iterative_linear_solver_1a9a7610d7c31f7259f4365d79187cfa78"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution21IterativeLinearSolverE" title="rocalution::IterativeLinearSolver">IterativeLinearSolver</a><code class="descclassname">::</code></code><code class="descname">SetResidualNorm</code><span class="sig-paren">(</span>int <em>resnorm</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the residual norm to <span class="math notranslate nohighlight">\(L_1\)</span>, <span class="math notranslate nohighlight">\(L_2\)</span> or <span class="math notranslate nohighlight">\(L_\infty\)</span> norm. </p>
<p><ul class="simple">
<li>resnorm = 1 -&gt; <span class="math notranslate nohighlight">\(L_1\)</span> norm</li>
<li>resnorm = 2 -&gt; <span class="math notranslate nohighlight">\(L_2\)</span> norm</li>
<li>resnorm = 3 -&gt; <span class="math notranslate nohighlight">\(L_\infty\)</span> norm </li>
</ul>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution21IterativeLinearSolver20GetAmaxResidualIndexEv">
<span id="_CPPv2N10rocalution21IterativeLinearSolver20GetAmaxResidualIndexEv"></span><span id="rocalution::IterativeLinearSolver::GetAmaxResidualIndex__void"></span><span class="target" id="classrocalution_1_1_iterative_linear_solver_1a20f2516ef96cebecbe83ba153bfacc8e"></span>int <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution21IterativeLinearSolverE" title="rocalution::IterativeLinearSolver">IterativeLinearSolver</a><code class="descclassname">::</code></code><code class="descname">GetAmaxResidualIndex</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Return absolute maximum index of residual vector when using <span class="math notranslate nohighlight">\(L_\infty\)</span> norm. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution21IterativeLinearSolver15GetSolverStatusEv">
<span id="_CPPv2N10rocalution21IterativeLinearSolver15GetSolverStatusEv"></span><span id="rocalution::IterativeLinearSolver::GetSolverStatus__void"></span><span class="target" id="classrocalution_1_1_iterative_linear_solver_1a814064201608ca980284fbea51792137"></span>int <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution21IterativeLinearSolverE" title="rocalution::IterativeLinearSolver">IterativeLinearSolver</a><code class="descclassname">::</code></code><code class="descname">GetSolverStatus</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Return the current status. </p>
</dd></dl>

</div>
<div class="section" id="building-and-solving-phase">
<h3>Building and Solving Phase<a class="headerlink" href="#building-and-solving-phase" title="Permalink to this headline">¶</a></h3>
<p>Each iterative solver consists of a building step and a solving step. During the building step all necessary auxiliary data is allocated and the preconditioner is constructed. After that, the user can call the solving procedure, the solving step can be called several times.</p>
<p>When the initial matrix associated with the solver is on the accelerator, the solver will try to build everything on the accelerator. However, some preconditioners and solvers (such as FSAI and AMG) need to be constructed on the host before they can be transferred to the accelerator. If the initial matrix is on the host and we want to run the solver on the accelerator then we need to move the solver to the accelerator as well as the matrix, the right-hand-side and the solution vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you have a preconditioner associate with the solver, it will be moved automatically to the accelerator when you move the solver.</p>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// CG solver</span>
<span class="n">CG</span><span class="o">&lt;</span><span class="n">LocalMatrix</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">LocalVector</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ValueType</span><span class="o">&gt;</span> <span class="n">ls</span><span class="p">;</span>
<span class="c1">// Multi-Colored ILU preconditioner</span>
<span class="n">MultiColoredILU</span><span class="o">&lt;</span><span class="n">LocalMatrix</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">LocalVector</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ValueType</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>

<span class="c1">// Move matrix and vectors to the accelerator</span>
<span class="n">mat</span><span class="p">.</span><span class="n">MoveToAccelerator</span><span class="p">();</span>
<span class="n">rhs</span><span class="p">.</span><span class="n">MoveToAccelerator</span><span class="p">();</span>
<span class="n">x</span><span class="p">.</span><span class="n">MoveToAccelerator</span><span class="p">();</span>

<span class="c1">// Set mat to be the operator</span>
<span class="n">ls</span><span class="p">.</span><span class="n">SetOperator</span><span class="p">(</span><span class="n">mat</span><span class="p">);</span>
<span class="c1">// Set p as the preconditioner of ls</span>
<span class="n">ls</span><span class="p">.</span><span class="n">SetPreconditioner</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

<span class="c1">// Build the solver and preconditioner on the accelerator</span>
<span class="n">ls</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>

<span class="c1">// Compute the solution on the accelerator</span>
<span class="n">ls</span><span class="p">.</span><span class="n">Solve</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// CG solver</span>
<span class="n">CG</span><span class="o">&lt;</span><span class="n">LocalMatrix</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">LocalVector</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ValueType</span><span class="o">&gt;</span> <span class="n">ls</span><span class="p">;</span>
<span class="c1">// Multi-Colored ILU preconditioner</span>
<span class="n">MultiColoredILU</span><span class="o">&lt;</span><span class="n">LocalMatrix</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">LocalVector</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ValueType</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>

<span class="c1">// Set mat to be the operator</span>
<span class="n">ls</span><span class="p">.</span><span class="n">SetOperator</span><span class="p">(</span><span class="n">mat</span><span class="p">);</span>
<span class="c1">// Set p as the preconditioner of ls</span>
<span class="n">ls</span><span class="p">.</span><span class="n">SetPreconditioner</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

<span class="c1">// Build the solver and preconditioner on the host</span>
<span class="n">ls</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>

<span class="c1">// Move matrix and vectors to the accelerator</span>
<span class="n">mat</span><span class="p">.</span><span class="n">MoveToAccelerator</span><span class="p">();</span>
<span class="n">rhs</span><span class="p">.</span><span class="n">MoveToAccelerator</span><span class="p">();</span>
<span class="n">x</span><span class="p">.</span><span class="n">MoveToAccelerator</span><span class="p">();</span>

<span class="c1">// Move linear solver to the accelerator</span>
<span class="n">ls</span><span class="p">.</span><span class="n">MoveToAccelerator</span><span class="p">();</span>

<span class="c1">// Compute the solution on the accelerator</span>
<span class="n">ls</span><span class="p">.</span><span class="n">Solve</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="clear-function-and-destructor">
<h3>Clear Function and Destructor<a class="headerlink" href="#clear-function-and-destructor" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="api.html#_CPPv3N10rocalution6Solver5ClearEv" title="rocalution::Solver::Clear"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::Solver::Clear()</span></code></a> function clears all the data which is in the solver, including the associated preconditioner. Thus, the solver is not anymore associated with this preconditioner.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The preconditioner is not deleted (via destructor), only a <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::Preconditioner::Clear()</span></code> is called.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When the destructor of the solver class is called, it automatically calls the <em>Clear()</em> function. Be careful, when declaring your solver and preconditioner in different places - we highly recommend to manually call the <em>Clear()</em> function of the solver and not to rely on the destructor of the solver.</p>
</div>
</div>
<div class="section" id="numerical-update">
<h3>Numerical Update<a class="headerlink" href="#numerical-update" title="Permalink to this headline">¶</a></h3>
<p>Some preconditioners require two phases in the their construction: an algebraic (e.g. compute a pattern or structure) and a numerical (compute the actual values) phase. In cases, where the structure of the input matrix is a constant (e.g. Newton-like methods) it is not necessary to fully re-construct the preconditioner. In this case, the user can apply a numerical update to the current preconditioner and pass the new operator with <a class="reference internal" href="api.html#_CPPv3N10rocalution6Solver14ReBuildNumericEv" title="rocalution::Solver::ReBuildNumeric"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::Solver::ReBuildNumeric()</span></code></a>. If the preconditioner/solver does not support the numerical update, then a full <a class="reference internal" href="api.html#_CPPv3N10rocalution6Solver5ClearEv" title="rocalution::Solver::Clear"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::Solver::Clear()</span></code></a> and <a class="reference internal" href="api.html#_CPPv3N10rocalution6Solver5BuildEv" title="rocalution::Solver::Build"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::Solver::Build()</span></code></a> will be performed.</p>
</div>
<div class="section" id="fixed-point-iteration">
<h3>Fixed-Point Iteration<a class="headerlink" href="#fixed-point-iteration" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv3N10rocalution10FixedPointE">
<span id="_CPPv2N10rocalution10FixedPointE"></span><span id="rocalution::FixedPoint"></span><span class="target" id="classrocalution_1_1_fixed_point"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">FixedPoint</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution21IterativeLinearSolverE" title="rocalution::IterativeLinearSolver">IterativeLinearSolver</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Fixed-Point Iteration Scheme. </p>
<p>The Fixed-Point iteration scheme is based on additive splitting of the matrix <span class="math notranslate nohighlight">\(A = M + N\)</span>. The scheme reads <div class="math notranslate nohighlight">
\[ x_{k+1} = M^{-1} (b - N x_{k}). \]</div>
 It can also be reformulated as a weighted defect correction scheme <div class="math notranslate nohighlight">
\[ x_{k+1} = x_{k} - \omega M^{-1} (Ax_{k} - b). \]</div>
 The inversion of <span class="math notranslate nohighlight">\(M\)</span> can be performed by preconditioners (<a class="reference internal" href="#classrocalution_1_1_jacobi"><span class="std std-ref">Jacobi</span></a>, Gauss-Seidel, <a class="reference internal" href="#classrocalution_1_1_i_l_u"><span class="std std-ref">ILU</span></a>, etc.) or by any type of solvers.</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a>, <a class="reference internal" href="#classrocalution_1_1_global_matrix"><span class="std std-ref">GlobalMatrix</span></a> or <a class="reference internal" href="#classrocalution_1_1_local_stencil"><span class="std std-ref">LocalStencil</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> or <a class="reference internal" href="#classrocalution_1_1_global_vector"><span class="std std-ref">GlobalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution10FixedPoint13SetRelaxationE9ValueType">
<span id="_CPPv2N10rocalution10FixedPoint13SetRelaxationE9ValueType"></span><span id="rocalution::FixedPoint::SetRelaxation__ValueType"></span><span class="target" id="classrocalution_1_1_fixed_point_1a3aaa22bef74ae87f76051850a002d041"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution10FixedPointE" title="rocalution::FixedPoint">FixedPoint</a><code class="descclassname">::</code></code><code class="descname">SetRelaxation</code><span class="sig-paren">(</span>ValueType <em>omega</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set relaxation parameter <span class="math notranslate nohighlight">\(\omega\)</span>. </p>
</dd></dl>

</div>
<div class="section" id="krylov-subspace-solvers">
<h3>Krylov Subspace Solvers<a class="headerlink" href="#krylov-subspace-solvers" title="Permalink to this headline">¶</a></h3>
<div class="section" id="cg">
<h4>CG<a class="headerlink" href="#cg" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv3N10rocalution2CGE">
<span id="_CPPv2N10rocalution2CGE"></span><span id="rocalution::CG"></span><span class="target" id="classrocalution_1_1_c_g"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">CG</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution21IterativeLinearSolverE" title="rocalution::IterativeLinearSolver">IterativeLinearSolver</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Conjugate Gradient Method. </p>
<p>The Conjugate Gradient method is the best known iterative method for solving sparse symmetric positive definite (SPD) linear systems <span class="math notranslate nohighlight">\(Ax=b\)</span>. It is based on orthogonal projection onto the Krylov subspace <span class="math notranslate nohighlight">\(\mathcal{K}_{m}(r_{0}, A)\)</span>, where <span class="math notranslate nohighlight">\(r_{0}\)</span> is the initial residual. The method can be preconditioned, where the approximation should also be SPD. SAAD</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a>, <a class="reference internal" href="#classrocalution_1_1_global_matrix"><span class="std std-ref">GlobalMatrix</span></a> or <a class="reference internal" href="#classrocalution_1_1_local_stencil"><span class="std std-ref">LocalStencil</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> or <a class="reference internal" href="#classrocalution_1_1_global_vector"><span class="std std-ref">GlobalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<p>For further details, see <a href="#id18"><span class="problematic" id="id19">:cite:`SAAD`</span></a>.</p>
</div>
<div class="section" id="cr">
<h4>CR<a class="headerlink" href="#cr" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv3N10rocalution2CRE">
<span id="_CPPv2N10rocalution2CRE"></span><span id="rocalution::CR"></span><span class="target" id="classrocalution_1_1_c_r"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">CR</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution21IterativeLinearSolverE" title="rocalution::IterativeLinearSolver">IterativeLinearSolver</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Conjugate Residual Method. </p>
<p>The Conjugate Residual method is an iterative method for solving sparse symmetric semi-positive definite linear systems <span class="math notranslate nohighlight">\(Ax=b\)</span>. It is a Krylov subspace method and differs from the much more popular Conjugate Gradient method that the system matrix is not required to be positive definite. The method can be preconditioned where the approximation should also be SPD or semi-positive definite. SAAD</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a>, <a class="reference internal" href="#classrocalution_1_1_global_matrix"><span class="std std-ref">GlobalMatrix</span></a> or <a class="reference internal" href="#classrocalution_1_1_local_stencil"><span class="std std-ref">LocalStencil</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> or <a class="reference internal" href="#classrocalution_1_1_global_vector"><span class="std std-ref">GlobalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<p>For further details, see <a href="#id20"><span class="problematic" id="id21">:cite:`SAAD`</span></a>.</p>
</div>
<div class="section" id="gmres">
<h4>GMRES<a class="headerlink" href="#gmres" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv3N10rocalution5GMRESE">
<span id="_CPPv2N10rocalution5GMRESE"></span><span id="rocalution::GMRES"></span><span class="target" id="classrocalution_1_1_g_m_r_e_s"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">GMRES</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution21IterativeLinearSolverE" title="rocalution::IterativeLinearSolver">IterativeLinearSolver</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Generalized Minimum Residual Method. </p>
<p>The Generalized Minimum Residual method (<a class="reference internal" href="#classrocalution_1_1_g_m_r_e_s"><span class="std std-ref">GMRES</span></a>) is a projection method for solving sparse (non) symmetric linear systems <span class="math notranslate nohighlight">\(Ax=b\)</span>, based on restarting technique. The solution is approximated in a Krylov subspace <span class="math notranslate nohighlight">\(\mathcal{K}=\mathcal{K}_{m}\)</span> and <span class="math notranslate nohighlight">\(\mathcal{L}=A\mathcal{K}_{m}\)</span> with minimal residual, where <span class="math notranslate nohighlight">\(\mathcal{K}_{m}\)</span> is the <span class="math notranslate nohighlight">\(m\)</span>-th Krylov subspace with <span class="math notranslate nohighlight">\(v_{1} = r_{0}/||r_{0}||_{2}\)</span>. SAAD</p>
<p>The Krylov subspace basis size can be set using <a class="reference internal" href="#classrocalution_1_1_g_m_r_e_s_1a10653ae4ae57d6ff8025d34ebf5231c8"><span class="std std-ref">SetBasisSize()</span></a>. The default size is 30.</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a>, <a class="reference internal" href="#classrocalution_1_1_global_matrix"><span class="std std-ref">GlobalMatrix</span></a> or <a class="reference internal" href="#classrocalution_1_1_local_stencil"><span class="std std-ref">LocalStencil</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> or <a class="reference internal" href="#classrocalution_1_1_global_vector"><span class="std std-ref">GlobalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution5GMRES12SetBasisSizeEi">
<span id="_CPPv2N10rocalution5GMRES12SetBasisSizeEi"></span><span id="rocalution::GMRES::SetBasisSize__i"></span><span class="target" id="classrocalution_1_1_g_m_r_e_s_1a10653ae4ae57d6ff8025d34ebf5231c8"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution5GMRESE" title="rocalution::GMRES">GMRES</a><code class="descclassname">::</code></code><code class="descname">SetBasisSize</code><span class="sig-paren">(</span>int <em>size_basis</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the size of the Krylov subspace basis. </p>
</dd></dl>

<p>For further details, see <a href="#id22"><span class="problematic" id="id23">:cite:`SAAD`</span></a>.</p>
</div>
<div class="section" id="fgmres">
<h4>FGMRES<a class="headerlink" href="#fgmres" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv3N10rocalution6FGMRESE">
<span id="_CPPv2N10rocalution6FGMRESE"></span><span id="rocalution::FGMRES"></span><span class="target" id="classrocalution_1_1_f_g_m_r_e_s"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">FGMRES</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution21IterativeLinearSolverE" title="rocalution::IterativeLinearSolver">IterativeLinearSolver</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Flexible Generalized Minimum Residual Method. </p>
<p>The Flexible Generalized Minimum Residual method (<a class="reference internal" href="#classrocalution_1_1_f_g_m_r_e_s"><span class="std std-ref">FGMRES</span></a>) is a projection method for solving sparse (non) symmetric linear systems <span class="math notranslate nohighlight">\(Ax=b\)</span>. It is similar to the <a class="reference internal" href="#classrocalution_1_1_g_m_r_e_s"><span class="std std-ref">GMRES</span></a> method with the only difference, the <a class="reference internal" href="#classrocalution_1_1_f_g_m_r_e_s"><span class="std std-ref">FGMRES</span></a> is based on a window shifting of the Krylov subspace and thus allows the preconditioner <span class="math notranslate nohighlight">\(M^{-1}\)</span> to be not a constant operator. This can be especially helpful if the operation <span class="math notranslate nohighlight">\(M^{-1}x\)</span> is the result of another iterative process and not a constant operator. SAAD</p>
<p>The Krylov subspace basis size can be set using <a class="reference internal" href="#classrocalution_1_1_f_g_m_r_e_s_1aca2ae523796ca1ec710b6b7f864dd82c"><span class="std std-ref">SetBasisSize()</span></a>. The default size is 30.</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a>, <a class="reference internal" href="#classrocalution_1_1_global_matrix"><span class="std std-ref">GlobalMatrix</span></a> or <a class="reference internal" href="#classrocalution_1_1_local_stencil"><span class="std std-ref">LocalStencil</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> or <a class="reference internal" href="#classrocalution_1_1_global_vector"><span class="std std-ref">GlobalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution6FGMRES12SetBasisSizeEi">
<span id="_CPPv2N10rocalution6FGMRES12SetBasisSizeEi"></span><span id="rocalution::FGMRES::SetBasisSize__i"></span><span class="target" id="classrocalution_1_1_f_g_m_r_e_s_1aca2ae523796ca1ec710b6b7f864dd82c"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution6FGMRESE" title="rocalution::FGMRES">FGMRES</a><code class="descclassname">::</code></code><code class="descname">SetBasisSize</code><span class="sig-paren">(</span>int <em>size_basis</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the size of the Krylov subspace basis. </p>
</dd></dl>

<p>For further details, see <a href="#id24"><span class="problematic" id="id25">:cite:`SAAD`</span></a>.</p>
</div>
<div class="section" id="bicgstab">
<h4>BiCGStab<a class="headerlink" href="#bicgstab" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv3N10rocalution8BiCGStabE">
<span id="_CPPv2N10rocalution8BiCGStabE"></span><span id="rocalution::BiCGStab"></span><span class="target" id="classrocalution_1_1_bi_c_g_stab"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">BiCGStab</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution21IterativeLinearSolverE" title="rocalution::IterativeLinearSolver">IterativeLinearSolver</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Bi-Conjugate Gradient Stabilized Method. </p>
<p>The Bi-Conjugate Gradient Stabilized method is a variation of CGS and solves sparse (non) symmetric linear systems <span class="math notranslate nohighlight">\(Ax=b\)</span>. SAAD</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a>, <a class="reference internal" href="#classrocalution_1_1_global_matrix"><span class="std std-ref">GlobalMatrix</span></a> or <a class="reference internal" href="#classrocalution_1_1_local_stencil"><span class="std std-ref">LocalStencil</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> or <a class="reference internal" href="#classrocalution_1_1_global_vector"><span class="std std-ref">GlobalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<p>For further details, see <a href="#id26"><span class="problematic" id="id27">:cite:`SAAD`</span></a>.</p>
</div>
<div class="section" id="idr">
<h4>IDR<a class="headerlink" href="#idr" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv3N10rocalution3IDRE">
<span id="_CPPv2N10rocalution3IDRE"></span><span id="rocalution::IDR"></span><span class="target" id="classrocalution_1_1_i_d_r"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">IDR</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution21IterativeLinearSolverE" title="rocalution::IterativeLinearSolver">IterativeLinearSolver</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Induced Dimension Reduction Method. </p>
<p>The Induced Dimension Reduction method is a Krylov subspace method for solving sparse (non) symmetric linear systems <span class="math notranslate nohighlight">\(Ax=b\)</span>. IDR(s) generates residuals in a sequence of nested subspaces. IDR1 IDR2</p>
<p>The dimension of the shadow space can be set by <a class="reference internal" href="#classrocalution_1_1_i_d_r_1ae6ecd7dcdfc8fa84714d2dea452ef6e2"><span class="std std-ref">SetShadowSpace()</span></a>. The default size of the shadow space is 4.</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a>, <a class="reference internal" href="#classrocalution_1_1_global_matrix"><span class="std std-ref">GlobalMatrix</span></a> or <a class="reference internal" href="#classrocalution_1_1_local_stencil"><span class="std std-ref">LocalStencil</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> or <a class="reference internal" href="#classrocalution_1_1_global_vector"><span class="std std-ref">GlobalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution3IDR14SetShadowSpaceEi">
<span id="_CPPv2N10rocalution3IDR14SetShadowSpaceEi"></span><span id="rocalution::IDR::SetShadowSpace__i"></span><span class="target" id="classrocalution_1_1_i_d_r_1ae6ecd7dcdfc8fa84714d2dea452ef6e2"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution3IDRE" title="rocalution::IDR">IDR</a><code class="descclassname">::</code></code><code class="descname">SetShadowSpace</code><span class="sig-paren">(</span>int <em>s</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the size of the Shadow Space. </p>
</dd></dl>

<p>For further details, see <a href="#id28"><span class="problematic" id="id29">:cite:`IDR1`</span></a> and <a href="#id30"><span class="problematic" id="id31">:cite:`IDR2`</span></a>.</p>
</div>
<div class="section" id="fcg">
<h4>FCG<a class="headerlink" href="#fcg" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv3N10rocalution3FCGE">
<span id="_CPPv2N10rocalution3FCGE"></span><span id="rocalution::FCG"></span><span class="target" id="classrocalution_1_1_f_c_g"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">FCG</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution21IterativeLinearSolverE" title="rocalution::IterativeLinearSolver">IterativeLinearSolver</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Flexible Conjugate Gradient Method. </p>
<p>The Flexible Conjugate Gradient method is an iterative method for solving sparse symmetric positive definite linear systems <span class="math notranslate nohighlight">\(Ax=b\)</span>. It is similar to the Conjugate Gradient method with the only difference, that it allows the preconditioner <span class="math notranslate nohighlight">\(M^{-1}\)</span> to be not a constant operator. This can be especially helpful if the operation <span class="math notranslate nohighlight">\(M^{-1}x\)</span> is the result of another iterative process and not a constant operator. fcg</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> or <a class="reference internal" href="#classrocalution_1_1_global_matrix"><span class="std std-ref">GlobalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> or <a class="reference internal" href="#classrocalution_1_1_global_vector"><span class="std std-ref">GlobalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<p>For further details, see <a href="#id32"><span class="problematic" id="id33">:cite:`fcg`</span></a>.</p>
</div>
<div class="section" id="qmrcgstab">
<h4>QMRCGStab<a class="headerlink" href="#qmrcgstab" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv3N10rocalution9QMRCGStabE">
<span id="_CPPv2N10rocalution9QMRCGStabE"></span><span id="rocalution::QMRCGStab"></span><span class="target" id="classrocalution_1_1_q_m_r_c_g_stab"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">QMRCGStab</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution21IterativeLinearSolverE" title="rocalution::IterativeLinearSolver">IterativeLinearSolver</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Quasi-Minimal Residual Conjugate Gradient Stabilized Method. </p>
<p>The Quasi-Minimal Residual Conjugate Gradient Stabilized method is a variant of the Krylov subspace <a class="reference internal" href="#classrocalution_1_1_bi_c_g_stab"><span class="std std-ref">BiCGStab</span></a> method for solving sparse (non) symmetric linear systems <span class="math notranslate nohighlight">\(Ax=b\)</span>. qmrcgstab</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> or <a class="reference internal" href="#classrocalution_1_1_global_matrix"><span class="std std-ref">GlobalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> or <a class="reference internal" href="#classrocalution_1_1_global_vector"><span class="std std-ref">GlobalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<p>For further details, see <a href="#id34"><span class="problematic" id="id35">:cite:`qmrcgstab`</span></a>.</p>
</div>
<div class="section" id="bicgstab-l">
<h4>BiCGStab(l)<a class="headerlink" href="#bicgstab-l" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv3N10rocalution9BiCGStablE">
<span id="_CPPv2N10rocalution9BiCGStablE"></span><span id="rocalution::BiCGStabl"></span><span class="target" id="classrocalution_1_1_bi_c_g_stabl"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">BiCGStabl</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution21IterativeLinearSolverE" title="rocalution::IterativeLinearSolver">IterativeLinearSolver</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Bi-Conjugate Gradient Stabilized (l) Method. </p>
<p>The Bi-Conjugate Gradient Stabilized (l) method is a generalization of <a class="reference internal" href="#classrocalution_1_1_bi_c_g_stab"><span class="std std-ref">BiCGStab</span></a> for solving sparse (non) symmetric linear systems <span class="math notranslate nohighlight">\(Ax=b\)</span>. It minimizes residuals over <span class="math notranslate nohighlight">\(l\)</span>-dimensional Krylov subspaces. The degree <span class="math notranslate nohighlight">\(l\)</span> can be set with <a class="reference internal" href="#classrocalution_1_1_bi_c_g_stabl_1af0084f3f7f847151973e9f25de96a50b"><span class="std std-ref">SetOrder()</span></a>. bicgstabl</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> or <a class="reference internal" href="#classrocalution_1_1_global_matrix"><span class="std std-ref">GlobalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> or <a class="reference internal" href="#classrocalution_1_1_global_vector"><span class="std std-ref">GlobalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution9BiCGStabl8SetOrderEi">
<span id="_CPPv2N10rocalution9BiCGStabl8SetOrderEi"></span><span id="rocalution::BiCGStabl::SetOrder__i"></span><span class="target" id="classrocalution_1_1_bi_c_g_stabl_1af0084f3f7f847151973e9f25de96a50b"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution9BiCGStablE" title="rocalution::BiCGStabl">BiCGStabl</a><code class="descclassname">::</code></code><code class="descname">SetOrder</code><span class="sig-paren">(</span>int <em>l</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the order. </p>
</dd></dl>

<p>For further details, see <a href="#id36"><span class="problematic" id="id37">:cite:`bicgstabl`</span></a>.</p>
</div>
</div>
<div class="section" id="chebyshev-iteration-scheme">
<h3>Chebyshev Iteration Scheme<a class="headerlink" href="#chebyshev-iteration-scheme" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv3N10rocalution9ChebyshevE">
<span id="_CPPv2N10rocalution9ChebyshevE"></span><span id="rocalution::Chebyshev"></span><span class="target" id="classrocalution_1_1_chebyshev"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">Chebyshev</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution21IterativeLinearSolverE" title="rocalution::IterativeLinearSolver">IterativeLinearSolver</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p><a class="reference internal" href="#classrocalution_1_1_chebyshev"><span class="std std-ref">Chebyshev</span></a> Iteration Scheme. </p>
<p>The <a class="reference internal" href="#classrocalution_1_1_chebyshev"><span class="std std-ref">Chebyshev</span></a> Iteration scheme (also known as acceleration scheme) is similar to the <a class="reference internal" href="#classrocalution_1_1_c_g"><span class="std std-ref">CG</span></a> method but requires minimum and maximum eigenvalues of the operator. templates</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a>, <a class="reference internal" href="#classrocalution_1_1_global_matrix"><span class="std std-ref">GlobalMatrix</span></a> or <a class="reference internal" href="#classrocalution_1_1_local_stencil"><span class="std std-ref">LocalStencil</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> or <a class="reference internal" href="#classrocalution_1_1_global_vector"><span class="std std-ref">GlobalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<p>For further details, see <a href="#id38"><span class="problematic" id="id39">:cite:`templates`</span></a>.</p>
</div>
<div class="section" id="mixed-precision-defect-correction-scheme">
<h3>Mixed-Precision Defect Correction Scheme<a class="headerlink" href="#mixed-precision-defect-correction-scheme" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv3N10rocalution16MixedPrecisionDCE">
<span id="_CPPv2N10rocalution16MixedPrecisionDCE"></span><span id="rocalution::MixedPrecisionDC"></span><span class="target" id="classrocalution_1_1_mixed_precision_d_c"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorTypeH, <em class="property">class</em> VectorTypeH, <em class="property">typename</em> ValueTypeH, <em class="property">class</em> OperatorTypeL, <em class="property">class</em> VectorTypeL, <em class="property">typename</em> ValueTypeL&gt;<br /><em class="property">class </em><code class="descname">MixedPrecisionDC</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution21IterativeLinearSolverE" title="rocalution::IterativeLinearSolver">IterativeLinearSolver</a>&lt;OperatorTypeH, VectorTypeH, ValueTypeH&gt;<br /></dt>
<dd><p>Mixed-Precision Defect Correction Scheme. </p>
<p>The Mixed-Precision solver is based on a defect-correction scheme. The current implementation of the library is using host based correction in double precision and accelerator computation in single precision. The solver is implemeting the scheme <div class="math notranslate nohighlight">
\[ x_{k+1} = x_{k} + A^{-1} r_{k}, \]</div>
 where the computation of the residual <span class="math notranslate nohighlight">\(r_{k} = b - Ax_{k}\)</span> and the update <span class="math notranslate nohighlight">\(x_{k+1} = x_{k} + d_{k}\)</span> are performed on the host in double precision. The computation of the residual system <span class="math notranslate nohighlight">\(Ad_{k} = r_{k}\)</span> is performed on the accelerator in single precision. In addition to the setup functions of the iterative solver, the user need to specify the inner ( <span class="math notranslate nohighlight">\(Ad_{k} = r_{k}\)</span>) solver.</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorTypeH</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorTypeH</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueTypeH</span></code>: - can be double </li>
<li><code class="docutils literal notranslate"><span class="pre">OperatorTypeL</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorTypeL</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueTypeL</span></code>: - can be float </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="section" id="multigrid-solvers">
<h3>MultiGrid Solvers<a class="headerlink" href="#multigrid-solvers" title="Permalink to this headline">¶</a></h3>
<p>The library provides algebraic multigrid as well as a skeleton for geometric multigrid methods. The BaseMultigrid class itself is not constructing the data for the method. It contains the solution procedure for V, W and K-cycles. The AMG has two different versions for Local (non-MPI) and for Global (MPI) type of computations.</p>
<dl class="class">
<dt id="_CPPv3N10rocalution13BaseMultiGridE">
<span id="_CPPv2N10rocalution13BaseMultiGridE"></span><span id="rocalution::BaseMultiGrid"></span><span class="target" id="classrocalution_1_1_base_multi_grid"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">BaseMultiGrid</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution21IterativeLinearSolverE" title="rocalution::IterativeLinearSolver">IterativeLinearSolver</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Base class for all multigrid solvers Trottenberg2003. </p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> or <a class="reference internal" href="#classrocalution_1_1_global_matrix"><span class="std std-ref">GlobalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> or <a class="reference internal" href="#classrocalution_1_1_global_vector"><span class="std std-ref">GlobalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
<p>Subclassed by <a class="reference internal" href="#classrocalution_1_1_base_a_m_g"><span class="std std-ref">rocalution::BaseAMG&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_multi_grid"><span class="std std-ref">rocalution::MultiGrid&lt; OperatorType, VectorType, ValueType &gt;</span></a></p>
</dd></dl>

<div class="section" id="geometric-multigrid">
<h4>Geometric MultiGrid<a class="headerlink" href="#geometric-multigrid" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv3N10rocalution9MultiGridE">
<span id="_CPPv2N10rocalution9MultiGridE"></span><span id="rocalution::MultiGrid"></span><span class="target" id="classrocalution_1_1_multi_grid"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">MultiGrid</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution13BaseMultiGridE" title="rocalution::BaseMultiGrid">BaseMultiGrid</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p><a class="reference internal" href="#classrocalution_1_1_multi_grid"><span class="std std-ref">MultiGrid</span></a> Method. </p>
<p>The <a class="reference internal" href="#classrocalution_1_1_multi_grid"><span class="std std-ref">MultiGrid</span></a> method can be used with external data, such as externally computed restriction, prolongation and operator hierarchy. The user need to pass all this information for each level and for its construction. This includes smoothing step, prolongation/restriction, grid traversing and coarse grid solver. This data need to be passed to the solver. Trottenberg2003<ul class="simple">
<li>Restriction and prolongation operations can be performed in two ways, based on Restriction() and Prolongation() of the <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> class, or by matrix-vector multiplication. This is configured by a set function.</li>
<li>Smoothers can be of any iterative linear solver. Valid options are <a class="reference internal" href="#classrocalution_1_1_jacobi"><span class="std std-ref">Jacobi</span></a>, Gauss-Seidel, <a class="reference internal" href="#classrocalution_1_1_i_l_u"><span class="std std-ref">ILU</span></a>, etc. using a <a class="reference internal" href="#classrocalution_1_1_fixed_point"><span class="std std-ref">FixedPoint</span></a> iteration scheme with pre-defined number of iterations. The smoothers could also be a solver such as <a class="reference internal" href="#classrocalution_1_1_c_g"><span class="std std-ref">CG</span></a>, <a class="reference internal" href="#classrocalution_1_1_bi_c_g_stab"><span class="std std-ref">BiCGStab</span></a>, etc.</li>
<li>Coarse grid solver could be of any iterative linear solver type. The class also provides mechanisms to specify, where the coarse grid solver has to be performed, on the host or on the accelerator. The coarse grid solver can be preconditioned.</li>
<li>Grid scaling based on a <span class="math notranslate nohighlight">\(L_2\)</span> norm ratio.</li>
<li><a class="reference internal" href="api.html#classrocalution_1_1_operator"><span class="std std-ref">Operator</span></a> matrices need to be passed on each grid level.</li>
</ul>
</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> or <a class="reference internal" href="#classrocalution_1_1_global_matrix"><span class="std std-ref">GlobalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> or <a class="reference internal" href="#classrocalution_1_1_global_vector"><span class="std std-ref">GlobalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<p>For further details, see <a href="#id40"><span class="problematic" id="id41">:cite:`Trottenberg2003`</span></a>.</p>
</div>
<div class="section" id="algebraic-multigrid">
<h4>Algebraic MultiGrid<a class="headerlink" href="#algebraic-multigrid" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv3N10rocalution7BaseAMGE">
<span id="_CPPv2N10rocalution7BaseAMGE"></span><span id="rocalution::BaseAMG"></span><span class="target" id="classrocalution_1_1_base_a_m_g"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">BaseAMG</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution13BaseMultiGridE" title="rocalution::BaseMultiGrid">BaseMultiGrid</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Base class for all algebraic multigrid solvers. </p>
<p>The Algebraic <a class="reference internal" href="#classrocalution_1_1_multi_grid"><span class="std std-ref">MultiGrid</span></a> solver is based on the <a class="reference internal" href="#classrocalution_1_1_base_multi_grid"><span class="std std-ref">BaseMultiGrid</span></a> class. The coarsening is obtained by different aggregation techniques. The smoothers can be constructed inside or outside of the class.</p>
<p>All parameters in the Algebraic <a class="reference internal" href="#classrocalution_1_1_multi_grid"><span class="std std-ref">MultiGrid</span></a> class can be set externally, including smoothers and coarse grid solver.</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> or <a class="reference internal" href="#classrocalution_1_1_global_matrix"><span class="std std-ref">GlobalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> or <a class="reference internal" href="#classrocalution_1_1_global_vector"><span class="std std-ref">GlobalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
<p>Subclassed by <a class="reference internal" href="#classrocalution_1_1_global_pairwise_a_m_g"><span class="std std-ref">rocalution::GlobalPairwiseAMG&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_pairwise_a_m_g"><span class="std std-ref">rocalution::PairwiseAMG&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_ruge_stueben_a_m_g"><span class="std std-ref">rocalution::RugeStuebenAMG&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_s_a_a_m_g"><span class="std std-ref">rocalution::SAAMG&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_u_a_a_m_g"><span class="std std-ref">rocalution::UAAMG&lt; OperatorType, VectorType, ValueType &gt;</span></a></p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution7BaseAMG14BuildHierarchyEv">
<span id="_CPPv2N10rocalution7BaseAMG14BuildHierarchyEv"></span><span id="rocalution::BaseAMG::BuildHierarchy__void"></span><span class="target" id="classrocalution_1_1_base_a_m_g_1af6d4defc5f8a6fc67a4fec46c8f1bd66"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution7BaseAMGE" title="rocalution::BaseAMG">BaseAMG</a><code class="descclassname">::</code></code><code class="descname">BuildHierarchy</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Create AMG hierarchy. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution7BaseAMG14BuildSmoothersEv">
<span id="_CPPv2N10rocalution7BaseAMG14BuildSmoothersEv"></span><span id="rocalution::BaseAMG::BuildSmoothers__void"></span><span class="target" id="classrocalution_1_1_base_a_m_g_1a3f76e7e8ceb1772e77772f2c3995f2d7"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution7BaseAMGE" title="rocalution::BaseAMG">BaseAMG</a><code class="descclassname">::</code></code><code class="descname">BuildSmoothers</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Create AMG smoothers. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution7BaseAMG16SetCoarsestLevelEi">
<span id="_CPPv2N10rocalution7BaseAMG16SetCoarsestLevelEi"></span><span id="rocalution::BaseAMG::SetCoarsestLevel__i"></span><span class="target" id="classrocalution_1_1_base_a_m_g_1a96281a009e8cb941f8ff269035302d4c"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution7BaseAMGE" title="rocalution::BaseAMG">BaseAMG</a><code class="descclassname">::</code></code><code class="descname">SetCoarsestLevel</code><span class="sig-paren">(</span>int <em>coarse_size</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set coarsest level for hierarchy creation. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution7BaseAMG18SetManualSmoothersEb">
<span id="_CPPv2N10rocalution7BaseAMG18SetManualSmoothersEb"></span><span id="rocalution::BaseAMG::SetManualSmoothers__b"></span><span class="target" id="classrocalution_1_1_base_a_m_g_1adf20402c86435116ad68911a26e15a4e"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution7BaseAMGE" title="rocalution::BaseAMG">BaseAMG</a><code class="descclassname">::</code></code><code class="descname">SetManualSmoothers</code><span class="sig-paren">(</span>bool <em>sm_manual</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set flag to pass smoothers manually for each level. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution7BaseAMG15SetManualSolverEb">
<span id="_CPPv2N10rocalution7BaseAMG15SetManualSolverEb"></span><span id="rocalution::BaseAMG::SetManualSolver__b"></span><span class="target" id="classrocalution_1_1_base_a_m_g_1a590e1b7401d3b73c63d5bd9d20b92eb4"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution7BaseAMGE" title="rocalution::BaseAMG">BaseAMG</a><code class="descclassname">::</code></code><code class="descname">SetManualSolver</code><span class="sig-paren">(</span>bool <em>s_manual</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set flag to pass coarse grid solver manually. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution7BaseAMG24SetDefaultSmootherFormatEj">
<span id="_CPPv2N10rocalution7BaseAMG24SetDefaultSmootherFormatEj"></span><span id="rocalution::BaseAMG::SetDefaultSmootherFormat__unsigned-i"></span><span class="target" id="classrocalution_1_1_base_a_m_g_1aa359bb6dff698912e524d3d1a45f84fb"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution7BaseAMGE" title="rocalution::BaseAMG">BaseAMG</a><code class="descclassname">::</code></code><code class="descname">SetDefaultSmootherFormat</code><span class="sig-paren">(</span>unsigned int <em>op_format</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the smoother operator format. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution7BaseAMG17SetOperatorFormatEj">
<span id="_CPPv2N10rocalution7BaseAMG17SetOperatorFormatEj"></span><span id="rocalution::BaseAMG::SetOperatorFormat__unsigned-i"></span><span class="target" id="classrocalution_1_1_base_a_m_g_1a0b96ffa5244f9a4ef008aebcb0491e46"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution7BaseAMGE" title="rocalution::BaseAMG">BaseAMG</a><code class="descclassname">::</code></code><code class="descname">SetOperatorFormat</code><span class="sig-paren">(</span>unsigned int <em>op_format</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the operator format. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution7BaseAMG12GetNumLevelsEv">
<span id="_CPPv2N10rocalution7BaseAMG12GetNumLevelsEv"></span><span id="rocalution::BaseAMG::GetNumLevels__void"></span><span class="target" id="classrocalution_1_1_base_a_m_g_1a615e88d5a7abc5a0d3d556e7974ab9e9"></span>int <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution7BaseAMGE" title="rocalution::BaseAMG">BaseAMG</a><code class="descclassname">::</code></code><code class="descname">GetNumLevels</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Returns the number of levels in hierarchy. </p>
</dd></dl>

<div class="section" id="unsmoothed-aggregation-amg">
<h5>Unsmoothed Aggregation AMG<a class="headerlink" href="#unsmoothed-aggregation-amg" title="Permalink to this headline">¶</a></h5>
<dl class="class">
<dt id="_CPPv3N10rocalution5UAAMGE">
<span id="_CPPv2N10rocalution5UAAMGE"></span><span id="rocalution::UAAMG"></span><span class="target" id="classrocalution_1_1_u_a_a_m_g"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">UAAMG</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution7BaseAMGE" title="rocalution::BaseAMG">BaseAMG</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Unsmoothed Aggregation Algebraic <a class="reference internal" href="#classrocalution_1_1_multi_grid"><span class="std std-ref">MultiGrid</span></a> Method. </p>
<p>The Unsmoothed Aggregation Algebraic <a class="reference internal" href="#classrocalution_1_1_multi_grid"><span class="std std-ref">MultiGrid</span></a> method is based on unsmoothed aggregation based interpolation scheme. stuben</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution5UAAMG19SetCouplingStrengthE9ValueType">
<span id="_CPPv2N10rocalution5UAAMG19SetCouplingStrengthE9ValueType"></span><span id="rocalution::UAAMG::SetCouplingStrength__ValueType"></span><span class="target" id="classrocalution_1_1_u_a_a_m_g_1a7d42a31f416971e4566a8db0c519dd7b"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution5UAAMGE" title="rocalution::UAAMG">UAAMG</a><code class="descclassname">::</code></code><code class="descname">SetCouplingStrength</code><span class="sig-paren">(</span>ValueType <em>eps</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set coupling strength. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution5UAAMG13SetOverInterpE9ValueType">
<span id="_CPPv2N10rocalution5UAAMG13SetOverInterpE9ValueType"></span><span id="rocalution::UAAMG::SetOverInterp__ValueType"></span><span class="target" id="classrocalution_1_1_u_a_a_m_g_1a37661f011d64a05a3dff0b2cb74d3b9b"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution5UAAMGE" title="rocalution::UAAMG">UAAMG</a><code class="descclassname">::</code></code><code class="descname">SetOverInterp</code><span class="sig-paren">(</span>ValueType <em>overInterp</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set over-interpolation parameter for aggregation. </p>
</dd></dl>

<p>For further details, see <a href="#id42"><span class="problematic" id="id43">:cite:`stuben`</span></a>.</p>
</div>
<div class="section" id="smoothed-aggregation-amg">
<h5>Smoothed Aggregation AMG<a class="headerlink" href="#smoothed-aggregation-amg" title="Permalink to this headline">¶</a></h5>
<dl class="class">
<dt id="_CPPv3N10rocalution5SAAMGE">
<span id="_CPPv2N10rocalution5SAAMGE"></span><span id="rocalution::SAAMG"></span><span class="target" id="classrocalution_1_1_s_a_a_m_g"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">SAAMG</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution7BaseAMGE" title="rocalution::BaseAMG">BaseAMG</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Smoothed Aggregation Algebraic <a class="reference internal" href="#classrocalution_1_1_multi_grid"><span class="std std-ref">MultiGrid</span></a> Method. </p>
<p>The Smoothed Aggregation Algebraic <a class="reference internal" href="#classrocalution_1_1_multi_grid"><span class="std std-ref">MultiGrid</span></a> method is based on smoothed aggregation based interpolation scheme. vanek</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution5SAAMG19SetCouplingStrengthE9ValueType">
<span id="_CPPv2N10rocalution5SAAMG19SetCouplingStrengthE9ValueType"></span><span id="rocalution::SAAMG::SetCouplingStrength__ValueType"></span><span class="target" id="classrocalution_1_1_s_a_a_m_g_1ad2a730cf911b3202de51f79dd9a7f775"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution5SAAMGE" title="rocalution::SAAMG">SAAMG</a><code class="descclassname">::</code></code><code class="descname">SetCouplingStrength</code><span class="sig-paren">(</span>ValueType <em>eps</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set coupling strength. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution5SAAMG14SetInterpRelaxE9ValueType">
<span id="_CPPv2N10rocalution5SAAMG14SetInterpRelaxE9ValueType"></span><span id="rocalution::SAAMG::SetInterpRelax__ValueType"></span><span class="target" id="classrocalution_1_1_s_a_a_m_g_1a65159c53b41708651925a9d31c1120b0"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution5SAAMGE" title="rocalution::SAAMG">SAAMG</a><code class="descclassname">::</code></code><code class="descname">SetInterpRelax</code><span class="sig-paren">(</span>ValueType <em>relax</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the relaxation parameter. </p>
</dd></dl>

<p>For further details, see <a href="#id44"><span class="problematic" id="id45">:cite:`vanek`</span></a>.</p>
</div>
<div class="section" id="ruge-stueben-amg">
<h5>Ruge-Stueben AMG<a class="headerlink" href="#ruge-stueben-amg" title="Permalink to this headline">¶</a></h5>
<dl class="class">
<dt id="_CPPv3N10rocalution14RugeStuebenAMGE">
<span id="_CPPv2N10rocalution14RugeStuebenAMGE"></span><span id="rocalution::RugeStuebenAMG"></span><span class="target" id="classrocalution_1_1_ruge_stueben_a_m_g"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">RugeStuebenAMG</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution7BaseAMGE" title="rocalution::BaseAMG">BaseAMG</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Ruge-Stueben Algebraic <a class="reference internal" href="#classrocalution_1_1_multi_grid"><span class="std std-ref">MultiGrid</span></a> Method. </p>
<p>The Ruge-Stueben Algebraic <a class="reference internal" href="#classrocalution_1_1_multi_grid"><span class="std std-ref">MultiGrid</span></a> method is based on the classic Ruge-Stueben coarsening with direct interpolation. The solver provides high-efficiency in terms of complexity of the solver (i.e. number of iterations). However, most of the time it has a higher building step and requires higher memory usage. stuben</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution14RugeStuebenAMG19SetCouplingStrengthE9ValueType">
<span id="_CPPv2N10rocalution14RugeStuebenAMG19SetCouplingStrengthE9ValueType"></span><span id="rocalution::RugeStuebenAMG::SetCouplingStrength__ValueType"></span><span class="target" id="classrocalution_1_1_ruge_stueben_a_m_g_1a20d71c64006c0d6008d6ce0fbdf58985"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution14RugeStuebenAMGE" title="rocalution::RugeStuebenAMG">RugeStuebenAMG</a><code class="descclassname">::</code></code><code class="descname">SetCouplingStrength</code><span class="sig-paren">(</span>ValueType <em>eps</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set coupling strength. </p>
</dd></dl>

<p>For further details, see <a href="#id46"><span class="problematic" id="id47">:cite:`stuben`</span></a>.</p>
</div>
<div class="section" id="pairwise-amg">
<h5>Pairwise AMG<a class="headerlink" href="#pairwise-amg" title="Permalink to this headline">¶</a></h5>
<dl class="class">
<dt id="_CPPv3N10rocalution11PairwiseAMGE">
<span id="_CPPv2N10rocalution11PairwiseAMGE"></span><span id="rocalution::PairwiseAMG"></span><span class="target" id="classrocalution_1_1_pairwise_a_m_g"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">PairwiseAMG</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution7BaseAMGE" title="rocalution::BaseAMG">BaseAMG</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Pairwise Aggregation Algebraic <a class="reference internal" href="#classrocalution_1_1_multi_grid"><span class="std std-ref">MultiGrid</span></a> Method. </p>
<p>The Pairwise Aggregation Algebraic <a class="reference internal" href="#classrocalution_1_1_multi_grid"><span class="std std-ref">MultiGrid</span></a> method is based on a pairwise aggregation matching scheme. It delivers very efficient building phase which is suitable for Poisson-like equation. Most of the time it requires K-cycle for the solving phase to provide low number of iterations. pairwiseamg</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N10rocalution17GlobalPairwiseAMGE">
<span id="_CPPv2N10rocalution17GlobalPairwiseAMGE"></span><span id="rocalution::GlobalPairwiseAMG"></span><span class="target" id="classrocalution_1_1_global_pairwise_a_m_g"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">GlobalPairwiseAMG</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution7BaseAMGE" title="rocalution::BaseAMG">BaseAMG</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Pairwise Aggregation Algebraic <a class="reference internal" href="#classrocalution_1_1_multi_grid"><span class="std std-ref">MultiGrid</span></a> Method (multi-node) </p>
<p>The Pairwise Aggregation Algebraic <a class="reference internal" href="#classrocalution_1_1_multi_grid"><span class="std std-ref">MultiGrid</span></a> method is based on a pairwise aggregation matching scheme. It delivers very efficient building phase which is suitable for Poisson-like equation. Most of the time it requires K-cycle for the solving phase to provide low number of iterations. This version has multi-node support. pairwiseamg</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_global_matrix"><span class="std std-ref">GlobalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_global_vector"><span class="std std-ref">GlobalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11PairwiseAMG7SetBetaE9ValueType">
<span id="_CPPv2N10rocalution11PairwiseAMG7SetBetaE9ValueType"></span><span id="rocalution::PairwiseAMG::SetBeta__ValueType"></span><span class="target" id="classrocalution_1_1_pairwise_a_m_g_1a6dc95d19d2c5fbee5350603310fad12f"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11PairwiseAMGE" title="rocalution::PairwiseAMG">PairwiseAMG</a><code class="descclassname">::</code></code><code class="descname">SetBeta</code><span class="sig-paren">(</span>ValueType <em>beta</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set beta for pairwise aggregation. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11PairwiseAMG11SetOrderingEj">
<span id="_CPPv2N10rocalution11PairwiseAMG11SetOrderingEj"></span><span id="rocalution::PairwiseAMG::SetOrdering__unsigned-i"></span><span class="target" id="classrocalution_1_1_pairwise_a_m_g_1a3a0227c2b228a0afb0a431dfea874b00"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11PairwiseAMGE" title="rocalution::PairwiseAMG">PairwiseAMG</a><code class="descclassname">::</code></code><code class="descname">SetOrdering</code><span class="sig-paren">(</span>unsigned int <em>ordering</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set re-ordering for aggregation. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11PairwiseAMG19SetCoarseningFactorEd">
<span id="_CPPv2N10rocalution11PairwiseAMG19SetCoarseningFactorEd"></span><span id="rocalution::PairwiseAMG::SetCoarseningFactor__double"></span><span class="target" id="classrocalution_1_1_pairwise_a_m_g_1ac4b383708d9957bca2a2c454f7707f17"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11PairwiseAMGE" title="rocalution::PairwiseAMG">PairwiseAMG</a><code class="descclassname">::</code></code><code class="descname">SetCoarseningFactor</code><span class="sig-paren">(</span>double <em>factor</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set target coarsening factor. </p>
</dd></dl>

<p>For further details, see <a href="#id48"><span class="problematic" id="id49">:cite:`pairwiseamg`</span></a>.</p>
</div>
</div>
</div>
<div class="section" id="direct-linear-solvers">
<h3>Direct Linear Solvers<a class="headerlink" href="#direct-linear-solvers" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv3N10rocalution18DirectLinearSolverE">
<span id="_CPPv2N10rocalution18DirectLinearSolverE"></span><span id="rocalution::DirectLinearSolver"></span><span class="target" id="classrocalution_1_1_direct_linear_solver"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">DirectLinearSolver</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution6SolverE" title="rocalution::Solver">Solver</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Base class for all direct linear solvers. </p>
<p>The library provides three direct methods - <a class="reference internal" href="#classrocalution_1_1_l_u"><span class="std std-ref">LU</span></a>, <a class="reference internal" href="#classrocalution_1_1_q_r"><span class="std std-ref">QR</span></a> and <a class="reference internal" href="#classrocalution_1_1_inversion"><span class="std std-ref">Inversion</span></a> (based on <a class="reference internal" href="#classrocalution_1_1_q_r"><span class="std std-ref">QR</span></a> decomposition). The user can pass a sparse matrix, internally it will be converted to dense and then the selected method will be applied. These methods are not very optimal and due to the fact that the matrix is converted to a dense format, these methods should be used only for very small matrices.</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
<p>Subclassed by <a class="reference internal" href="#classrocalution_1_1_inversion"><span class="std std-ref">rocalution::Inversion&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_l_u"><span class="std std-ref">rocalution::LU&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_q_r"><span class="std std-ref">rocalution::QR&lt; OperatorType, VectorType, ValueType &gt;</span></a></p>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N10rocalution2LUE">
<span id="_CPPv2N10rocalution2LUE"></span><span id="rocalution::LU"></span><span class="target" id="classrocalution_1_1_l_u"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">LU</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution18DirectLinearSolverE" title="rocalution::DirectLinearSolver">DirectLinearSolver</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p><a class="reference internal" href="#classrocalution_1_1_l_u"><span class="std std-ref">LU</span></a> Decomposition. </p>
<p>Lower-Upper Decomposition factors a given square matrix into lower and upper triangular matrix, such that <span class="math notranslate nohighlight">\(A = LU\)</span>.</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N10rocalution2QRE">
<span id="_CPPv2N10rocalution2QRE"></span><span id="rocalution::QR"></span><span class="target" id="classrocalution_1_1_q_r"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">QR</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution18DirectLinearSolverE" title="rocalution::DirectLinearSolver">DirectLinearSolver</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p><a class="reference internal" href="#classrocalution_1_1_q_r"><span class="std std-ref">QR</span></a> Decomposition. </p>
<p>The <a class="reference internal" href="#classrocalution_1_1_q_r"><span class="std std-ref">QR</span></a> Decomposition decomposes a given matrix into <span class="math notranslate nohighlight">\(A = QR\)</span>, such that <span class="math notranslate nohighlight">\(Q\)</span> is an orthogonal matrix and <span class="math notranslate nohighlight">\(R\)</span> an upper triangular matrix.</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N10rocalution9InversionE">
<span id="_CPPv2N10rocalution9InversionE"></span><span id="rocalution::Inversion"></span><span class="target" id="classrocalution_1_1_inversion"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">Inversion</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution18DirectLinearSolverE" title="rocalution::DirectLinearSolver">DirectLinearSolver</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Matrix <a class="reference internal" href="#classrocalution_1_1_inversion"><span class="std std-ref">Inversion</span></a>. </p>
<p>Full matrix inversion based on <a class="reference internal" href="#classrocalution_1_1_q_r"><span class="std std-ref">QR</span></a> decomposition.</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">These methods can only be used with local-type problems.</p>
</div>
</div>
</div>
<div class="section" id="preconditioners">
<h2>Preconditioners<a class="headerlink" href="#preconditioners" title="Permalink to this headline">¶</a></h2>
<p>In this chapter, all preconditioners are presented. All preconditioners support local operators. They can be used as a global preconditioner via block-jacobi scheme which works locally on each interior matrix. To provide fast application, all preconditioners require extra memory to keep the approximated operator.</p>
<dl class="class">
<dt id="_CPPv3N10rocalution14PreconditionerE">
<span id="_CPPv2N10rocalution14PreconditionerE"></span><span id="rocalution::Preconditioner"></span><span class="target" id="classrocalution_1_1_preconditioner"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">Preconditioner</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution6SolverE" title="rocalution::Solver">Solver</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Base class for all preconditioners. </p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> or <a class="reference internal" href="#classrocalution_1_1_global_matrix"><span class="std std-ref">GlobalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> or <a class="reference internal" href="#classrocalution_1_1_global_vector"><span class="std std-ref">GlobalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
<p>Subclassed by <a class="reference internal" href="#classrocalution_1_1_a_i_chebyshev"><span class="std std-ref">rocalution::AIChebyshev&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_a_s"><span class="std std-ref">rocalution::AS&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_block_jacobi"><span class="std std-ref">rocalution::BlockJacobi&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_block_preconditioner"><span class="std std-ref">rocalution::BlockPreconditioner&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_diag_jacobi_saddle_point_precond"><span class="std std-ref">rocalution::DiagJacobiSaddlePointPrecond&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_f_s_a_i"><span class="std std-ref">rocalution::FSAI&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_g_s"><span class="std std-ref">rocalution::GS&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_i_c"><span class="std std-ref">rocalution::IC&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_i_l_u"><span class="std std-ref">rocalution::ILU&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_i_l_u_t"><span class="std std-ref">rocalution::ILUT&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_jacobi"><span class="std std-ref">rocalution::Jacobi&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_multi_colored"><span class="std std-ref">rocalution::MultiColored&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_multi_elimination"><span class="std std-ref">rocalution::MultiElimination&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_s_g_s"><span class="std std-ref">rocalution::SGS&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_s_p_a_i"><span class="std std-ref">rocalution::SPAI&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_t_n_s"><span class="std std-ref">rocalution::TNS&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_variable_preconditioner"><span class="std std-ref">rocalution::VariablePreconditioner&lt; OperatorType, VectorType, ValueType &gt;</span></a></p>
</dd></dl>

<div class="section" id="id50">
<h3>Code Structure<a class="headerlink" href="#id50" title="Permalink to this headline">¶</a></h3>
<p>The preconditioners provide a solution to the system <span class="math notranslate nohighlight">\(Mz = r\)</span>, where either the solution <span class="math notranslate nohighlight">\(z\)</span> is directly computed by the approximation scheme or it is iteratively obtained with <span class="math notranslate nohighlight">\(z = 0\)</span> initial guess.</p>
</div>
<div class="section" id="jacobi-method">
<h3>Jacobi Method<a class="headerlink" href="#jacobi-method" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv3N10rocalution6JacobiE">
<span id="_CPPv2N10rocalution6JacobiE"></span><span id="rocalution::Jacobi"></span><span class="target" id="classrocalution_1_1_jacobi"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">Jacobi</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution14PreconditionerE" title="rocalution::Preconditioner">Preconditioner</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p><a class="reference internal" href="#classrocalution_1_1_jacobi"><span class="std std-ref">Jacobi</span></a> Method. </p>
<p>The <a class="reference internal" href="#classrocalution_1_1_jacobi"><span class="std std-ref">Jacobi</span></a> method is for solving a diagonally dominant system of linear equations <span class="math notranslate nohighlight">\(Ax=b\)</span>. It solves for each diagonal element iteratively until convergence, such that <div class="math notranslate nohighlight">
\[ x_{i}^{(k+1)} = (1 - \omega)x_{i}^{(k)} + \frac{\omega}{a_{ii}} \left( b_{i} - \sum\limits_{j=1}^{i-1}{a_{ij}x_{j}^{(k)}} - \sum\limits_{j=i}^{n}{a_{ij}x_{j}^{(k)}} \right) \]</div>
</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> or <a class="reference internal" href="#classrocalution_1_1_global_matrix"><span class="std std-ref">GlobalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> or <a class="reference internal" href="#classrocalution_1_1_global_vector"><span class="std std-ref">GlobalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Damping parameter <span class="math notranslate nohighlight">\(\omega\)</span> can be adjusted by <a class="reference internal" href="api.html#_CPPv3N10rocalution10FixedPoint13SetRelaxationE9ValueType" title="rocalution::FixedPoint::SetRelaxation"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::FixedPoint::SetRelaxation()</span></code></a>.</p>
</div>
</div>
<div class="section" id="symmetric-gauss-seidel-s-sor-method">
<h3>(Symmetric) Gauss-Seidel / (S)SOR Method<a class="headerlink" href="#symmetric-gauss-seidel-s-sor-method" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv3N10rocalution2GSE">
<span id="_CPPv2N10rocalution2GSE"></span><span id="rocalution::GS"></span><span class="target" id="classrocalution_1_1_g_s"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">GS</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution14PreconditionerE" title="rocalution::Preconditioner">Preconditioner</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Gauss-Seidel / Successive Over-Relaxation Method. </p>
<p>The Gauss-Seidel / SOR method is for solving system of linear equations <span class="math notranslate nohighlight">\(Ax=b\)</span>. It approximates the solution iteratively with <div class="math notranslate nohighlight">
\[ x_{i}^{(k+1)} = (1 - \omega) x_{i}^{(k)} + \frac{\omega}{a_{ii}} \left( b_{i} - \sum\limits_{j=1}^{i-1}{a_{ij}x_{j}^{(k+1)}} - \sum\limits_{j=i}^{n}{a_{ij}x_{j}^{(k)}} \right), \]</div>
 with <span class="math notranslate nohighlight">\(\omega \in (0,2)\)</span>.</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N10rocalution3SGSE">
<span id="_CPPv2N10rocalution3SGSE"></span><span id="rocalution::SGS"></span><span class="target" id="classrocalution_1_1_s_g_s"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">SGS</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution14PreconditionerE" title="rocalution::Preconditioner">Preconditioner</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Symmetric Gauss-Seidel / Symmetric Successive Over-Relaxation Method. </p>
<p>The Symmetric Gauss-Seidel / SSOR method is for solving system of linear equations <span class="math notranslate nohighlight">\(Ax=b\)</span>. It approximates the solution iteratively.</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Relaxation parameter <span class="math notranslate nohighlight">\(\omega\)</span> can be adjusted by <a class="reference internal" href="api.html#_CPPv3N10rocalution10FixedPoint13SetRelaxationE9ValueType" title="rocalution::FixedPoint::SetRelaxation"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::FixedPoint::SetRelaxation()</span></code></a>.</p>
</div>
</div>
<div class="section" id="incomplete-factorizations">
<h3>Incomplete Factorizations<a class="headerlink" href="#incomplete-factorizations" title="Permalink to this headline">¶</a></h3>
<div class="section" id="ilu">
<h4>ILU<a class="headerlink" href="#ilu" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv3N10rocalution3ILUE">
<span id="_CPPv2N10rocalution3ILUE"></span><span id="rocalution::ILU"></span><span class="target" id="classrocalution_1_1_i_l_u"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">ILU</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution14PreconditionerE" title="rocalution::Preconditioner">Preconditioner</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Incomplete <a class="reference internal" href="#classrocalution_1_1_l_u"><span class="std std-ref">LU</span></a> Factorization based on levels. </p>
<p>The Incomplete <a class="reference internal" href="#classrocalution_1_1_l_u"><span class="std std-ref">LU</span></a> Factorization based on levels computes a sparse lower and sparse upper triangular matrix such that <span class="math notranslate nohighlight">\(A = LU - R\)</span>.</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution3ILU3SetEib">
<span id="_CPPv2N10rocalution3ILU3SetEib"></span><span id="rocalution::ILU::Set__i.b"></span><span class="target" id="classrocalution_1_1_i_l_u_1ad4e4160e6277870985110fbd479ed670"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution3ILUE" title="rocalution::ILU">ILU</a><code class="descclassname">::</code></code><code class="descname">Set</code><span class="sig-paren">(</span>int <em>p</em>, bool <em>level</em> = true<span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize ILU(p) factorization. </p>
<p>Initialize ILU(p) factorization based on power. SAAD<ul class="simple">
<li>level = true build the structure based on levels</li>
<li>level = false build the structure only based on the power(p+1) </li>
</ul>
</p>
</dd></dl>

<p>For further details, see <a href="#id51"><span class="problematic" id="id52">:cite:`SAAD`</span></a>.</p>
</div>
<div class="section" id="ilut">
<h4>ILUT<a class="headerlink" href="#ilut" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv3N10rocalution4ILUTE">
<span id="_CPPv2N10rocalution4ILUTE"></span><span id="rocalution::ILUT"></span><span class="target" id="classrocalution_1_1_i_l_u_t"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">ILUT</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution14PreconditionerE" title="rocalution::Preconditioner">Preconditioner</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Incomplete <a class="reference internal" href="#classrocalution_1_1_l_u"><span class="std std-ref">LU</span></a> Factorization based on threshold. </p>
<p>The Incomplete <a class="reference internal" href="#classrocalution_1_1_l_u"><span class="std std-ref">LU</span></a> Factorization based on threshold computes a sparse lower and sparse upper triangular matrix such that <span class="math notranslate nohighlight">\(A = LU - R\)</span>. Fill-in values are dropped depending on a threshold and number of maximal fill-ins per row. SAAD</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution4ILUT3SetEd">
<span id="_CPPv2N10rocalution4ILUT3SetEd"></span><span id="rocalution::ILUT::Set__double"></span><span class="target" id="classrocalution_1_1_i_l_u_t_1aeb87440eca213964f7e226d8a6fa9f8a"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution4ILUTE" title="rocalution::ILUT">ILUT</a><code class="descclassname">::</code></code><code class="descname">Set</code><span class="sig-paren">(</span>double <em>t</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set drop-off threshold. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution4ILUT3SetEdi">
<span id="_CPPv2N10rocalution4ILUT3SetEdi"></span><span id="rocalution::ILUT::Set__double.i"></span><span class="target" id="classrocalution_1_1_i_l_u_t_1af8c3d02dd76842598f6e4f7b6a625598"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution4ILUTE" title="rocalution::ILUT">ILUT</a><code class="descclassname">::</code></code><code class="descname">Set</code><span class="sig-paren">(</span>double <em>t</em>, int <em>maxrow</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set drop-off threshold and maximum fill-ins per row. </p>
</dd></dl>

<p>For further details, see <a href="#id53"><span class="problematic" id="id54">:cite:`SAAD`</span></a>.</p>
</div>
<div class="section" id="ic">
<h4>IC<a class="headerlink" href="#ic" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv3N10rocalution2ICE">
<span id="_CPPv2N10rocalution2ICE"></span><span id="rocalution::IC"></span><span class="target" id="classrocalution_1_1_i_c"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">IC</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution14PreconditionerE" title="rocalution::Preconditioner">Preconditioner</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Incomplete Cholesky Factorization without fill-ins. </p>
<p>The Incomplete Cholesky Factorization computes a sparse lower triangular matrix such that <span class="math notranslate nohighlight">\(A=LL^{T} - R\)</span>. Additional fill-ins are dropped and the sparsity pattern of the original matrix is preserved.</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</div>
<div class="section" id="ai-chebyshev">
<h3>AI Chebyshev<a class="headerlink" href="#ai-chebyshev" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv3N10rocalution11AIChebyshevE">
<span id="_CPPv2N10rocalution11AIChebyshevE"></span><span id="rocalution::AIChebyshev"></span><span class="target" id="classrocalution_1_1_a_i_chebyshev"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">AIChebyshev</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution14PreconditionerE" title="rocalution::Preconditioner">Preconditioner</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Approximate Inverse - <a class="reference internal" href="#classrocalution_1_1_chebyshev"><span class="std std-ref">Chebyshev</span></a> <a class="reference internal" href="#classrocalution_1_1_preconditioner"><span class="std std-ref">Preconditioner</span></a>. </p>
<p>The Approximate Inverse - <a class="reference internal" href="#classrocalution_1_1_chebyshev"><span class="std std-ref">Chebyshev</span></a> <a class="reference internal" href="#classrocalution_1_1_preconditioner"><span class="std std-ref">Preconditioner</span></a> is an inverse matrix preconditioner with values from a linear combination of matrix-valued <a class="reference internal" href="#classrocalution_1_1_chebyshev"><span class="std std-ref">Chebyshev</span></a> polynomials. chebpoly</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11AIChebyshev3SetEi9ValueType9ValueType">
<span id="_CPPv2N10rocalution11AIChebyshev3SetEi9ValueType9ValueType"></span><span id="rocalution::AIChebyshev::Set__i.ValueType.ValueType"></span><span class="target" id="classrocalution_1_1_a_i_chebyshev_1ae116b80069f8757508ba15b478f32d5b"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11AIChebyshevE" title="rocalution::AIChebyshev">AIChebyshev</a><code class="descclassname">::</code></code><code class="descname">Set</code><span class="sig-paren">(</span>int <em>p</em>, ValueType <em>lambda_min</em>, ValueType <em>lambda_max</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set order, min and max eigenvalues. </p>
</dd></dl>

<p>For further details, see <a href="#id55"><span class="problematic" id="id56">:cite:`chebpoly`</span></a>.</p>
</div>
<div class="section" id="fsai">
<h3>FSAI<a class="headerlink" href="#fsai" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv3N10rocalution4FSAIE">
<span id="_CPPv2N10rocalution4FSAIE"></span><span id="rocalution::FSAI"></span><span class="target" id="classrocalution_1_1_f_s_a_i"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">FSAI</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution14PreconditionerE" title="rocalution::Preconditioner">Preconditioner</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Factorized Approximate Inverse <a class="reference internal" href="#classrocalution_1_1_preconditioner"><span class="std std-ref">Preconditioner</span></a>. </p>
<p>The Factorized Sparse Approximate Inverse preconditioner computes a direct approximation of <span class="math notranslate nohighlight">\(M^{-1}\)</span> by minimizing the Frobenius norm <span class="math notranslate nohighlight">\(||I − GL||_{F}\)</span>, where <span class="math notranslate nohighlight">\(L\)</span> denotes the exact lower triangular part of <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(G:=M^{-1}\)</span>. The <a class="reference internal" href="#classrocalution_1_1_f_s_a_i"><span class="std std-ref">FSAI</span></a> preconditioner is initialized by <span class="math notranslate nohighlight">\(q\)</span>, based on the sparsity pattern of <span class="math notranslate nohighlight">\(|A^{q}|\)</span>. However, it is also possible to supply external sparsity patterns in form of the <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> class. kolotilina</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The <a class="reference internal" href="#classrocalution_1_1_f_s_a_i"><span class="std std-ref">FSAI</span></a> preconditioner is only suited for symmetric positive definite matrices.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution4FSAI3SetEi">
<span id="_CPPv2N10rocalution4FSAI3SetEi"></span><span id="rocalution::FSAI::Set__i"></span><span class="target" id="classrocalution_1_1_f_s_a_i_1ae02e8110161e34558861c7b307b4c286"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution4FSAIE" title="rocalution::FSAI">FSAI</a><code class="descclassname">::</code></code><code class="descname">Set</code><span class="sig-paren">(</span>int <em>power</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the power of the system matrix sparsity pattern. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution4FSAI3SetERK12OperatorType">
<span id="_CPPv2N10rocalution4FSAI3SetERK12OperatorType"></span><span id="rocalution::FSAI::Set__OperatorTypeCR"></span><span class="target" id="classrocalution_1_1_f_s_a_i_1ae39d0ddfea02610a76c09ac6b0e0d738"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution4FSAIE" title="rocalution::FSAI">FSAI</a><code class="descclassname">::</code></code><code class="descname">Set</code><span class="sig-paren">(</span><em class="property">const</em> OperatorType &amp;<em>pattern</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set an external sparsity pattern. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution4FSAI22SetPrecondMatrixFormatEj">
<span id="_CPPv2N10rocalution4FSAI22SetPrecondMatrixFormatEj"></span><span id="rocalution::FSAI::SetPrecondMatrixFormat__unsigned-i"></span><span class="target" id="classrocalution_1_1_f_s_a_i_1a8ee271df7007285accc0ed3db03552fc"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution4FSAIE" title="rocalution::FSAI">FSAI</a><code class="descclassname">::</code></code><code class="descname">SetPrecondMatrixFormat</code><span class="sig-paren">(</span>unsigned int <em>mat_format</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the matrix format of the preconditioner. </p>
</dd></dl>

<p>For further details, see <a href="#id57"><span class="problematic" id="id58">:cite:`kolotilina`</span></a>.</p>
</div>
<div class="section" id="spai">
<h3>SPAI<a class="headerlink" href="#spai" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv3N10rocalution4SPAIE">
<span id="_CPPv2N10rocalution4SPAIE"></span><span id="rocalution::SPAI"></span><span class="target" id="classrocalution_1_1_s_p_a_i"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">SPAI</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution14PreconditionerE" title="rocalution::Preconditioner">Preconditioner</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>SParse Approximate Inverse <a class="reference internal" href="#classrocalution_1_1_preconditioner"><span class="std std-ref">Preconditioner</span></a>. </p>
<p>The SParse Approximate Inverse algorithm is an explicitly computed preconditioner for general sparse linear systems. In its current implementation, only the sparsity pattern of the system matrix is supported. The <a class="reference internal" href="#classrocalution_1_1_s_p_a_i"><span class="std std-ref">SPAI</span></a> computation is based on the minimization of the Frobenius norm <span class="math notranslate nohighlight">\(||AM − I||_{F}\)</span>. grote</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution4SPAI22SetPrecondMatrixFormatEj">
<span id="_CPPv2N10rocalution4SPAI22SetPrecondMatrixFormatEj"></span><span id="rocalution::SPAI::SetPrecondMatrixFormat__unsigned-i"></span><span class="target" id="classrocalution_1_1_s_p_a_i_1a20d070e44f7f64197ad9bb1c56d3d6c7"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution4SPAIE" title="rocalution::SPAI">SPAI</a><code class="descclassname">::</code></code><code class="descname">SetPrecondMatrixFormat</code><span class="sig-paren">(</span>unsigned int <em>mat_format</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the matrix format of the preconditioner. </p>
</dd></dl>

<p>For further details, see <a href="#id59"><span class="problematic" id="id60">:cite:`grote`</span></a>.</p>
</div>
<div class="section" id="tns">
<h3>TNS<a class="headerlink" href="#tns" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv3N10rocalution3TNSE">
<span id="_CPPv2N10rocalution3TNSE"></span><span id="rocalution::TNS"></span><span class="target" id="classrocalution_1_1_t_n_s"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">TNS</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution14PreconditionerE" title="rocalution::Preconditioner">Preconditioner</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Truncated Neumann Series <a class="reference internal" href="#classrocalution_1_1_preconditioner"><span class="std std-ref">Preconditioner</span></a>. </p>
<p>The Truncated Neumann Series (<a class="reference internal" href="#classrocalution_1_1_t_n_s"><span class="std std-ref">TNS</span></a>) preconditioner is based on <span class="math notranslate nohighlight">\(M^{-1} = K^{T} D^{-1} K\)</span>, where <span class="math notranslate nohighlight">\(K=(I-LD^{-1}+(LD^{-1})^{2})\)</span>, with the diagonal <span class="math notranslate nohighlight">\(D\)</span> of <span class="math notranslate nohighlight">\(A\)</span> and the strictly lower triangular part <span class="math notranslate nohighlight">\(L\)</span> of <span class="math notranslate nohighlight">\(A\)</span>. The preconditioner can be computed in two forms - explicitly and implicitly. In the implicit form, the full construction of <span class="math notranslate nohighlight">\(M\)</span> is performed via matrix-matrix operations, whereas in the explicit from, the application of the preconditioner is based on matrix-vector operations only. The matrix format for the stored matrices can be specified.</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution3TNS3SetEb">
<span id="_CPPv2N10rocalution3TNS3SetEb"></span><span id="rocalution::TNS::Set__b"></span><span class="target" id="classrocalution_1_1_t_n_s_1ac7ebac11443d6fab77dd0c05c77c8860"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution3TNSE" title="rocalution::TNS">TNS</a><code class="descclassname">::</code></code><code class="descname">Set</code><span class="sig-paren">(</span>bool <em>imp</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set implicit (true) or explicit (false) computation. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution3TNS22SetPrecondMatrixFormatEj">
<span id="_CPPv2N10rocalution3TNS22SetPrecondMatrixFormatEj"></span><span id="rocalution::TNS::SetPrecondMatrixFormat__unsigned-i"></span><span class="target" id="classrocalution_1_1_t_n_s_1ac8e54cad485a413740d44543bacbc497"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution3TNSE" title="rocalution::TNS">TNS</a><code class="descclassname">::</code></code><code class="descname">SetPrecondMatrixFormat</code><span class="sig-paren">(</span>unsigned int <em>mat_format</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the matrix format of the preconditioner. </p>
</dd></dl>

</div>
<div class="section" id="multicolored-preconditioners">
<h3>MultiColored Preconditioners<a class="headerlink" href="#multicolored-preconditioners" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv3N10rocalution12MultiColoredE">
<span id="_CPPv2N10rocalution12MultiColoredE"></span><span id="rocalution::MultiColored"></span><span class="target" id="classrocalution_1_1_multi_colored"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">MultiColored</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution14PreconditionerE" title="rocalution::Preconditioner">Preconditioner</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Base class for all multi-colored preconditioners. </p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
<p>Subclassed by <a class="reference internal" href="#classrocalution_1_1_multi_colored_i_l_u"><span class="std std-ref">rocalution::MultiColoredILU&lt; OperatorType, VectorType, ValueType &gt;</span></a>, <a class="reference internal" href="#classrocalution_1_1_multi_colored_s_g_s"><span class="std std-ref">rocalution::MultiColoredSGS&lt; OperatorType, VectorType, ValueType &gt;</span></a></p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution12MultiColored22SetPrecondMatrixFormatEj">
<span id="_CPPv2N10rocalution12MultiColored22SetPrecondMatrixFormatEj"></span><span id="rocalution::MultiColored::SetPrecondMatrixFormat__unsigned-i"></span><span class="target" id="classrocalution_1_1_multi_colored_1a62aa6b45c0c1cd0945f1283889403bcc"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution12MultiColoredE" title="rocalution::MultiColored">MultiColored</a><code class="descclassname">::</code></code><code class="descname">SetPrecondMatrixFormat</code><span class="sig-paren">(</span>unsigned int <em>mat_format</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set a specific matrix type of the decomposed block matrices. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution12MultiColored16SetDecompositionEb">
<span id="_CPPv2N10rocalution12MultiColored16SetDecompositionEb"></span><span id="rocalution::MultiColored::SetDecomposition__b"></span><span class="target" id="classrocalution_1_1_multi_colored_1afc5e5067e7d904f2dbcf1e3f786cb1c1"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution12MultiColoredE" title="rocalution::MultiColored">MultiColored</a><code class="descclassname">::</code></code><code class="descname">SetDecomposition</code><span class="sig-paren">(</span>bool <em>decomp</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set if the preconditioner should be decomposed or not. </p>
</dd></dl>

<div class="section" id="multicolored-symmetric-gauss-seidel-s-sor">
<h4>MultiColored (Symmetric) Gauss-Seidel / (S)SOR<a class="headerlink" href="#multicolored-symmetric-gauss-seidel-s-sor" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv3N10rocalution14MultiColoredGSE">
<span id="_CPPv2N10rocalution14MultiColoredGSE"></span><span id="rocalution::MultiColoredGS"></span><span class="target" id="classrocalution_1_1_multi_colored_g_s"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">MultiColoredGS</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution15MultiColoredSGSE" title="rocalution::MultiColoredSGS">MultiColoredSGS</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Multi-Colored Gauss-Seidel / SOR <a class="reference internal" href="#classrocalution_1_1_preconditioner"><span class="std std-ref">Preconditioner</span></a>. </p>
<p>The Multi-Colored Symmetric Gauss-Seidel / SOR preconditioner is based on the splitting of the original matrix. Higher parallelism in solving the forward substitution is obtained by performing a multi-colored decomposition. Details on the Gauss-Seidel / SOR algorithm can be found in the <a class="reference internal" href="#classrocalution_1_1_g_s"><span class="std std-ref">GS</span></a> preconditioner.</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N10rocalution15MultiColoredSGSE">
<span id="_CPPv2N10rocalution15MultiColoredSGSE"></span><span id="rocalution::MultiColoredSGS"></span><span class="target" id="classrocalution_1_1_multi_colored_s_g_s"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">MultiColoredSGS</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution12MultiColoredE" title="rocalution::MultiColored">MultiColored</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Multi-Colored Symmetric Gauss-Seidel / SSOR <a class="reference internal" href="#classrocalution_1_1_preconditioner"><span class="std std-ref">Preconditioner</span></a>. </p>
<p>The Multi-Colored Symmetric Gauss-Seidel / SSOR preconditioner is based on the splitting of the original matrix. Higher parallelism in solving the forward and backward substitution is obtained by performing a multi-colored decomposition. Details on the Symmetric Gauss-Seidel / SSOR algorithm can be found in the <a class="reference internal" href="#classrocalution_1_1_s_g_s"><span class="std std-ref">SGS</span></a> preconditioner.</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
<p>Subclassed by <a class="reference internal" href="#classrocalution_1_1_multi_colored_g_s"><span class="std std-ref">rocalution::MultiColoredGS&lt; OperatorType, VectorType, ValueType &gt;</span></a></p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution15MultiColoredSGS13SetRelaxationE9ValueType">
<span id="_CPPv2N10rocalution15MultiColoredSGS13SetRelaxationE9ValueType"></span><span id="rocalution::MultiColoredSGS::SetRelaxation__ValueType"></span><span class="target" id="classrocalution_1_1_multi_colored_s_g_s_1ae876aae50f9b6e676e2ee77802303c15"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution15MultiColoredSGSE" title="rocalution::MultiColoredSGS">MultiColoredSGS</a><code class="descclassname">::</code></code><code class="descname">SetRelaxation</code><span class="sig-paren">(</span>ValueType <em>omega</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the relaxation parameter for the SOR/SSOR scheme. </p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The preconditioner matrix format can be changed using <a class="reference internal" href="api.html#_CPPv3N10rocalution12MultiColored22SetPrecondMatrixFormatEj" title="rocalution::MultiColored::SetPrecondMatrixFormat"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::MultiColored::SetPrecondMatrixFormat()</span></code></a>.</p>
</div>
</div>
<div class="section" id="multicolored-power-q-pattern-method-ilu-p-q">
<h4>MultiColored Power(q)-pattern method ILU(p,q)<a class="headerlink" href="#multicolored-power-q-pattern-method-ilu-p-q" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="_CPPv3N10rocalution15MultiColoredILUE">
<span id="_CPPv2N10rocalution15MultiColoredILUE"></span><span id="rocalution::MultiColoredILU"></span><span class="target" id="classrocalution_1_1_multi_colored_i_l_u"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">MultiColoredILU</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution12MultiColoredE" title="rocalution::MultiColored">MultiColored</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Multi-Colored Incomplete <a class="reference internal" href="#classrocalution_1_1_l_u"><span class="std std-ref">LU</span></a> Factorization <a class="reference internal" href="#classrocalution_1_1_preconditioner"><span class="std std-ref">Preconditioner</span></a>. </p>
<p>Multi-Colored Incomplete <a class="reference internal" href="#classrocalution_1_1_l_u"><span class="std std-ref">LU</span></a> Factorization based on the ILU(p) factorization with a power(q)-pattern method. This method provides a higher degree of parallelism of forward and backward substitution compared to the standard ILU(p) preconditioner. Lukarski2012</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution15MultiColoredILU3SetEi">
<span id="_CPPv2N10rocalution15MultiColoredILU3SetEi"></span><span id="rocalution::MultiColoredILU::Set__i"></span><span class="target" id="classrocalution_1_1_multi_colored_i_l_u_1acd59157d2ba766220e500bc76aaabab0"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution15MultiColoredILUE" title="rocalution::MultiColoredILU">MultiColoredILU</a><code class="descclassname">::</code></code><code class="descname">Set</code><span class="sig-paren">(</span>int <em>p</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize a multi-colored <a class="reference internal" href="#classrocalution_1_1_i_l_u"><span class="std std-ref">ILU</span></a>(p, p+1) preconditioner. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution15MultiColoredILU3SetEiib">
<span id="_CPPv2N10rocalution15MultiColoredILU3SetEiib"></span><span id="rocalution::MultiColoredILU::Set__i.i.b"></span><span class="target" id="classrocalution_1_1_multi_colored_i_l_u_1a451c62d8cc9a04b9708465f31b652e27"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution15MultiColoredILUE" title="rocalution::MultiColoredILU">MultiColoredILU</a><code class="descclassname">::</code></code><code class="descname">Set</code><span class="sig-paren">(</span>int <em>p</em>, int <em>q</em>, bool <em>level</em> = true<span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize a multi-colored ILU(p, q) preconditioner. </p>
<p>level = true will perform the factorization with levels <p> level = false will perform the factorization only on the power(q)-pattern </p>
</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The preconditioner matrix format can be changed using <a class="reference internal" href="api.html#_CPPv3N10rocalution12MultiColored22SetPrecondMatrixFormatEj" title="rocalution::MultiColored::SetPrecondMatrixFormat"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::MultiColored::SetPrecondMatrixFormat()</span></code></a>.</p>
</div>
<p>For further details, see <a href="#id61"><span class="problematic" id="id62">:cite:`Lukarski2012`</span></a>.</p>
</div>
</div>
<div class="section" id="multi-elimination-incomplete-lu">
<h3>Multi-Elimination Incomplete LU<a class="headerlink" href="#multi-elimination-incomplete-lu" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv3N10rocalution16MultiEliminationE">
<span id="_CPPv2N10rocalution16MultiEliminationE"></span><span id="rocalution::MultiElimination"></span><span class="target" id="classrocalution_1_1_multi_elimination"></span><em class="property">template </em>&lt;class <em>OperatorType</em>, class <em>VectorType</em>, typename <em>ValueType</em>&gt;<br /><em class="property">class </em><code class="descname">MultiElimination</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution14PreconditionerE" title="rocalution::Preconditioner">Preconditioner</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Multi-Elimination Incomplete <a class="reference internal" href="#classrocalution_1_1_l_u"><span class="std std-ref">LU</span></a> Factorization <a class="reference internal" href="#classrocalution_1_1_preconditioner"><span class="std std-ref">Preconditioner</span></a>. </p>
<p>The Multi-Elimination Incomplete <a class="reference internal" href="#classrocalution_1_1_l_u"><span class="std std-ref">LU</span></a> preconditioner is based on the following decomposition <div class="math notranslate nohighlight">
\[\begin{split} A = \begin{pmatrix} D &amp; F \\ E &amp; C \end{pmatrix} = \begin{pmatrix} I &amp; 0 \\ ED^{-1} &amp; I \end{pmatrix} \times \begin{pmatrix} D &amp; F \\ 0 &amp; \hat{A} \end{pmatrix}, \end{split}\]</div>
 where <span class="math notranslate nohighlight">\(\hat{A} = C - ED^{-1} F\)</span>. To make the inversion of <span class="math notranslate nohighlight">\(D\)</span> easier, we permute the preconditioning before the factorization with a permutation <span class="math notranslate nohighlight">\(P\)</span> to obtain only diagonal elements in <span class="math notranslate nohighlight">\(D\)</span>. The permutation here is based on a maximal independent set. This procedure can be applied to the block matrix <span class="math notranslate nohighlight">\(\hat{A}\)</span>, in this way we can perform the factorization recursively. In the last level of the recursion, we need to provide a solution procedure. By the design of the library, this can be any kind of solver. SAAD</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK10rocalution16MultiElimination16GetSizeDiagBlockEv">
<span id="_CPPv2NK10rocalution16MultiElimination16GetSizeDiagBlockEv"></span><span id="rocalution::MultiElimination::GetSizeDiagBlock__voidC"></span><span class="target" id="classrocalution_1_1_multi_elimination_1a1e477e9f38017bea89d7d022d0a5ce0f"></span>int <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution16MultiEliminationE" title="rocalution::MultiElimination">MultiElimination</a><code class="descclassname">::</code></code><code class="descname">GetSizeDiagBlock</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>Returns the size of the first (diagonal) block of the preconditioner. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK10rocalution16MultiElimination8GetLevelEv">
<span id="_CPPv2NK10rocalution16MultiElimination8GetLevelEv"></span><span id="rocalution::MultiElimination::GetLevel__voidC"></span><span class="target" id="classrocalution_1_1_multi_elimination_1ad9da13d305752da8c082d75d3ee477db"></span>int <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution16MultiEliminationE" title="rocalution::MultiElimination">MultiElimination</a><code class="descclassname">::</code></code><code class="descname">GetLevel</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd><p>Return the depth of the current level. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution16MultiElimination3SetER6SolverI12OperatorType10VectorType9ValueTypeEid">
<span id="_CPPv2N10rocalution16MultiElimination3SetER6SolverI12OperatorType10VectorType9ValueTypeEid"></span><span id="rocalution::MultiElimination::Set__Solver:OperatorType.VectorType.ValueType:R.i.double"></span><span class="target" id="classrocalution_1_1_multi_elimination_1a332a7c50fb62ccb9631f58b881acb621"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution16MultiEliminationE" title="rocalution::MultiElimination">MultiElimination</a><code class="descclassname">::</code></code><code class="descname">Set</code><span class="sig-paren">(</span><a class="reference internal" href="api.html#_CPPv3N10rocalution6SolverE" title="rocalution::Solver">Solver</a>&lt;OperatorType, VectorType, ValueType&gt; &amp;<em>AA_Solver</em>, int <em>level</em>, double <em>drop_off</em> = 0.0<span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize (recursively) ME-ILU with level (depth of recursion) </p>
<p>AA_Solvers - defines the last-block solver <p> drop_off - defines drop-off tolerance </p>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution16MultiElimination22SetPrecondMatrixFormatEj">
<span id="_CPPv2N10rocalution16MultiElimination22SetPrecondMatrixFormatEj"></span><span id="rocalution::MultiElimination::SetPrecondMatrixFormat__unsigned-i"></span><span class="target" id="classrocalution_1_1_multi_elimination_1a6ec26a31af3b2b142bc67af672ca0c9d"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution16MultiEliminationE" title="rocalution::MultiElimination">MultiElimination</a><code class="descclassname">::</code></code><code class="descname">SetPrecondMatrixFormat</code><span class="sig-paren">(</span>unsigned int <em>mat_format</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set a specific matrix type of the decomposed block matrices. </p>
</dd></dl>

<p>For further details, see <a href="#id63"><span class="problematic" id="id64">:cite:`SAAD`</span></a>.</p>
</div>
<div class="section" id="diagonal-preconditioner-for-saddle-point-problems">
<h3>Diagonal Preconditioner for Saddle-Point Problems<a class="headerlink" href="#diagonal-preconditioner-for-saddle-point-problems" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv3N10rocalution28DiagJacobiSaddlePointPrecondE">
<span id="_CPPv2N10rocalution28DiagJacobiSaddlePointPrecondE"></span><span id="rocalution::DiagJacobiSaddlePointPrecond"></span><span class="target" id="classrocalution_1_1_diag_jacobi_saddle_point_precond"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">DiagJacobiSaddlePointPrecond</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution14PreconditionerE" title="rocalution::Preconditioner">Preconditioner</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Diagonal <a class="reference internal" href="#classrocalution_1_1_preconditioner"><span class="std std-ref">Preconditioner</span></a> for Saddle-Point Problems. </p>
<p>Consider the following saddle-point problem <div class="math notranslate nohighlight">
\[\begin{split} A = \begin{pmatrix} K &amp; F \\ E &amp; 0 \end{pmatrix}. \end{split}\]</div>
 For such problems we can construct a diagonal Jacobi-type preconditioner of type <div class="math notranslate nohighlight">
\[\begin{split} P = \begin{pmatrix} K &amp; 0 \\ 0 &amp; S \end{pmatrix}, \end{split}\]</div>
 with <span class="math notranslate nohighlight">\(S=ED^{-1}F\)</span>, where <span class="math notranslate nohighlight">\(D\)</span> are the diagonal elements of <span class="math notranslate nohighlight">\(K\)</span>. The matrix <span class="math notranslate nohighlight">\(S\)</span> is fully constructed (via sparse matrix-matrix multiplication). The preconditioner needs to be initialized with two external solvers/preconditioners - one for the matrix <span class="math notranslate nohighlight">\(K\)</span> and one for the matrix <span class="math notranslate nohighlight">\(S\)</span>.</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution28DiagJacobiSaddlePointPrecond3SetER6SolverI12OperatorType10VectorType9ValueTypeER6SolverI12OperatorType10VectorType9ValueTypeE">
<span id="_CPPv2N10rocalution28DiagJacobiSaddlePointPrecond3SetER6SolverI12OperatorType10VectorType9ValueTypeER6SolverI12OperatorType10VectorType9ValueTypeE"></span><span id="rocalution::DiagJacobiSaddlePointPrecond::Set__Solver:OperatorType.VectorType.ValueType:R.Solver:OperatorType.VectorType.ValueType:R"></span><span class="target" id="classrocalution_1_1_diag_jacobi_saddle_point_precond_1a565eeff2293d71a97b9fd1d00423945e"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution28DiagJacobiSaddlePointPrecondE" title="rocalution::DiagJacobiSaddlePointPrecond">DiagJacobiSaddlePointPrecond</a><code class="descclassname">::</code></code><code class="descname">Set</code><span class="sig-paren">(</span><a class="reference internal" href="api.html#_CPPv3N10rocalution6SolverE" title="rocalution::Solver">Solver</a>&lt;OperatorType, VectorType, ValueType&gt; &amp;<em>K_Solver</em>, <a class="reference internal" href="api.html#_CPPv3N10rocalution6SolverE" title="rocalution::Solver">Solver</a>&lt;OperatorType, VectorType, ValueType&gt; &amp;<em>S_Solver</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Initialize solver for <span class="math notranslate nohighlight">\(K\)</span> and <span class="math notranslate nohighlight">\(S\)</span>. </p>
</dd></dl>

</div>
<div class="section" id="restricted-additive-schwarz-preconditioner">
<h3>(Restricted) Additive Schwarz Preconditioner<a class="headerlink" href="#restricted-additive-schwarz-preconditioner" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv3N10rocalution2ASE">
<span id="_CPPv2N10rocalution2ASE"></span><span id="rocalution::AS"></span><span class="target" id="classrocalution_1_1_a_s"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">AS</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution14PreconditionerE" title="rocalution::Preconditioner">Preconditioner</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Additive Schwarz <a class="reference internal" href="#classrocalution_1_1_preconditioner"><span class="std std-ref">Preconditioner</span></a>. </p>
<p>The Additive Schwarz preconditioner relies on a preconditioning technique, where the linear system <span class="math notranslate nohighlight">\(Ax=b\)</span> can be decomposed into small sub-problems based on <span class="math notranslate nohighlight">\(A_{i} = R_{i}^{T}AR_{i}\)</span>, where <span class="math notranslate nohighlight">\(R_{i}\)</span> are restriction operators. Those restriction operators produce sub-matrices wich overlap. This leads to contributions from two preconditioners on the overlapped area which are scaled by <span class="math notranslate nohighlight">\(1/2\)</span>. RAS</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
<p>Subclassed by <a class="reference internal" href="#classrocalution_1_1_r_a_s"><span class="std std-ref">rocalution::RAS&lt; OperatorType, VectorType, ValueType &gt;</span></a></p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution2AS3SetEiiPP6SolverI12OperatorType10VectorType9ValueTypeE">
<span id="_CPPv2N10rocalution2AS3SetEiiPP6SolverI12OperatorType10VectorType9ValueTypeE"></span><span id="rocalution::AS::Set__i.i.Solver:OperatorType.VectorType.ValueType:PP"></span><span class="target" id="classrocalution_1_1_a_s_1ae9fb0702e70b520204b4c56459a48076"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution2ASE" title="rocalution::AS">AS</a><code class="descclassname">::</code></code><code class="descname">Set</code><span class="sig-paren">(</span>int <em>nb</em>, int <em>overlap</em>, <a class="reference internal" href="api.html#_CPPv3N10rocalution6SolverE" title="rocalution::Solver">Solver</a>&lt;OperatorType, VectorType, ValueType&gt; **<em>preconds</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set number of blocks, overlap and array of preconditioners. </p>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N10rocalution3RASE">
<span id="_CPPv2N10rocalution3RASE"></span><span id="rocalution::RAS"></span><span class="target" id="classrocalution_1_1_r_a_s"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">RAS</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution2ASE" title="rocalution::AS">AS</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Restricted Additive Schwarz <a class="reference internal" href="#classrocalution_1_1_preconditioner"><span class="std std-ref">Preconditioner</span></a>. </p>
<p>The Restricted Additive Schwarz preconditioner relies on a preconditioning technique, where the linear system <span class="math notranslate nohighlight">\(Ax=b\)</span> can be decomposed into small sub-problems based on <span class="math notranslate nohighlight">\(A_{i} = R_{i}^{T}AR_{i}\)</span>, where <span class="math notranslate nohighlight">\(R_{i}\)</span> are restriction operators. The <a class="reference internal" href="#classrocalution_1_1_r_a_s"><span class="std std-ref">RAS</span></a> method is a mixture of block <a class="reference internal" href="#classrocalution_1_1_jacobi"><span class="std std-ref">Jacobi</span></a> and the <a class="reference internal" href="#classrocalution_1_1_a_s"><span class="std std-ref">AS</span></a> scheme. In this case, the sub-matrices contain overlapped areas from other blocks, too. RAS</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<p>The overlapped area is shown in <code class="xref std std-numref docutils literal notranslate"><span class="pre">AS</span></code>.</p>
<img alt="4 block additive schwarz" class="align-center" id="as" src="_images/AS.png" />
<p><strong>Example of a 4 block-decomposed matrix - Additive Schwarz with overlapping preconditioner (left) and Restricted Additive Schwarz preconditioner (right)</strong></p>
<p>For further details, see <a href="#id65"><span class="problematic" id="id66">:cite:`RAS`</span></a>.</p>
</div>
<div class="section" id="block-jacobi-mpi-preconditioner">
<h3>Block-Jacobi (MPI) Preconditioner<a class="headerlink" href="#block-jacobi-mpi-preconditioner" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv3N10rocalution11BlockJacobiE">
<span id="_CPPv2N10rocalution11BlockJacobiE"></span><span id="rocalution::BlockJacobi"></span><span class="target" id="classrocalution_1_1_block_jacobi"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">BlockJacobi</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution14PreconditionerE" title="rocalution::Preconditioner">Preconditioner</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Block-Jacobi <a class="reference internal" href="#classrocalution_1_1_preconditioner"><span class="std std-ref">Preconditioner</span></a>. </p>
<p>The Block-Jacobi preconditioner is designed to wrap any local preconditioner and apply it in a global block fashion locally on each interior matrix.</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_global_matrix"><span class="std std-ref">GlobalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_global_vector"><span class="std std-ref">GlobalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution11BlockJacobi3SetER6SolverI11LocalMatrixI9ValueTypeE11LocalVectorI9ValueTypeE9ValueTypeE">
<span id="_CPPv2N10rocalution11BlockJacobi3SetER6SolverI11LocalMatrixI9ValueTypeE11LocalVectorI9ValueTypeE9ValueTypeE"></span><span id="rocalution::BlockJacobi::Set__Solver:LocalMatrix:ValueType:.LocalVector:ValueType:.ValueType:R"></span><span class="target" id="classrocalution_1_1_block_jacobi_1ae3e6bd6708cd0826c616a410161378c5"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution11BlockJacobiE" title="rocalution::BlockJacobi">BlockJacobi</a><code class="descclassname">::</code></code><code class="descname">Set</code><span class="sig-paren">(</span><a class="reference internal" href="api.html#_CPPv3N10rocalution6SolverE" title="rocalution::Solver">Solver</a>&lt;<a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrixE" title="rocalution::LocalMatrix">LocalMatrix</a>&lt;ValueType&gt;, <a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVectorE" title="rocalution::LocalVector">LocalVector</a>&lt;ValueType&gt;, ValueType&gt; &amp;<em>precond</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set local preconditioner. </p>
</dd></dl>

<p>The Block-Jacobi (MPI) preconditioner is shown in <code class="xref std std-numref docutils literal notranslate"><span class="pre">BJ</span></code>.</p>
<img alt="4 block jacobi" class="align-center" id="bj" src="_images/BJ.png" />
<p><strong>Example of a 4 block-decomposed matrix - Block-Jacobi preconditioner</strong></p>
</div>
<div class="section" id="block-preconditioner">
<h3>Block Preconditioner<a class="headerlink" href="#block-preconditioner" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv3N10rocalution19BlockPreconditionerE">
<span id="_CPPv2N10rocalution19BlockPreconditionerE"></span><span id="rocalution::BlockPreconditioner"></span><span class="target" id="classrocalution_1_1_block_preconditioner"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">BlockPreconditioner</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution14PreconditionerE" title="rocalution::Preconditioner">Preconditioner</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Block-Preconditioner. </p>
<p>When handling vector fields, typically one can try to use different preconditioners and/or solvers for the different blocks. For such problems, the library provides a block-type preconditioner. This preconditioner builds the following block-type matrix <div class="math notranslate nohighlight">
\[\begin{split} P = \begin{pmatrix} A_{d} &amp; 0 &amp; . &amp; 0 \\ B_{1} &amp; B_{d} &amp; . &amp; 0 \\ . &amp; . &amp; . &amp; . \\ Z_{1} &amp; Z_{2} &amp; . &amp; Z_{d} \end{pmatrix} \end{split}\]</div>
 The solution of <span class="math notranslate nohighlight">\(P\)</span> can be performed in two ways. It can be solved by block-lower-triangular sweeps with inversion of the blocks <span class="math notranslate nohighlight">\(A_{d} \ldots Z_{d}\)</span> and with a multiplication of the corresponding blocks. This is set by <a class="reference internal" href="#classrocalution_1_1_block_preconditioner_1aada7f537faa69378b3bdd7b3d7e2cb35"><span class="std std-ref">SetLSolver()</span></a> (which is the default solution scheme). Alternatively, it can be used only with an inverse of the diagonal <span class="math notranslate nohighlight">\(A_{d} \ldots Z_{d}\)</span> (Block-Jacobi type) by using <a class="reference internal" href="#classrocalution_1_1_block_preconditioner_1a26dc097dd5ea4752d45194761a3d1416"><span class="std std-ref">SetDiagonalSolver()</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution19BlockPreconditioner3SetEiPKiPP6SolverI12OperatorType10VectorType9ValueTypeE">
<span id="_CPPv2N10rocalution19BlockPreconditioner3SetEiPKiPP6SolverI12OperatorType10VectorType9ValueTypeE"></span><span id="rocalution::BlockPreconditioner::Set__i.iCP.Solver:OperatorType.VectorType.ValueType:PP"></span><span class="target" id="classrocalution_1_1_block_preconditioner_1a9657b8371b17b04aae9b0612df42b94e"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution19BlockPreconditionerE" title="rocalution::BlockPreconditioner">BlockPreconditioner</a><code class="descclassname">::</code></code><code class="descname">Set</code><span class="sig-paren">(</span>int <em>n</em>, <em class="property">const</em> int *<em>size</em>, <a class="reference internal" href="api.html#_CPPv3N10rocalution6SolverE" title="rocalution::Solver">Solver</a>&lt;OperatorType, VectorType, ValueType&gt; **<em>D_solver</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set number, size and diagonal solver. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution19BlockPreconditioner17SetDiagonalSolverEv">
<span id="_CPPv2N10rocalution19BlockPreconditioner17SetDiagonalSolverEv"></span><span id="rocalution::BlockPreconditioner::SetDiagonalSolver__void"></span><span class="target" id="classrocalution_1_1_block_preconditioner_1a26dc097dd5ea4752d45194761a3d1416"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution19BlockPreconditionerE" title="rocalution::BlockPreconditioner">BlockPreconditioner</a><code class="descclassname">::</code></code><code class="descname">SetDiagonalSolver</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Set diagonal solver mode. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution19BlockPreconditioner10SetLSolverEv">
<span id="_CPPv2N10rocalution19BlockPreconditioner10SetLSolverEv"></span><span id="rocalution::BlockPreconditioner::SetLSolver__void"></span><span class="target" id="classrocalution_1_1_block_preconditioner_1aada7f537faa69378b3bdd7b3d7e2cb35"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution19BlockPreconditionerE" title="rocalution::BlockPreconditioner">BlockPreconditioner</a><code class="descclassname">::</code></code><code class="descname">SetLSolver</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Set lower triangular sweep mode. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution19BlockPreconditioner21SetExternalLastMatrixERK12OperatorType">
<span id="_CPPv2N10rocalution19BlockPreconditioner21SetExternalLastMatrixERK12OperatorType"></span><span id="rocalution::BlockPreconditioner::SetExternalLastMatrix__OperatorTypeCR"></span><span class="target" id="classrocalution_1_1_block_preconditioner_1a994e8ff9b247c946d3d52621fa43d2bb"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution19BlockPreconditionerE" title="rocalution::BlockPreconditioner">BlockPreconditioner</a><code class="descclassname">::</code></code><code class="descname">SetExternalLastMatrix</code><span class="sig-paren">(</span><em class="property">const</em> OperatorType &amp;<em>mat</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set external last block matrix. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution19BlockPreconditioner14SetPermutationERK11LocalVectorIiE">
<span id="_CPPv2N10rocalution19BlockPreconditioner14SetPermutationERK11LocalVectorIiE"></span><span id="rocalution::BlockPreconditioner::SetPermutation__LocalVector:i:CR"></span><span class="target" id="classrocalution_1_1_block_preconditioner_1a5ec1e5c49befe88fd2de732affcf86fe"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution19BlockPreconditionerE" title="rocalution::BlockPreconditioner">BlockPreconditioner</a><code class="descclassname">::</code></code><code class="descname">SetPermutation</code><span class="sig-paren">(</span><em class="property">const</em> <a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVectorE" title="rocalution::LocalVector">LocalVector</a>&lt;int&gt; &amp;<em>perm</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set permutation vector. </p>
</dd></dl>

</div>
<div class="section" id="variable-preconditioner">
<h3>Variable Preconditioner<a class="headerlink" href="#variable-preconditioner" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="_CPPv3N10rocalution22VariablePreconditionerE">
<span id="_CPPv2N10rocalution22VariablePreconditionerE"></span><span id="rocalution::VariablePreconditioner"></span><span class="target" id="classrocalution_1_1_variable_preconditioner"></span><em class="property">template </em>&lt;<em class="property">class</em> OperatorType, <em class="property">class</em> VectorType, <em class="property">typename</em> ValueType&gt;<br /><em class="property">class </em><code class="descname">VariablePreconditioner</code> : <em class="property">public</em> rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution14PreconditionerE" title="rocalution::Preconditioner">Preconditioner</a>&lt;OperatorType, VectorType, ValueType&gt;<br /></dt>
<dd><p>Variable <a class="reference internal" href="#classrocalution_1_1_preconditioner"><span class="std std-ref">Preconditioner</span></a>. </p>
<p>The Variable <a class="reference internal" href="#classrocalution_1_1_preconditioner"><span class="std std-ref">Preconditioner</span></a> can hold a selection of preconditioners. Thus, any type of preconditioners can be combined. As example, the variable preconditioner can combine <a class="reference internal" href="#classrocalution_1_1_jacobi"><span class="std std-ref">Jacobi</span></a>, <a class="reference internal" href="#classrocalution_1_1_g_s"><span class="std std-ref">GS</span></a> and <a class="reference internal" href="#classrocalution_1_1_i_l_u"><span class="std std-ref">ILU</span></a> – then, the first iteration of the iterative solver will apply <a class="reference internal" href="#classrocalution_1_1_jacobi"><span class="std std-ref">Jacobi</span></a>, the second iteration will apply <a class="reference internal" href="#classrocalution_1_1_g_s"><span class="std std-ref">GS</span></a> and the third iteration will apply <a class="reference internal" href="#classrocalution_1_1_i_l_u"><span class="std std-ref">ILU</span></a>. After that, the solver will start again with <a class="reference internal" href="#classrocalution_1_1_jacobi"><span class="std std-ref">Jacobi</span></a>, <a class="reference internal" href="#classrocalution_1_1_g_s"><span class="std std-ref">GS</span></a>, <a class="reference internal" href="#classrocalution_1_1_i_l_u"><span class="std std-ref">ILU</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">OperatorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_matrix"><span class="std std-ref">LocalMatrix</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">VectorType</span></code>: - can be <a class="reference internal" href="#classrocalution_1_1_local_vector"><span class="std std-ref">LocalVector</span></a> </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueType</span></code>: - can be float, double, std::complex&lt;float&gt; or std::complex&lt;double&gt; </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution22VariablePreconditioner17SetPreconditionerEiPP6SolverI12OperatorType10VectorType9ValueTypeE">
<span id="_CPPv2N10rocalution22VariablePreconditioner17SetPreconditionerEiPP6SolverI12OperatorType10VectorType9ValueTypeE"></span><span id="rocalution::VariablePreconditioner::SetPreconditioner__i.Solver:OperatorType.VectorType.ValueType:PP"></span><span class="target" id="classrocalution_1_1_variable_preconditioner_1aca967cd3b1365901ff36b56df9be1319"></span>void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution22VariablePreconditionerE" title="rocalution::VariablePreconditioner">VariablePreconditioner</a><code class="descclassname">::</code></code><code class="descname">SetPreconditioner</code><span class="sig-paren">(</span>int <em>n</em>, <a class="reference internal" href="api.html#_CPPv3N10rocalution6SolverE" title="rocalution::Solver">Solver</a>&lt;OperatorType, VectorType, ValueType&gt; **<em>precond</em><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the preconditioner sequence. </p>
</dd></dl>

</div>
</div>
<div class="section" id="backends">
<h2>Backends<a class="headerlink" href="#backends" title="Permalink to this headline">¶</a></h2>
<p>The support of accelerator devices is embedded in the structure of rocALUTION. The primary goal is to use this technology whenever possible to decrease the computational time.
.. note:: Not all functions are ported and present on the accelerator backend. This limited functionality is natural, since not all operations can be performed efficiently on the accelerators (e.g. sequential algorithms, I/O from the file system, etc.).</p>
<p>Currently, rocALUTION supports HIP capable GPUs starting with ROCm 1.9. Due to its design, the library can be easily extended to support future accelerator technologies. Such an extension of the library will not reflect the algorithms which are based on it.</p>
<p>If a particular function is not implemented for the used accelerator, the library will move the object to the host and compute the routine there. In this case a warning message of level 2 will be printed. For example, if the user wants to perform an ILUT factorization on the HIP backend which is currently not available, the library will move the object to the host, perform the routine there and print the following warning message</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">***</span> <span class="n">warning</span><span class="p">:</span> <span class="n">LocalMatrix</span><span class="p">::</span><span class="n">ILUTFactorize</span><span class="p">()</span> <span class="ow">is</span> <span class="n">performed</span> <span class="n">on</span> <span class="n">the</span> <span class="n">host</span>
</pre></div>
</div>
<div class="section" id="moving-objects-to-and-from-the-accelerator">
<h3>Moving Objects To and From the Accelerator<a class="headerlink" href="#moving-objects-to-and-from-the-accelerator" title="Permalink to this headline">¶</a></h3>
<p>All objects in rocALUTION can be moved to the accelerator and to the host.</p>
<dl class="function">
<dt id="_CPPv3N10rocalution14BaseRocalution17MoveToAcceleratorEv">
<span id="_CPPv2N10rocalution14BaseRocalution17MoveToAcceleratorEv"></span><span id="rocalution::BaseRocalution::MoveToAccelerator__void"></span><span class="target" id="classrocalution_1_1_base_rocalution_1a2238fc9adc895dff8744a5e470b79282"></span><em class="property">virtual</em> void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution14BaseRocalutionE" title="rocalution::BaseRocalution">BaseRocalution</a><code class="descclassname">::</code></code><code class="descname">MoveToAccelerator</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span> = 0<br /></dt>
<dd><p>Move the object to the accelerator backend. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution14BaseRocalution10MoveToHostEv">
<span id="_CPPv2N10rocalution14BaseRocalution10MoveToHostEv"></span><span id="rocalution::BaseRocalution::MoveToHost__void"></span><span class="target" id="classrocalution_1_1_base_rocalution_1a4e572619edf6570b746c263e3b9e82e9"></span><em class="property">virtual</em> void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution14BaseRocalutionE" title="rocalution::BaseRocalution">BaseRocalution</a><code class="descclassname">::</code></code><code class="descname">MoveToHost</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span> = 0<br /></dt>
<dd><p>Move the object to the host backend. </p>
</dd></dl>

<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">LocalMatrix</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span> <span class="n">mat</span><span class="p">;</span>
<span class="n">LocalVector</span><span class="o">&lt;</span><span class="n">ValueType</span><span class="o">&gt;</span> <span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">;</span>

<span class="c1">// Perform matrix vector multiplication on the host</span>
<span class="n">mat</span><span class="p">.</span><span class="n">Apply</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vec2</span><span class="p">);</span>

<span class="c1">// Move data to the accelerator</span>
<span class="n">mat</span><span class="p">.</span><span class="n">MoveToAccelerator</span><span class="p">();</span>
<span class="n">vec1</span><span class="p">.</span><span class="n">MoveToAccelerator</span><span class="p">();</span>
<span class="n">vec2</span><span class="p">.</span><span class="n">MoveToAccelerator</span><span class="p">();</span>

<span class="c1">// Perform matrix vector multiplication on the accelerator</span>
<span class="n">mat</span><span class="p">.</span><span class="n">Apply</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vec2</span><span class="p">);</span>

<span class="c1">// Move data to the host</span>
<span class="n">mat</span><span class="p">.</span><span class="n">MoveToHost</span><span class="p">();</span>
<span class="n">vec1</span><span class="p">.</span><span class="n">MoveToHost</span><span class="p">();</span>
<span class="n">vec2</span><span class="p">.</span><span class="n">MoveToHost</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="asynchronous-transfers">
<h3>Asynchronous Transfers<a class="headerlink" href="#asynchronous-transfers" title="Permalink to this headline">¶</a></h3>
<p>The rocALUTION library also provides asynchronous transfers of data between host and HIP backend.</p>
<dl class="function">
<dt id="_CPPv3N10rocalution14BaseRocalution22MoveToAcceleratorAsyncEv">
<span id="_CPPv2N10rocalution14BaseRocalution22MoveToAcceleratorAsyncEv"></span><span id="rocalution::BaseRocalution::MoveToAcceleratorAsync__void"></span><span class="target" id="classrocalution_1_1_base_rocalution_1a1c37dbcf976261be544dc6c66502182a"></span><em class="property">virtual</em> void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution14BaseRocalutionE" title="rocalution::BaseRocalution">BaseRocalution</a><code class="descclassname">::</code></code><code class="descname">MoveToAcceleratorAsync</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Move the object to the accelerator backend with async move. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution14BaseRocalution15MoveToHostAsyncEv">
<span id="_CPPv2N10rocalution14BaseRocalution15MoveToHostAsyncEv"></span><span id="rocalution::BaseRocalution::MoveToHostAsync__void"></span><span class="target" id="classrocalution_1_1_base_rocalution_1a6491e18ff3f4809b42c3c3c94d1bc1f2"></span><em class="property">virtual</em> void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution14BaseRocalutionE" title="rocalution::BaseRocalution">BaseRocalution</a><code class="descclassname">::</code></code><code class="descname">MoveToHostAsync</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Move the object to the host backend with async move. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N10rocalution14BaseRocalution4SyncEv">
<span id="_CPPv2N10rocalution14BaseRocalution4SyncEv"></span><span id="rocalution::BaseRocalution::Sync__void"></span><span class="target" id="classrocalution_1_1_base_rocalution_1a67986dbebc9b025e6ac30be4f85f784b"></span><em class="property">virtual</em> void <code class="descclassname">rocalution::<a class="reference internal" href="api.html#_CPPv3N10rocalution14BaseRocalutionE" title="rocalution::BaseRocalution">BaseRocalution</a><code class="descclassname">::</code></code><code class="descname">Sync</code><span class="sig-paren">(</span>void<span class="sig-paren">)</span><br /></dt>
<dd><p>Sync (the async move) </p>
</dd></dl>

<p>This can be done with <code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::LocalVector::CopyFromAsync()</span></code> and <a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalMatrix13CopyFromAsyncERK11LocalMatrixI9ValueTypeE" title="rocalution::LocalMatrix::CopyFromAsync"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::LocalMatrix::CopyFromAsync()</span></code></a> or with <cite>MoveToAcceleratorAsync()</cite> and <cite>MoveToHostAsync()</cite>. These functions return immediately and perform the asynchronous transfer in background mode. The synchronization is done with <cite>Sync()</cite>.</p>
<p>When using the <cite>MoveToAcceleratorAsync()</cite> and <cite>MoveToHostAsync()</cite> functions, the object will still point to its original location (i.e. host for calling <cite>MoveToAcceleratorAsync()</cite> and accelerator for <cite>MoveToHostAsync()</cite>). The object will switch to the new location after the <cite>Sync()</cite> function is called.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The objects should not be modified during an active asynchronous transfer. However, if this happens, the values after the synchronization might be wrong.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">To use the asynchronous transfers, you need to enable the pinned memory allocation. Uncomment <cite>#define ROCALUTION_HIP_PINNED_MEMORY</cite> in <cite>src/utils/allocate_free.hpp</cite>.</p>
</div>
</div>
<div class="section" id="systems-without-accelerators">
<h3>Systems without Accelerators<a class="headerlink" href="#systems-without-accelerators" title="Permalink to this headline">¶</a></h3>
<p>rocALUTION provides full code compatibility on systems without accelerators, the user can take the code from the GPU system, re-compile the same code on a machine without a GPU and it will provide the same results. Any calls to <a class="reference internal" href="api.html#_CPPv3N10rocalution14BaseRocalution17MoveToAcceleratorEv" title="rocalution::BaseRocalution::MoveToAccelerator"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::BaseRocalution::MoveToAccelerator()</span></code></a> and <a class="reference internal" href="api.html#_CPPv3N10rocalution14BaseRocalution10MoveToHostEv" title="rocalution::BaseRocalution::MoveToHost"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::BaseRocalution::MoveToHost()</span></code></a> will be ignored.</p>
</div>
</div>
<div class="section" id="memory-allocations">
<h2>Memory Allocations<a class="headerlink" href="#memory-allocations" title="Permalink to this headline">¶</a></h2>
<p>All data which is passed to and from rocALUTION is using the memory handling functions described in the code. By default, the library uses standard C++ <em>new</em> and <em>delete</em> functions for the host data. This can be changed by modifying <cite>src/utils/allocate_free.cpp</cite>.</p>
<div class="section" id="allocation-problems">
<h3>Allocation Problems<a class="headerlink" href="#allocation-problems" title="Permalink to this headline">¶</a></h3>
<p>If the allocation fails, the library will report an error and exits. If the user requires a special treatment, it has to be placed in <cite>src/utils/allocate_free.cpp</cite>.</p>
</div>
<div class="section" id="memory-alignment">
<h3>Memory Alignment<a class="headerlink" href="#memory-alignment" title="Permalink to this headline">¶</a></h3>
<p>The library can also handle special memory alignment functions. This feature need to be uncommented before the compilation process in <cite>src/utils/allocate_free.cpp</cite>.</p>
</div>
<div class="section" id="pinned-memory-allocation-hip">
<h3>Pinned Memory Allocation (HIP)<a class="headerlink" href="#pinned-memory-allocation-hip" title="Permalink to this headline">¶</a></h3>
<p>By default, the standard host memory allocation is realized by C++ <em>new</em> and <em>delete</em>. For faster PCI-Express transfers on HIP backend, the user can also use pinned host memory. This can be activated by uncommenting the corresponding macro in <cite>src/utils/allocate_free.hpp</cite>.</p>
</div>
</div>
<div class="section" id="remarks">
<h2>Remarks<a class="headerlink" href="#remarks" title="Permalink to this headline">¶</a></h2>
<div class="section" id="performance">
<h3>Performance<a class="headerlink" href="#performance" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Solvers can be built on the accelerator. In many cases, this is faster compared to building on the host.</li>
<li>Small-sized problems tend to perform better on the host (CPU), due to the good caching system, while large-sized problems typically perform better on the accelerator devices.</li>
<li>Avoid accessing vectors using [] operators. Use techniques based on <a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVector10SetDataPtrEPP9ValueTypeNSt6stringEi" title="rocalution::LocalVector::SetDataPtr"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::LocalVector::SetDataPtr()</span></code></a> and <a class="reference internal" href="api.html#_CPPv3N10rocalution11LocalVector12LeaveDataPtrEPP9ValueType" title="rocalution::LocalVector::LeaveDataPtr"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::LocalVector::LeaveDataPtr()</span></code></a> instead.</li>
<li>By default, the OpenMP backend picks the maximum number of threads available. However, if your CPU supports SMT, it will allow to run two times more threads than number of cores. This, in many cases, leads to lower performance. You may observe a performance increase by setting the number of threads (see <a class="reference internal" href="api.html#_CPPv3N10rocalution26set_omp_threads_rocalutionEi" title="rocalution::set_omp_threads_rocalution"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::set_omp_threads_rocalution()</span></code></a>) equal to the number of physical cores.</li>
<li>If you need to solve a system with multiple right-hand-sides, avoid constructing the solver/preconditioner every time.</li>
<li>If you are solving similar linear systems, you might want to consider to use the same preconditioner to avoid long building phases.</li>
<li>In most of the cases, the classical CSR matrix format performs very similar to all other formats on the CPU. On accelerators with many-cores (such as GPUs), formats such as DIA and ELL typically perform better. However, for general sparse matrices one could use HYB format to avoid large memory overhead. The multi-colored preconditioners can be performed in ELL for most of the matrices.</li>
<li>Not all matrix conversions are performed on the device, the platform will give you a warning if the object need to be moved.</li>
<li>If you are deploying the rocALUTION library into another software framework try to design your integration functions to avoid <a class="reference internal" href="api.html#_CPPv3N10rocalution15init_rocalutionEii" title="rocalution::init_rocalution"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::init_rocalution()</span></code></a> and <a class="reference internal" href="api.html#_CPPv3N10rocalution15stop_rocalutionEv" title="rocalution::stop_rocalution"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::stop_rocalution()</span></code></a> every time you call a solver in the library.</li>
<li>Be sure to compile the library with the correct optimization level (-O3).</li>
<li>Check, if your solver is really performed on the accelerator by printing the matrix information (<a class="reference internal" href="api.html#_CPPv3NK10rocalution14BaseRocalution4InfoEv" title="rocalution::BaseRocalution::Info"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::BaseRocalution::Info()</span></code></a>) just before calling the <a class="reference internal" href="api.html#_CPPv3N10rocalution6Solver5SolveERK10VectorTypeP10VectorType" title="rocalution::Solver::Solve"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::Solver::Solve()</span></code></a> function.</li>
<li>Check the configuration of the library for your hardware with <a class="reference internal" href="api.html#_CPPv3N10rocalution15info_rocalutionEv" title="rocalution::info_rocalution"><code class="xref cpp cpp-func docutils literal notranslate"><span class="pre">rocalution::info_rocalution()</span></code></a>.</li>
<li>Mixed-Precision defect correction technique is recommended for accelerators (e.g. GPUs) with partial or no double precision support. The stopping criteria for the inner solver has to be tuned well for good performance.</li>
</ul>
</div>
<div class="section" id="accelerators">
<h3>Accelerators<a class="headerlink" href="#accelerators" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Avoid PCI-Express communication whenever possible (such as copying data from/to the accelerator). Also check the internal structure of the functions.</li>
<li>Pinned memory allocation (page-locked) can be used for all host memory allocations when using the HIP backend. This provides faster transfers over the PCI-Express and allows asynchronous data movement. By default, this option is disabled. To enable the pinned memory allocation uncomment <cite>#define ROCALUTION_HIP_PINNED_MEMORY</cite> in file <cite>src/utils/allocate_free.hpp</cite>.</li>
<li>Asynchronous transfers are available for the HIP backend.</li>
</ul>
</div>
<div class="section" id="correctness">
<h3>Correctness<a class="headerlink" href="#correctness" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>If you are assembling or modifying your matrix, you can check it in octave/MATLAB by just writing it into a matrix-market file and read it via <cite>mmread()</cite> function, see <a href="#id67"><span class="problematic" id="id68">:cite:`mm-read`</span></a>. You can also input a MATLAB/octave matrix in such a way.</li>
<li>Be sure, to set the correct relative and absolute tolerance values for your problem.</li>
<li>Check the computation of the relative stopping criteria, if it is based on <span class="math notranslate nohighlight">\(|b-Ax^k|_2/|b-Ax^0|_2\)</span> or <span class="math notranslate nohighlight">\(|b-Ax^k|_2/|b|_2\)</span>.</li>
<li>Solving very ill-conditioned problems by iterative methods without a proper preconditioning technique might produce wrong results. The solver could stop by showing a low relative tolerance based on the residual but this might be wrong.</li>
<li>Building the Krylov subspace for many ill-conditioned problems could be a tricky task. To ensure orthogonality in the subspace you might want to perform double orthogonalization (i.e. re-orthogonalization) to avoid rounding errors.</li>
<li>If you read/write matrices/vectors from files, check the ASCII format of the values (e.g. 34.3434 or 3.43434E + 01).</li>
</ul>
</div>
</div>
<div class="section" id="change-log">
<h2>Change Log<a class="headerlink" href="#change-log" title="Permalink to this headline">¶</a></h2>
<div class="section" id="beta-for-rocm-1-9">
<h3>1.3.2.0-beta for ROCm 1.9<a class="headerlink" href="#beta-for-rocm-1-9" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Initial pre-release version of the rocALUTION library</li>
</ul>
</div>
</div>
<div class="section" id="bibliography">
<h2>Bibliography<a class="headerlink" href="#bibliography" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="api.html" class="btn btn-neutral float-right" title="API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral" title="Welcome to rocALUTION’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014, Thomas Edvalson.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0.0',
            LANGUAGE:'None',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>